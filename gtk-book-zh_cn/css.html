<!DOCTYPE HTML>
<html lang="zh_cn" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CSS - 基于 Rust 和 GTK 4 的 GUI 开发</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/style.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">简介</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.</strong> 安装</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation_linux.html"><strong aria-hidden="true">1.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="installation_macos.html"><strong aria-hidden="true">1.2.</strong> macOS</a></li><li class="chapter-item expanded "><a href="installation_windows.html"><strong aria-hidden="true">1.3.</strong> Windows</a></li></ol></li><li class="chapter-item expanded "><a href="project_setup.html"><strong aria-hidden="true">2.</strong> 项目设置</a></li><li class="chapter-item expanded "><a href="hello_world.html"><strong aria-hidden="true">3.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="widgets.html"><strong aria-hidden="true">4.</strong> 控件</a></li><li class="chapter-item expanded "><a href="g_object_concepts.html"><strong aria-hidden="true">5.</strong> GObject 相关概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="g_object_memory_management.html"><strong aria-hidden="true">5.1.</strong> 内存管理</a></li><li class="chapter-item expanded "><a href="g_object_subclassing.html"><strong aria-hidden="true">5.2.</strong> 子类化</a></li><li class="chapter-item expanded "><a href="g_object_values.html"><strong aria-hidden="true">5.3.</strong> 泛型值</a></li><li class="chapter-item expanded "><a href="g_object_properties.html"><strong aria-hidden="true">5.4.</strong> 属性</a></li><li class="chapter-item expanded "><a href="g_object_signals.html"><strong aria-hidden="true">5.5.</strong> 信号</a></li></ol></li><li class="chapter-item expanded "><a href="main_event_loop.html"><strong aria-hidden="true">6.</strong> 主事件循环</a></li><li class="chapter-item expanded "><a href="settings.html"><strong aria-hidden="true">7.</strong> 设置(Settings)</a></li><li class="chapter-item expanded "><a href="saving_window_state.html"><strong aria-hidden="true">8.</strong> 保存窗口状态</a></li><li class="chapter-item expanded "><a href="list_widgets.html"><strong aria-hidden="true">9.</strong> 列表控件</a></li><li class="chapter-item expanded "><a href="composite_templates.html"><strong aria-hidden="true">10.</strong> 复合模板</a></li><li class="chapter-item expanded "><a href="todo_1.html"><strong aria-hidden="true">11.</strong> 创建一个简单的待办事项应用</a></li><li class="chapter-item expanded "><a href="actions.html"><strong aria-hidden="true">12.</strong> Actions</a></li><li class="chapter-item expanded "><a href="todo_2.html"><strong aria-hidden="true">13.</strong> 控制待办事项应用的状态</a></li><li class="chapter-item expanded "><a href="css.html" class="active"><strong aria-hidden="true">14.</strong> CSS</a></li><li class="chapter-item expanded "><a href="libadwaita.html"><strong aria-hidden="true">15.</strong> Libadwaita</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="todo_3.html"><strong aria-hidden="true">15.1.</strong> 让待办事项应用使用 Libadwaita</a></li><li class="chapter-item expanded "><a href="todo_4.html"><strong aria-hidden="true">15.2.</strong> 添加收藏夹</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">基于 Rust 和 GTK 4 的 GUI 开发</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Mario-Hero/GTK-Rust-Book-zh_cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="css"><a class="header" href="#css">CSS</a></h1>
<p>当您想改变网站风格时，需要使用 <a href="https://de.wikipedia.org/wiki/Cascading_Style_Sheets">CSS</a>. 同样，GTK 也支持自己的 CSS 变体，以便为应用程序设计样式。</p>
<blockquote>
<p>在本章中，我们不会对所用的每一种语法进行解释。 如果你是 CSS 的新手，或者需要复习一下，请查看 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Syntax">MDN Web 文档</a>。</p>
</blockquote>
<p>比方说，我们有一个按钮，希望将其字体颜色设置为品红色。 每种类型的控件都有一个对应的 CSS 节点。 对于 <code>gtk::Button</code>，这个节点被称为 <code>button</code>. 因此，我们创建了一个内容如下的 <code>style.css</code> 文件：</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/1/style.css">listings/css/1/style.css</a></p>
<pre><code class="language-css">button {
  color: magenta;
}
</code></pre>
<p>接下来，我们需要在应用程序的启动步骤中加载 CSS 文件。 像往常一样，控件是在"激活"步骤中创建的。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/1/main.rs">listings/css/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gdk::Display;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gdk, glib, Application, ApplicationWindow, Button, CssProvider};
</span><span class="boring">
</span>const APP_ID: &amp;str = "org.gtk_rs.Css1";

fn main() -&gt; glib::ExitCode {
    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to signals
    app.connect_startup(|_| load_css());
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

fn load_css() {
    // Load the CSS file and add it to the provider
    let provider = CssProvider::new();
    provider.load_from_string(include_str!("style.css"));

    // Add the provider to the default screen
    gtk::style_context_add_provider_for_display(
        &amp;Display::default().expect("Could not connect to a display."),
        &amp;provider,
        gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
    );
}

fn build_ui(app: &amp;Application) {
    // Create button
    let button = Button::builder()
        .label("Press me!")
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // Create a new window and present it
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .child(&amp;button)
        .build();
    window.present();
}</code></pre>
<p>现在运行应用程序时，我们会发现按钮和窗口上的"关闭"按钮都变成了品红色。 这可能不是我们想要的结果，但我们的 CSS 代码段就是这么做的。 我们没有指定该规则应适用于哪个按钮，因此它同时适用于全部两个按钮。</p>
<div style="text-align:center"><img src="img/css_1.png" alt="Window with magenta text"/></div>
<blockquote>
<p>在使用 CSS 时，<code>GtkInspector</code> 可谓得心应手（不仅如此）。 确保您的应用程序窗口处于焦点状态，然后按下  <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>D</kbd>. 这时会弹出一个窗口，您可以浏览甚至操作应用程序的状态。 打开 CSS 视图，用以下代码段覆盖按钮颜色。</p>
<pre><code class="language-css">button {
color: blue;
}
</code></pre>
<p>使用暂停按钮可以切换 CSS 代码的活动状态。</p>
</blockquote>
<h2 id="gtk-实现的样式类"><a class="header" href="#gtk-实现的样式类">GTK 实现的样式类</a></h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors">类选择器</a>是选择 CSS 规则适用于哪些特定元素的一种方法。 GTK 为许多控件添加了样式类，通常取决于它们的内容。 例如，当 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Button.html#css-nodes"><code>gtk::Button</code></a> 的内容是一个标签时，它就会获得 <code>text-button</code> 样式类。 因此，我们创建了一条新的 CSS 规则，它只适用于样式类为 <code>text_button</code> 的按钮节点。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/2/style.css">listings/css/2/style.css</a></p>
<pre><code class="language-css">button.text-button {
  color: magenta;
}
</code></pre>
<p>Now only the font of our button becomes magenta.</p>
<div style="text-align:center"><img src="img/css_2.png" alt="Now only the text of the button is magenta"/></div>
<h2 id="添加你自己的样式类"><a class="header" href="#添加你自己的样式类">添加你自己的样式类</a></h2>
<p>通过 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.WidgetExt.html#tymethod.add_css_class"><code>add_css_class</code></a>，我们还可以为控件添加自己的样式类。 这种方法的一种使用情况是，当你希望一条规则适用于一组精心挑选的部件时。 例如，我们有两个按钮，但只想让其中一个使用品红色字体。 依靠 GTK 添加的某个样式类是没有用的，因为两个按钮的样式是一样的。 这就是为什么我们要为第一个按钮添加 <code>button-1</code> 样式类。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/3/main.rs">listings/css/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gdk::Display;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gdk, glib, Application, ApplicationWindow, Button, CssProvider};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Css3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to signals
</span><span class="boring">    app.connect_startup(|_| load_css());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn load_css() {
</span><span class="boring">    // Load the CSS file and add it to the provider
</span><span class="boring">    let provider = CssProvider::new();
</span><span class="boring">    provider.load_from_string(include_str!("style.css"));
</span><span class="boring">
</span><span class="boring">    // Add the provider to the default screen
</span><span class="boring">    gtk::style_context_add_provider_for_display(
</span><span class="boring">        &amp;Display::default().expect("Could not connect to a display."),
</span><span class="boring">        &amp;provider,
</span><span class="boring">        gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create buttons
    let button_1 = Button::with_label("Press me!");
    let button_2 = Button::with_label("Press me!");

    button_1.add_css_class("button-1");
<span class="boring">
</span><span class="boring">    // Create `gtk_box` and add buttons
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a new window and present it
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>然后，我们创建一条 CSS 规则，该规则适用于样式类为 <code>button-1</code> 的按钮节点。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/3/style.css">listings/css/3/style.css</a></p>
<pre><code class="language-css">button.button-1 {
  color: magenta;
}
</code></pre>
<p>我们可以看到，这样只有第一个按钮被染成了品红色。</p>
<div style="text-align:center"><img src="img/css_3.png" alt="Two buttons and only the left one has magenta font"/></div>
<h2 id="指定控件名称"><a class="header" href="#指定控件名称">指定控件名称</a></h2>
<p>如果您希望您的规则只适用于一个部件，那么使用样式类进行匹配也是可以的。 不过，理想情况下，您应该给控件取一个名字，然后用这个名字进行匹配。 这样，你的意图就会更明确，而不是匹配可适用于多个控件的样式类。</p>
<p>同样，我们有两个按钮，但只想将其中一个按钮染成洋红色。 我们使用 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.WidgetExt.html#tymethod.set_widget_name"><code>set_widget_name</code></a> 设置第一个按钮的名称。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/4/main.rs">listings/css/4/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gdk::Display;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gdk, glib, Application, ApplicationWindow, Button, CssProvider};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Css4";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to signals
</span><span class="boring">    app.connect_startup(|_| load_css());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn load_css() {
</span><span class="boring">    // Load the CSS file and add it to the provider
</span><span class="boring">    let provider = CssProvider::new();
</span><span class="boring">    provider.load_from_string(include_str!("style.css"));
</span><span class="boring">
</span><span class="boring">    // Add the provider to the default screen
</span><span class="boring">    gtk::style_context_add_provider_for_display(
</span><span class="boring">        &amp;Display::default().expect("Could not connect to a display."),
</span><span class="boring">        &amp;provider,
</span><span class="boring">        gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create buttons
    let button_1 = Button::with_label("Press me!");
    let button_2 = Button::with_label("Press me!");

    button_1.set_widget_name("button-1");
<span class="boring">
</span><span class="boring">    // Create `gtk_box` and add buttons
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a new window and present it
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>然后，创建一条适用于名称为 <code>button-1</code> 的按钮节点的 CSS 规则。 名称在 <code>#</code> 符号后指定。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/4/style.css">listings/css/4/style.css</a></p>
<pre><code class="language-css">button#button-1 {
  color: magenta;
}
</code></pre>
<p>同样，样式规则只适用于第一个按钮。</p>
<div style="text-align:center"><img src="img/css_4.png" alt="Two buttons and only the left one has magenta font"/></div>
<h2 id="gtk-提供的-css-规则"><a class="header" href="#gtk-提供的-css-规则">GTK 提供的 CSS 规则</a></h2>
<p>某些样式非常常见，GTK 为其提供了 CSS 规则。 例如，如果您想在按钮上标明 "破坏性动作"或"建议的动作"，您就不必提供自己的 CSS 规则。 您只需在按钮上添加 "破坏性动作(destructive-action)"或 "建议的动作(suggested-action)"样式类即可。 大多数控件都会在 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Button.html#css-nodes">CSS 节点</a>下的文档中记录这些规则。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/5/main.rs">listings/css/5/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Css5";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to signals
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create buttons
    let button_1 = Button::with_label("Destructive");
    let button_2 = Button::with_label("Suggested");

    button_1.add_css_class("destructive-action");
    button_2.add_css_class("suggested-action");
<span class="boring">
</span><span class="boring">    // Create `gtk_box` and add buttons
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .spacing(6)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a new window and present it
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<div style="text-align:center"><img src="img/css_5.png" alt="The left button is red, the right one is blue"/></div>
<h2 id="界面生成器"><a class="header" href="#界面生成器">界面生成器</a></h2>
<p>我们还可以使用界面生成器添加样式类。 只需在 widget 中添加 <code>&lt;style&gt;</code> 元素即可。 <code>&lt;style&gt;</code> 元素与 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Widget.html#gtkwidget-as-gtkbuildable"><code>gtk::Widget</code></a> 一起记录。 再次添加破坏性和建议的按钮，看起来就像这样：</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/6/window/window.ui">listings/css/6/window/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title" translatable="yes"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkBox"&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;
        &lt;property name="spacing"&gt;6&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkButton"&gt;
            &lt;property name="label"&gt;Destructive&lt;/property&gt;
            &lt;style&gt;
              &lt;class name="destructive-action"/&gt;
            &lt;/style&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class="GtkButton"&gt;
            &lt;property name="label"&gt;Suggested&lt;/property&gt;
            &lt;style&gt;
              &lt;class name="suggested-action"/&gt;
            &lt;/style&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<h2 id="伪类"><a class="header" href="#伪类">伪类</a></h2>
<p>有时，你希望 CSS 规则在比样式类更精确的条件下应用。 这就是<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes">伪类</a>的用武之地。 让我们使用名称为 <code>button-1</code> 的按钮来演示这一概念。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/7/window/window.ui">listings/css/7/window/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title" translatable="yes"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkButton"&gt;
        &lt;property name="label"&gt;Hover over me!&lt;/property&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;
        &lt;property name="name"&gt;button-1&lt;/property&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>通过添加伪类 <code>hover</code>，我们表示希望这条规则只适用于当鼠标指针悬停在名称为 <code>button-1</code> 的按钮节点。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/7/style.css">listings/css/7/style.css</a></p>
<pre><code class="language-css">button#button-1:hover {
  color: magenta;
  background: yellow;
}
</code></pre>
<p>现在，如果我们将鼠标悬停在按钮上，就会发现在一瞬间按钮的背景变成了黄色，文字变成了品红色。 当我们移除光标后，按钮又恢复到原来的状态。</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/css_6.webm" type="video/webm">
  <p>A video which shows that hovering over one button makes its background yellow and text red</p>
 </video>
</div>
<h2 id="节点"><a class="header" href="#节点">节点</a></h2>
<p>在前面的示例中，一个部件总是对应一个 CSS 节点。 但情况并非总是如此。 例如，<a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.MenuButton.html"><code>gtk::MenuButton</code></a>  就有多个 CSS 节点。</p>
<p>首先，我们创建一个 <code>MenuButton</code>.</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/8/window/window.ui">listings/css/8/window/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title" translatable="yes"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkMenuButton"&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>您可以让菜单按钮( <code>MenuButton</code> )显示图标或标签。 如果您选择两者都不显示，就像我们目前所做的那样，它将显示一个箭头图像。</p>
<p><a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.MenuButton.html#css-nodes">CSS 节点</a>的继承树就显示了这种情况：</p>
<pre><code>menubutton
╰── button.toggle
    ╰── &lt;content&gt;
         ╰── [arrow]
</code></pre>
<p>我们看到，<code>menubutton</code> 节点有子节点，而子节点本身也有子节点和附加样式类。 现在我们知道，必须添加一条适用于箭头(<code>arrow</code>)节点的 CSS 规则，它是 <code>menubutton</code> 的子节点。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/8/style.css">listings/css/8/style.css</a></p>
<pre><code class="language-css">menubutton arrow {
  color: magenta;
}
</code></pre>
<p>的确，我们得到了一个带有品红色箭头的 <code>MenuButton</code>。</p>
<div style="text-align:center"><img src="img/css_8.png" alt="Button with a magenta symbol in it"/></div>
<h2 id="设置-css-名称并使用导出颜色"><a class="header" href="#设置-css-名称并使用导出颜色">设置 CSS 名称并使用导出颜色</a></h2>
<p>我们已经学习了如何使用伪类为部件实例命名。 但如果我们有一个自定义控件，并想引用它的所有实例，该怎么办呢？ 让我们通过再次用待办事项应用来看看如何处理这种情况。</p>
<p><code>TaskRow</code> 类继承于 <code>gtk::Box</code>，因此我们可以只匹配节点 <code>box</code>. 但是，在这种情况下，我们也会匹配其他 <code>gtk::Box</code> 的实例。 我们要做的是为 <code>TaskRow</code> 赋予自己的 CSS 名称。 调用 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/subclass/widget/trait.WidgetClassExt.html#method.set_css_name"><code>set_css_name</code> </a> 时，我们会更改控件类的 CSS 节点名称。 在我们的例子中，<code>TaskRow</code> 就对应于节点 <code>task-row</code>.</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/3/task_row/imp.rs">listings/todo/3/task_row/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">use glib::Binding;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CheckButton, CompositeTemplate, Label};
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(Default, CompositeTemplate)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo3/task_row.ui")]
</span><span class="boring">pub struct TaskRow {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub completed_button: TemplateChild&lt;CheckButton&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub content_label: TemplateChild&lt;Label&gt;,
</span><span class="boring">    // Vector holding the bindings to properties of `TaskObject`
</span><span class="boring">    pub bindings: RefCell&lt;Vec&lt;Binding&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for TaskRow {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "TodoTaskRow";
    type Type = super::TaskRow;
    type ParentType = gtk::Box;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();
        klass.set_css_name("task-row");
    }

    fn instance_init(obj: &amp;glib::subclass::InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for TaskRow {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for TaskRow {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all boxes
</span><span class="boring">impl BoxImpl for TaskRow {}</span></code></pre>
<p>现在该如何处理新的节点名称呢？ 让我们再次更改背景颜色，但这次有点不一样，我们将使用名为 <code>success_color</code> 的颜色。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/3/resources/style.css">listings/todo/3/resources/style.css</a></p>
<pre><code class="language-css">task-row {
  background-color: @success_color;
}
</code></pre>
<p>GTK 的默认(<code>Default</code>)样式表为各种用途提供了预定义的颜色。 在<a href="https://gitlab.gnome.org/GNOME/gtk/-/blob/b2c227e9c57839a2a4e24462a71ae0bad9a95264/gtk/theme/Default/_colors-public.scss">源代码</a>中，我们可以找到 <code>success_color</code> 颜色，在实际场景中，它用来表示成功。 然后，我们可以通过在名称前添加 @ 来访问预定义的颜色。</p>
<p>我们还必须在 <code>resources.gresource.xml</code> 中添加 <code>style.css</code>.</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/3/resources/resources.gresource.xml">listings/todo/3/resources/resources.gresource.xml</a></p>
<pre><code class="language-diff"> &lt;?xml version="1.0" encoding="UTF-8"?&gt;
 &lt;gresources&gt;
   &lt;gresource prefix="/org/gtk_rs/Todo3/"&gt;
     &lt;file compressed="true" preprocess="xml-stripblanks" alias="gtk/help-overlay.ui"&gt;shortcuts.ui&lt;/file&gt;
     &lt;file compressed="true" preprocess="xml-stripblanks"&gt;task_row.ui&lt;/file&gt;
     &lt;file compressed="true" preprocess="xml-stripblanks"&gt;window.ui&lt;/file&gt;
+    &lt;file compressed="true"&gt;style.css&lt;/file&gt;
   &lt;/gresource&gt;
 &lt;/gresources&gt;
</code></pre>
<p>此外，我们还在 <code>connect_startup</code> 中调用了 <code>load_css()</code>.</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/3/main.rs">listings/todo/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod task_object;
</span><span class="boring">mod task_row;
</span><span class="boring">mod utils;
</span><span class="boring">mod window;
</span><span class="boring">
</span><span class="boring">use gdk::Display;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gdk, gio, glib, Application, CssProvider};
</span><span class="boring">use window::Window;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Todo3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    gio::resources_register_include!("todo_3.gresource")
</span><span class="boring">        .expect("Failed to register resources.");
</span><span class="boring">
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span>    // Connect to signals
    app.connect_startup(|app| {
        setup_shortcuts(app);
        load_css()
    });
<span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn setup_shortcuts(app: &amp;Application) {
</span><span class="boring">    app.set_accels_for_action("win.filter('All')", &amp;["&lt;Ctrl&gt;a"]);
</span><span class="boring">    app.set_accels_for_action("win.filter('Open')", &amp;["&lt;Ctrl&gt;o"]);
</span><span class="boring">    app.set_accels_for_action("win.filter('Done')", &amp;["&lt;Ctrl&gt;d"]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn load_css() {
</span><span class="boring">    // Load the CSS file and add it to the provider
</span><span class="boring">    let provider = CssProvider::new();
</span><span class="boring">    provider.load_from_resource("/org/gtk_rs/Todo3/style.css");
</span><span class="boring">
</span><span class="boring">    // Add the provider to the default screen
</span><span class="boring">    gtk::style_context_add_provider_for_display(
</span><span class="boring">        &amp;Display::default().expect("Could not connect to a display."),
</span><span class="boring">        &amp;provider,
</span><span class="boring">        gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a new custom window and present it
</span><span class="boring">    let window = Window::new(app);
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p><code>load_css()</code> 与本章开头显示的非常相似。 不过，这次我们使用 <code>load_from_resource()</code> 来加载样式。</p>
<pre><code class="language-rust"><span class="boring">mod task_object;
</span><span class="boring">mod task_row;
</span><span class="boring">mod utils;
</span><span class="boring">mod window;
</span><span class="boring">
</span><span class="boring">use gdk::Display;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gdk, gio, glib, Application, CssProvider};
</span><span class="boring">use window::Window;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Todo3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    gio::resources_register_include!("todo_3.gresource")
</span><span class="boring">        .expect("Failed to register resources.");
</span><span class="boring">
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to signals
</span><span class="boring">    app.connect_startup(|app| {
</span><span class="boring">        setup_shortcuts(app);
</span><span class="boring">        load_css()
</span><span class="boring">    });
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn setup_shortcuts(app: &amp;Application) {
</span><span class="boring">    app.set_accels_for_action("win.filter('All')", &amp;["&lt;Ctrl&gt;a"]);
</span><span class="boring">    app.set_accels_for_action("win.filter('Open')", &amp;["&lt;Ctrl&gt;o"]);
</span><span class="boring">    app.set_accels_for_action("win.filter('Done')", &amp;["&lt;Ctrl&gt;d"]);
</span><span class="boring">}
</span><span class="boring">
</span>fn load_css() {
    // Load the CSS file and add it to the provider
    let provider = CssProvider::new();
    provider.load_from_resource("/org/gtk_rs/Todo3/style.css");

    // Add the provider to the default screen
    gtk::style_context_add_provider_for_display(
        &amp;Display::default().expect("Could not connect to a display."),
        &amp;provider,
        gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
    );
}
<span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a new custom window and present it
</span><span class="boring">    let window = Window::new(app);
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>这就是更改后的任务行的样子。 也许最好立即还原……</p>
<div style="text-align:center"><img src="img/todo_3.png" alt="To-Do app with green background for its task widget"/></div>
<h2 id="改造待办事项应用"><a class="header" href="#改造待办事项应用">改造待办事项应用</a></h2>
<p>幸运的是，在我们的待办事项应用程序中找到 CSS 的实际用途并不难。 到目前为止，不同的任务还没有很好地分隔开来。 我们可以通过在 <code>tasks_list</code> 中添加 <code>frame</code> 和分隔符(<code>separators</code>)样式类来改变这种状况。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/4/resources/task_row.ui">listings/todo/4/resources/window.ui</a></p>
<pre><code class="language-diff"> &lt;object class="GtkListView" id="tasks_list"&gt;
   &lt;property name="valign"&gt;start&lt;/property&gt;
+  &lt;style&gt;
+    &lt;class name="frame"/&gt;
+    &lt;class name="separators"/&gt;
+  &lt;/style&gt;
 &lt;/object&gt;
</code></pre>
<div style="text-align:center"><img src="img/todo_4.png" alt="To-Do app with borders for its task widget"/></div>
<h2 id="结论"><a class="header" href="#结论">结论</a></h2>
<p>定义 CSS 规则的方法有很多。 让我们简要回顾一下所学的语法。 下面的规则匹配节点 <code>arrow</code>，它是名称为 <code>button-1</code>、样式类为 <code>toggle</code> 和 <code>text-button</code> 的按钮节点的子对象。 当我们将鼠标悬停在箭头上时，该规则就会实际应用。</p>
<pre><code class="language-css">button#button-1.toggle.text-button arrow:hover {
  color: magenta;
}
</code></pre>
<p>当规则应用时，颜色参数将被设置为品红色。 您可以在 GTK <a href="https://docs.gtk.org/gtk4/css-properties.html#gtk-css-properties">文档</a>中找到支持参数的完整列表。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="todo_2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="libadwaita.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="todo_2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="libadwaita.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
