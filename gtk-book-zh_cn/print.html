<!DOCTYPE HTML>
<html lang="zh_cn" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>基于 Rust 和 GTK 4 的 GUI 开发</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/style.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">简介</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.</strong> 安装</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation_linux.html"><strong aria-hidden="true">1.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="installation_macos.html"><strong aria-hidden="true">1.2.</strong> macOS</a></li><li class="chapter-item expanded "><a href="installation_windows.html"><strong aria-hidden="true">1.3.</strong> Windows</a></li></ol></li><li class="chapter-item expanded "><a href="project_setup.html"><strong aria-hidden="true">2.</strong> 项目设置</a></li><li class="chapter-item expanded "><a href="hello_world.html"><strong aria-hidden="true">3.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="widgets.html"><strong aria-hidden="true">4.</strong> 控件</a></li><li class="chapter-item expanded "><a href="g_object_concepts.html"><strong aria-hidden="true">5.</strong> GObject 相关概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="g_object_memory_management.html"><strong aria-hidden="true">5.1.</strong> 内存管理</a></li><li class="chapter-item expanded "><a href="g_object_subclassing.html"><strong aria-hidden="true">5.2.</strong> 子类化</a></li><li class="chapter-item expanded "><a href="g_object_values.html"><strong aria-hidden="true">5.3.</strong> 泛型值</a></li><li class="chapter-item expanded "><a href="g_object_properties.html"><strong aria-hidden="true">5.4.</strong> 属性</a></li><li class="chapter-item expanded "><a href="g_object_signals.html"><strong aria-hidden="true">5.5.</strong> 信号</a></li></ol></li><li class="chapter-item expanded "><a href="main_event_loop.html"><strong aria-hidden="true">6.</strong> 主事件循环</a></li><li class="chapter-item expanded "><a href="settings.html"><strong aria-hidden="true">7.</strong> 设置(Settings)</a></li><li class="chapter-item expanded "><a href="saving_window_state.html"><strong aria-hidden="true">8.</strong> 保存窗口状态</a></li><li class="chapter-item expanded "><a href="list_widgets.html"><strong aria-hidden="true">9.</strong> 列表控件</a></li><li class="chapter-item expanded "><a href="composite_templates.html"><strong aria-hidden="true">10.</strong> Composite Templates</a></li><li class="chapter-item expanded "><a href="todo_1.html"><strong aria-hidden="true">11.</strong> Building a Simple To-Do App</a></li><li class="chapter-item expanded "><a href="actions.html"><strong aria-hidden="true">12.</strong> Actions</a></li><li class="chapter-item expanded "><a href="todo_2.html"><strong aria-hidden="true">13.</strong> Manipulating State of To-Do App</a></li><li class="chapter-item expanded "><a href="css.html"><strong aria-hidden="true">14.</strong> CSS</a></li><li class="chapter-item expanded "><a href="libadwaita.html"><strong aria-hidden="true">15.</strong> Libadwaita</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="todo_3.html"><strong aria-hidden="true">15.1.</strong> Let To-Do App use Libadwaita</a></li><li class="chapter-item expanded "><a href="todo_4.html"><strong aria-hidden="true">15.2.</strong> Adding Collections</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">基于 Rust 和 GTK 4 的 GUI 开发</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Mario-Hero/GTK-Rust-Book-zh_cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="基于-rust-和-gtk-4-的-gui-开发"><a class="header" href="#基于-rust-和-gtk-4-的-gui-开发">基于 Rust 和 GTK 4 的 GUI 开发</a></h1>
<p><em>作者：Julian Hofer，社区贡献； 翻译：陈竞阁</em></p>
<p><em>本翻译基于 <a href="https://github.com/gtk-rs/gtk4-rs/tree/master/book">gtk4-rs/book at master(github.com)</a> 2024年9月9日版本, 即 <code>gtk-rs 0.9.1</code></em></p>
<p>GTK 4 是用 C 语言编写的、流行的、跨平台部件工具箱的最新版本。 多亏了GObject-Introspection技术，GTK 的 API 可以轻松地被各种编程语言所使用。 API 甚至可以描述其参数的所有权！</p>
<p>在不牺牲速度的前提下管理所有权是 Rust 的最大优势之一，这使其成为开发GTK 应用程序的极佳选择。</p>
<p>有了这种组合，您就不必再担心在项目中期遇到瓶颈了。 此外，使用 Rust，您还可以获得如下好处：</p>
<ul>
<li>线程安全</li>
<li>内存安全</li>
<li>合理的依赖管理</li>
<li>优秀的第三方库</li>
</ul>
<p><a href="https://gtk-rs.org/"><code>gtk-rs</code></a> 项目提供了许多 GTK 相关库的绑定，我们将在本书中使用这些库。</p>
<h2 id="这本书是写给谁的"><a class="header" href="#这本书是写给谁的">这本书是写给谁的</a></h2>
<p>本书假定您了解 Rust 语言。</p>
<p>如果现在还不是这种情况，那么阅读 <a href="https://doc.rust-lang.org/stable/book/">The Rust Programming Language</a> 是让您了解 Rust的一种愉快方式。 如果你有使用其他低级语言（如 C 或 C++）的经验，则可能会发现阅读 <a href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust">A half hour to learn Rust</a> 也能为您提供足够的信息。</p>
<p>幸运的是，这一点再加上开发图形应用程序的愿望就是从本书中受益所必需的全部了。</p>
<h2 id="如何使用这本书"><a class="header" href="#如何使用这本书">如何使用这本书</a></h2>
<p>一般来说，这本书假定你是按顺序从头读到尾。但是，如果您将其用作某个主题的参考， 您可能会发现直接跳入会很有用。</p>
<p>本书分为两种章节：概念章节和项目章节。</p>
<p>在概念章节中，您将了解 GTK 开发的某个方面。</p>
<p>在项目章节中，我们将一起构建小程序，应用您目前为止所学的知识。</p>
<p>本书致力于通过实际示例来解释基本的 GTK 概念。 但是，如果一个概念可以用一个不太实际的例子更好地传达，我们大多数时候都会走这条路。 如果您对包含的有用示例感兴趣，我们建议您参阅 <code>gtk4-rs</code> 的 <a href="https://github.com/gtk-rs/gtk4-rs/tree/master/examples">仓库</a>。</p>
<p>书中的每个有效代码片段都是列表的一部分。 与示例一样，这些列表可以在 <code>gtk4-rs</code> 的<a href="https://github.com/gtk-rs/gtk4-rs/tree/master/book/listings">仓库</a>中找到。</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>The book itself is licensed under the <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International license</a>.
The only exception are the code snippets which are licensed under the <a href="https://github.com/gtk-rs/gtk4-rs/blob/master/README.md">MIT license</a>.
This translation of this book is licensed under the <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International license</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装"><a class="header" href="#安装">安装</a></h1>
<p>为了开发 <code>gtk-rs</code> 应用程序，您的工作站至少需要两样东西：</p>
<ul>
<li>Rust 工具链，以及</li>
<li>GTK 4 库。</li>
</ul>
<p>正如魔鬼经常隐藏在细节中一样，我们将在以下章节中列出每个操作系统的安装说明。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux"><a class="header" href="#linux">Linux</a></h1>
<p>首先您必须安装 rustup。 您可以在 <a href="https://rustup.rs/">rustup.rs</a> 上找到最新的安装教程。</p>
<p>然后安装 GTK 4 和 build essentials。 为此，请执行属于您正在使用的发行版的命令。</p>
<p>Fedora 及其衍生版本：</p>
<pre><code>sudo dnf install gtk4-devel gcc
</code></pre>
<p>Debian 及其衍生版本：</p>
<pre><code>sudo apt install libgtk-4-dev build-essential
</code></pre>
<p>Arch 及其衍生版本：</p>
<pre><code>sudo pacman -S gtk4 base-devel
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macos"><a class="header" href="#macos">macOS</a></h1>
<p>首先安装 rustup。 您可以在 <a href="https://rustup.rs/">rustup.rs</a> 上找到最新的安装教程。</p>
<p>然后安装 <a href="https://brew.sh/zh-cn/">homebrew</a>。</p>
<p>最后，通过在终端中执行以下命令来安装 GTK 4：</p>
<pre><code class="language-bash">brew install gtk4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows"><a class="header" href="#windows">Windows</a></h1>
<p>在 Windows 计算机上做准备时，您必须在使用 <strong>MSVC 工具链</strong>或 <strong>GNU 工具链</strong>之间做出决定。 如有疑问，请选择 MSVC，因为这是 Windows 上的默认设置。 如果您依赖只能使用 GNU 工具链编译的库，您将需要使用 GNU 工具链。</p>
<h2 id="安装-rustup"><a class="header" href="#安装-rustup">安装 Rustup</a></h2>
<p>通过 <a href="https://rustup.rs/">rustup</a> 安装 Rust 工具链。</p>
<h2 id="安装-gtk-4"><a class="header" href="#安装-gtk-4">安装 GTK 4</a></h2>
<details>
<summary>使用gvsbuild 和 MSVC构建GTK 4 (推荐)</summary>
<h3 id="将-rust-工具链设为-msvc"><a class="header" href="#将-rust-工具链设为-msvc">将 Rust 工具链设为 MSVC</a></h3>
<p>通过执行以下命令告诉 Rust 使用 MSVC：</p>
<pre><code>rustup default stable-msvc
</code></pre>
<p>请注意，这不会安装 MSVC 工具链。如果您还没有，则需要<a href="https://learn.microsoft.com/zh-cn/windows/dev-environment/rust/setup">单独安装它</a>。</p>
<h3 id="构建-gtk-4"><a class="header" href="#构建-gtk-4">构建 GTK 4</a></h3>
<p>按照 <a href="https://github.com/wingtk/gvsbuild#development-environment"><code>gvsbuild</code> 文档构建 GTK 4</a>。请务必构建正确的版本：</p>
<pre><code>gvsbuild build gtk4
</code></pre>
<h3 id="更新环境变量"><a class="header" href="#更新环境变量">更新环境变量</a></h3>
<ol>
<li>打开开始菜单</li>
<li>搜索“高级系统设置”</li>
<li>单击 '环境变量...'</li>
<li>确保存在名为<code>PKG_CONFIG_PATH``C:\gtk-build\gtk\x64\release\lib\pkgconfig</code> 的用户环境变量</li>
<li>编辑名为<code>Path</code>的变量并添加 <code>C:\gtk-build\gtk\x64\release\bin</code> 到其中</li>
<li>确保有一个名为 <code>Lib</code> 的用户环境变量并包含<code>C:\gtk-build\gtk\x64\release\lib</code> （如果已存在，则向现有变量添加新值）</li>
</ol>
<p>您现在可以继续进行<a href="https://mario-hero.github.io/gtk-book-zh_cn/project_setup.html">项目设置</a>。</p>
</details>
<details>
<summary>使用 MSVC 手动构建 GTK 4</summary>
<p>如果使用 <code>gvsbuild</code> 无法正常构建 （或者您想要自定义构建），则可以手动构建 GTK 4 和您需要的最小依赖项。</p>
<h3 id="将-rust-工具链设置为-msvc"><a class="header" href="#将-rust-工具链设置为-msvc">将 Rust 工具链设置为 MSVC</a></h3>
<p>通过执行以下命令，将 Rust 工具链设置为 MSVC：</p>
<pre><code>rustup default stable-msvc
</code></pre>
<h3 id="visual-studio"><a class="header" href="#visual-studio">Visual Studio</a></h3>
<p>从 <a href="https://visualstudio.microsoft.com/zh-hans/vs/community/">visualstudio.microsoft.com</a> 安装 Visual Studio Community。 确保在安装过程中选中“使用 C++ 的桌面开发”选项。</p>
<div style="text-align:center"><img src="img/vs-install.png" /></div>
<h3 id="git"><a class="header" href="#git">Git</a></h3>
<p>从 <a href="https://gitforwindows.org/">gitforwindows.org</a> 下载 git.</p>
<h3 id="cmake"><a class="header" href="#cmake">CMake</a></h3>
<p>从 <a href="https://cmake.org/download/">https://cmake.org/download/</a> 下载 CMake.</p>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<p>从 <a href="https://www.python.org/downloads">python.org</a> 下载 Python.
确保在安装过程中选择将 Python 添加到您的 Path.</p>
<h3 id="meson"><a class="header" href="#meson">Meson</a></h3>
<p>通过执行以下命令安装 meson：</p>
<pre><code class="language-powershell">pip install meson ninja
</code></pre>
<h3 id="gettext-021"><a class="header" href="#gettext-021">Gettext 0.21</a></h3>
<p>从 <a href="https://mlocati.github.io/articles/gettext-iconv-windows.html">mlocati.github.io</a> 下载 Gettext 0.21.
确保选择静态链接版本。</p>
<h3 id="pkg-config"><a class="header" href="#pkg-config">Pkg-config</a></h3>
<p>从 <a href="https://sourceforge.net/projects/pkgconfiglite/">sourceforge.net</a> 下载 pkg-config-lite。
然后解压到 <code>C:/</code>, 使可执行文件位于 <code>C:\pkg-config-lite-0.28-1\bin</code>.</p>
<h3 id="更新环境变量-1"><a class="header" href="#更新环境变量-1">更新环境变量</a></h3>
<ol>
<li>转到设置 -&gt; 搜索并打开 <code>高级系统设置</code> -&gt; 点击 <code>环境变量</code> 按钮</li>
<li>选择<code>Path</code> -&gt; 点击<code>编辑</code> -&gt; 添加以下条目：</li>
</ol>
<pre><code>C:\pkg-config-lite-0.28-1\bin
C:\gnome\bin
</code></pre>
<ol start="3">
<li>返回到 <code>环境变量</code></li>
<li>在 <code>用户变量</code>下点击<code>新建</code> 并添加:</li>
</ol>
<ul>
<li>环境变量名称: <code>PKG_CONFIG_PATH</code></li>
<li>环境变量值: <code>C:\gnome\lib\pkgconfig</code></li>
</ul>
<h3 id="编译安装-gtk-4"><a class="header" href="#编译安装-gtk-4">编译安装 GTK 4</a></h3>
<p>从 Windows 开始菜单中，搜索 <code>x64 Native Tools Command Prompt for VS</code>。 这将打开一个配置为使用 MSVC x64 工具的终端。 从那里，运行以下命令：</p>
<pre><code class="language-cmd">cd /
git clone https://gitlab.gnome.org/GNOME/gtk.git --depth 1
git clone https://gitlab.gnome.org/GNOME/libxml2.git --depth 1
git clone https://gitlab.gnome.org/GNOME/librsvg.git --depth 1

:: 确保cmd在搜索pkg-config时能找到pkg-config-lite
where pkg-config

:: 确保setuptools可用。
pip install setuptools

cd gtk
meson setup builddir --prefix=C:/gnome -Dbuild-tests=false -Dmedia-gstreamer=disabled
meson install -C builddir
cd /

cd libxml2
cmake -S . -B build -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=C:\gnome -D LIBXML2_WITH_ICONV=OFF -D LIBXML2_WITH_LZMA=OFF -D LIBXML2_WITH_PYTHON=OFF -D LIBXML2_WITH_ZLIB=OFF
cmake --build build --config Release
cmake --install build
cd /

cd librsvg/win32
nmake /f generate-msvc.mak generate-nmake-files
nmake /f Makefile.vc CFG=release install PREFIX=C:\gnome
cd /
</code></pre>
<p>您现在可以继续进行<a href="https://mario-hero.github.io/gtk-book-zh_cn/project_setup.html">项目设置</a>。</p>
</details>
<details>
<summary>使用 MSYS2 和 GNU 工具链安装 GTK 4</summary>
<h3 id="安装-rustup-1"><a class="header" href="#安装-rustup-1">安装 Rustup</a></h3>
<p>通过 <a href="https://rustup.rs/">rustup</a> 安装 rust 工具链。</p>
<h3 id="从-msvc-工具链中去除残留物"><a class="header" href="#从-msvc-工具链中去除残留物">从 MSVC 工具链中去除残留物</a></h3>
<p>如果您以前使用过 MSVC 工具链，请确保在安装过程中还原您对环境变量所做的所有更改。</p>
<h3 id="msys2"><a class="header" href="#msys2">MSYS2</a></h3>
<p>从 <a href="https://www.msys2.org/">www.msys2.org</a> 安装 MSYS2</p>
<h3 id="安装-gtk-4-1"><a class="header" href="#安装-gtk-4-1">安装 GTK 4</a></h3>
<p>从 Windows 开始菜单，搜索 <code>MSYS2 MinGW 64-bit</code>.
这将打开一个配置为使用 MinGW x64 工具的终端。</p>
<p>在终端中，执行以下命令以安装<code>GTK 4</code>、<code>pkgconf</code> 和 <code>gcc</code>：</p>
<pre><code class="language-sh">pacman -S mingw-w64-x86_64-gtk4 mingw-w64-x86_64-gettext mingw-w64-x86_64-libxml2 mingw-w64-x86_64-librsvg mingw-w64-x86_64-pkgconf mingw-w64-x86_64-gcc
</code></pre>
<h3 id="更新-path-环境变量"><a class="header" href="#更新-path-环境变量">更新 <code>Path</code> 环境变量</a></h3>
<ol>
<li>转到设置 -&gt; 搜索并打开 <code>高级系统设置</code> -&gt; 点击 <code>环境变量</code> 按钮</li>
<li>选择 <code>Path</code> -&gt; 点击 <code>编辑</code> -&gt; 添加以下三个条目：</li>
</ol>
<pre><code>C:\msys64\mingw64\include
C:\msys64\mingw64\bin
C:\msys64\mingw64\lib
</code></pre>
<h3 id="为-rust-设置-gnu-工具链"><a class="header" href="#为-rust-设置-gnu-工具链">为 Rust 设置 GNU 工具链</a></h3>
<p>Windows 上的默认工具链是 <code>stable-msvc</code>.
要切换到 <code>stable-gnu</code>，请从终端运行以下命令：</p>
<ol>
<li><code>rustup toolchain install stable-gnu</code></li>
<li><code>rustup default stable-gnu</code></li>
</ol>
<p>请注意，此命令将来可能会更改。 如果它失效了，请在我们的 repo 上打开一个 <a href="https://github.com/gtk-rs/gtk4-rs/issues/new/choose">issue</a>。</p>
<p>您现在可以继续进行<a href="https://mario-hero.github.io/gtk-book-zh_cn/project_setup.html">项目设置</a>。</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="项目设置"><a class="header" href="#项目设置">项目设置</a></h1>
<p>让我们从安装所有必要的工具开始。</p>
<p>首先，按照 <a href="https://www.gtk.org/docs/installations/">GTK 网站</a>上的说明安装 GTK 4。 然后使用 <a href="https://rustup.rs/">rustup</a> 安装 Rust。</p>
<p>现在，通过执行以下命令，创建一个新项目并移动到新创建的文件夹中：</p>
<pre><code>cargo new my-gtk-app
cd my-gtk-app
</code></pre>
<p>通过运行以下命令来获取电脑上的 GTK 4 版本</p>
<pre><code>pkg-config --modversion gtk4
</code></pre>
<p>运行以下命令将 <a href="https://crates.io/crates/gtk4">gtk4 crate</a> 添加到 <code>Cargo.toml</code> 依赖项。在撰写本文时，最新GTK 4 版本是 <code>4.12</code></p>
<pre><code>cargo add gtk4 --rename gtk --features v4_12
</code></pre>
<p>通过指定此功能，您可以选择使用 GTK 4 次版本中添加的 API。</p>
<p>现在，您可以通过执行以下命令来运行您的应用程序：</p>
<pre><code>cargo run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h1>
<p>现在我们已经安装好了，让我们开始吧！</p>
<p>至少，我们需要创建一个带有<a href="https://developer.gnome.org/documentation/tutorials/application-id.html">应用程序 ID</a> 的 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Application.html"><code>gtk::Application</code></a> 实例。 为此，我们使用了许多 <code>gtk-rs</code> 对象都支持的 <a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html">builder 模式</a>。 请注意，我们还导入了 prelude 以将必要的 trait 引入。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/hello_world/1/main.rs">listings/hello_world/1/main.rs</a></p>
<pre><code class="language-rust">use gtk::prelude::*;
use gtk::{glib, Application};

const APP_ID: &amp;str = "org.gtk_rs.HelloWorld1";

fn main() -&gt; glib::ExitCode {
    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Run the application
    app.run()
}</code></pre>
<p>它构建正常，但终端中显示一条警告。</p>
<pre><code>GLib-GIO-WARNING: Your application does not implement g_application_activate()
and has no handlers connected to the 'activate' signal. It should do one of these.
</code></pre>
<p>GTK 告诉我们，应该在其 <code>activate</code>步骤中调用某些内容。</p>
<p>所以让我们在那里创建一个 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ApplicationWindow.html"><code>gtk::ApplicationWindow</code></a>。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/hello_world/2/main.rs">listings/hello_world/2/main.rs</a></p>
<pre><code class="language-rust">use gtk::prelude::*;
use gtk::{glib, Application, ApplicationWindow};

const APP_ID: &amp;str = "org.gtk_rs.HelloWorld2";

fn main() -&gt; glib::ExitCode {
    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to "activate" signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

fn build_ui(app: &amp;Application) {
    // Create a window and set the title
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .build();

    // Present window
    window.present();
}</code></pre>
<p>这样好多了！</p>
<div style="text-align:center"><img src="img/hello_world_empty.png" alt="An empty window with a header bar with label 'My GTK App'"/></div>
<p>通常，我们希望用户能够与界面进行交互。</p>
<p>此外，章节的名称表示软件将包含 “Hello World！”。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/hello_world/3/main.rs">listings/hello_world/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow, Button};
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.HelloWorld3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Create a button with label and margins
    let button = Button::builder()
        .label("Press me!")
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // Connect to "clicked" signal of `button`
    button.connect_clicked(|button| {
        // Set the label to "Hello World!" after the button has been clicked on
        button.set_label("Hello World!");
    });

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .child(&amp;button)
        .build();

    // Present window
    window.present();
}</code></pre>
<blockquote>
<p>如果您仔细查看这段代码，您会注意到它的右上角有一个小眼睛符号。 按下它后，您可以看到完整代码。 我们将在整本书中使用它来隐藏那些对传达信息并不重要的细节。 如果您想按照本书一步步编写程序，请注意这一点。 在这里，我们隐藏了我们引入<code>gtk::Button</code>的内容。</p>
</blockquote>
<p>现在有一个按钮，如果我们单击它，它的标签将变为 “Hello World！”。</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/hello_world_button.webm" type="video/webm">
  <p>A video which shows that pressing on the button changes it's label</p>
 </video>
</div>
<p>创建我们的第一个 <code>gtk-rs</code> 应用程序不是很难，对吧？ 现在让我们更好地了解我们到底在这里做了什么。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="控件"><a class="header" href="#控件">控件</a></h1>
<p>控件(Widget)是组成 GTK 应用程序的组件。 GTK 提供了许多控件，如果这些控件不合适，您甚至可以自定义。 例如，控件包含了显示控件、按钮、容器和窗口。 一种控件可能能够包含其他控件，它可能会用于展示信息，并且可能会对交互做出反应。</p>
<p><a href="https://docs.gtk.org/gtk4/visual_index.html">Widget Gallery</a> 有助于找出适合你的需求的控件。 假设我们想向应用程序添加一个按钮。 我们这里有很多选择，但让我们以最简单的一个——<code>Button</code>。</p>
<div style="text-align:center"><img src="img/widgets_button.png" /></div>
<p>GTK 是一个面向对象的框架，因此所有控件都是继承树的一部分，顶部是 <code>GObject</code>. 继承树如下所示：</p>
<pre><code class="language-console">GObject
╰── Widget
    ╰── Button
</code></pre>
<p><a href="https://docs.gtk.org/gtk4/class.Button.html#implements">GTK 文档</a>还告诉我们，<code>Button</code>实现了 <code>GtkAccessible</code>, <code>GtkActionable</code>, <code>GtkBuildable</code>, <code>GtkConstraintTarget</code> 接口。</p>
<p>现在让我们将其与 <code>gtk-rs</code> 中的 <code>Button</code> 结构进行比较。 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Button.html#implements">gtk-rs 文档</a>告诉我们它实现了哪些 trait。 我们发现这些 trait 在 GTK 文档中要么有相应的基类，要么有接口。 在 “Hello World” 程序中，我们希望对按钮单击做出反应。 这种行为是按钮特有的，因此我们希望在 <code>ButtonExt</code> trait 中找到合适的方法。 而事实上，<code>ButtonExt</code> 包含了 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.ButtonExt.html#tymethod.connect_clicked"><code>connect_clicked</code></a> 方法。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/hello_world/3/main.rs">listings/hello_world/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow, Button};
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.HelloWorld3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create a button with label and margins
    let button = Button::builder()
        .label("Press me!")
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // Connect to "clicked" signal of `button`
    button.connect_clicked(|button| {
        // Set the label to "Hello World!" after the button has been clicked on
        button.set_label("Hello World!");
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gobject-相关概念"><a class="header" href="#gobject-相关概念">GObject 相关概念</a></h1>
<p>GTK 是一个面向对象的框架。 它是用 C 语言编写的，而C 语言不支持开箱即用的面向对象。 这就是为什么 GTK 依赖 GObject 库来提供对象系统的原因。</p>
<p>我们已经了解了 <code>gtk-rs</code> 会将 GObject 概念（如继承和接口）映射到 Rust 的 trait 上。 在本章中，我们将学习：</p>
<ul>
<li>如何管理 GObject 的内存</li>
<li>如何通过子类化创建我们自己的 GObject</li>
<li>如何处理泛型值</li>
<li>如何使用属性</li>
<li>如何发送和接收信号</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存管理"><a class="header" href="#内存管理">内存管理</a></h1>
<p>在编写 gtk-rs 程序时，内存管理可能有点棘手。 让我们来看看为什么会出现这种情况以及如何处理。</p>
<p>在第一个示例中，我们的窗口只有一个按钮。 每点击一次按钮，一个整数变量  <code>number</code> 就会自增一次。</p>
<pre><code class="language-rust  no_run compile_fail"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectMemoryManagement0";
</span><span class="boring">
</span>// DOES NOT COMPILE!
fn main() -&gt; glib::ExitCode {
    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to "activate" signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

fn build_ui(application: &amp;Application) {
    // Create two buttons
    let button_increase = Button::builder()
        .label("Increase")
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // A mutable integer
    let mut number = 0;

    // Connect callbacks
    // When a button is clicked, `number` should be changed
    button_increase.connect_clicked(|_| number += 1);

    // Create a window
    let window = ApplicationWindow::builder()
        .application(application)
        .title("My GTK App")
        .child(&amp;button_increase)
        .build();

    // Present the window
    window.present();
}</code></pre>
<p>Rust 编译器拒绝编译这个程序，同时还吐出了多条错误信息。 让我们逐一查看。</p>
<pre><code class="language-console">
error[E0373]: closure may outlive the current function, but it borrows `number`, which is owned by the current function
   |
32 |     button_increase.connect_clicked(|_| number += 1);
   |                                     ^^^ ------ `number` is borrowed here
   |                                     |
   |                                     may outlive borrowed value `number`
   |
note: function requires argument type to outlive `'static`
   |
32 |     button_increase.connect_clicked(|_| number += 1);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `number` (and any other referenced variables), use the `move` keyword
   |
32 |     button_increase.connect_clicked(move |_| number += 1);
   |  
</code></pre>
<p>我们的闭包只借用了 <code>number</code>. GTK 中的信号处理器要求其引用具有静态( <code>`static</code>)生命周期，因此我们不能借用一个只在 <code>build_ui</code> 函数作用域中存在的变量。 编译器也给出了解决方法。 在闭包前面添加 <code>move</code> 关键字，<code>number </code>就会被移入闭包。</p>
<pre><code class="language-rust  no_run compile_fail"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectMemoryManagement0";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">   // Create a new application
</span><span class="boring">   let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">   // Connect to "activate" signal of `app`
</span><span class="boring">   app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">   // Run the application
</span><span class="boring">   app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(application: &amp;Application) {
</span><span class="boring">   // Create two buttons
</span><span class="boring">   let button_increase = Button::builder()
</span><span class="boring">       .label("Increase")
</span><span class="boring">       .margin_top(12)
</span><span class="boring">       .margin_bottom(12)
</span><span class="boring">       .margin_start(12)
</span><span class="boring">       .margin_end(12)
</span><span class="boring">       .build();
</span><span class="boring">
</span>    // DOES NOT COMPILE!
    // A mutable integer
    let mut number = 0;

    // Connect callbacks
    // When a button is clicked, `number` should be changed
    button_increase.connect_clicked(move |_| number += 1);
<span class="boring">
</span><span class="boring">   // Create a window
</span><span class="boring">   let window = ApplicationWindow::builder()
</span><span class="boring">       .application(application)
</span><span class="boring">       .title("My GTK App")
</span><span class="boring">       .child(&amp;button_increase)
</span><span class="boring">       .build();
</span><span class="boring">
</span><span class="boring">   // Present the window
</span><span class="boring">   window.present();
</span><span class="boring">}</span></code></pre>
<p>但这样仍然会出现以下错误信息：</p>
<pre><code class="language-console">
error[E0594]: cannot assign to `number`, as it is a captured variable in a `Fn` closure
   |
32 |     button_increase.connect_clicked(move |_| number += 1);
   |                                              ^^^^^^^^^^^ cannot assign
</code></pre>
<p>为了理解该错误信息，我们必须了解 <code>FnOnce</code>、<code>FnMut</code> 和 <code>Fn</code> 这三种闭包(closure) trait 之间的区别。 使用实现 <code>FnOnce</code> 特性的闭包的 API 给 API 消费者提供了最大的自由度。 闭包只被调用一次，因此它甚至可以使用自己的状态。 信号处理器可以被多次调用，所以它们不能接受 <code>FnOnce</code>。</p>
<p>限制性更强的 <code>FnMut</code> trait 不允许闭包消耗其状态，但它们仍可以对其进行修改。 信号处理器也不允许这样做，因为它们可以从自身内部调用。 这将导致多个可变引用，而借用检查器根本不喜欢这种情况。</p>
<p>这样就只剩下 <code>Fn</code>. 状态可以不可变地借用，但我们如何修改 <code>number</code> 呢？ 我们需要一种具有内部可变性的数据类型，比如 <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>std::cell::Cell</code></a>.</p>
<blockquote>
<p><code>Cell</code> 只适用于实现了 <a href="https://doc.rust-lang.org/core/marker/trait.Copy.html"><code>Copy</code></a> trait 的对象。对于其他对象，则应使用<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a>.
有关内部可变性的更多信息，请参见《Rust Atomics and Locks》一书中的<a href="https://marabos.nl/atomics/basics.html#interior-mutability">这一部分</a>。</p>
</blockquote>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_memory_management/2/main.rs">listings/g_object_memory_management/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow, Button};
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectMemoryManagement1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(application: &amp;Application) {
    // Create two buttons
    let button_increase = Button::builder()
        .label("Increase")
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // A mutable integer
    let number = Cell::new(0);

    // Connect callbacks
    // When a button is clicked, `number` should be changed
    button_increase.connect_clicked(move |_| number.set(number.get() + 1));

    // Create a window
    let window = ApplicationWindow::builder()
        .application(application)
        .title("My GTK App")
        .child(&amp;button_increase)
        .build();

    // Present the window
    window.present();
}</code></pre>
<p>现在编译结果符合预期。</p>
<p>让我们举一个稍微复杂一点的例子：两个按钮都修改了同一个数字<code>number</code>。 为此，我们需要一种方法，让两个闭包都拥有同一个值的所有权？</p>
<p>这正是 <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>std::rc::Rc</code></a> 类型的作用。</p>
<p><code>Rc</code> 会计算通过 <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html#tymethod.clone"><code>Clone::clone</code></a> 创建和通过 <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>Drop::drop</code></a> 释放的强引用的数量，只有当这个数量降为零时，才会释放这个值。</p>
<p>如果我们想修改 <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a>的内容，可以再次使用 <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell</code></a> 类型。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_memory_management/2/main.rs">listings/g_object_memory_management/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, glib, Application, ApplicationWindow, Button, Orientation};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectMemoryManagement2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label("Increase")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label("Decrease")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Reference-counted object with inner-mutability
    let number = Rc::new(Cell::new(0));

    // Connect callbacks, when a button is clicked `number` will be changed
    let number_copy = number.clone();
    button_increase.connect_clicked(move |_| number_copy.set(number_copy.get() + 1));
    button_decrease.connect_clicked(move |_| number.set(number.get() - 1));
<span class="boring">
</span><span class="boring">    // Add buttons to `gtk_box`
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>不过，用临时变量（如 number_copy）来填充作用域并不是一件好事。</p>
<p>我们可以使用 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/macro.clone.html"><code>glib::clone!</code></a> 宏来改善这种情况。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_memory_management/3/main.rs">listings/g_object_memory_management/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, glib, Application, ApplicationWindow, Button, Orientation};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectMemoryManagement3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label("Increase")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label("Decrease")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">    // Connect callbacks
</span><span class="boring">    // When a button is clicked, `number` will be changed
</span>    button_increase.connect_clicked(clone!(
        #[strong]
        number,
        move |_| {
            number.set(number.get() + 1);
        }
    ));
    button_decrease.connect_clicked(move |_| {
        number.set(number.get() - 1);
    });
<span class="boring">
</span><span class="boring">    // Add buttons to `gtk_box`
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>就像 <code>Rc&lt;Cell&lt;T&gt;&gt;</code>一样，GObject 也是引用计数和可变的。 因此，我们可以像传递<code>number</code>一样将按钮传递给闭包。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_memory_management/4/main.rs">listings/g_object_memory_management/4/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, glib, Application, ApplicationWindow, Button, Orientation};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectMemoryManagement4";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label("Increase")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label("Decrease")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">
</span>    // Connect callbacks
    // When a button is clicked, `number` and label of the other button will be changed
    button_increase.connect_clicked(clone!(
        #[weak]
        number,
        #[strong]
        button_decrease,
        move |_| {
            number.set(number.get() + 1);
            button_decrease.set_label(&amp;number.get().to_string());
        }
    ));
    button_decrease.connect_clicked(clone!(
        #[strong]
        button_increase,
        move |_| {
            number.set(number.get() - 1);
            button_increase.set_label(&amp;number.get().to_string());
        }
    ));
<span class="boring">
</span><span class="boring">    // Add buttons to `gtk_box`
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>如果我们现在点击其中一个按钮，另一个按钮的标签就会改变。</p>
<p>但是，哎呀！ 我们是不是忘了引用计数系统的一个恼人之处？是的：<a href="https://doc.rust-lang.org/book/ch15-06-reference-cycles.html">循环引用</a>.。<code>button_increase</code> 持有 <code>button_decrease</code> 的强引用，反之亦然。 强引用可以防止引用的值被释放。 如果这个链条导致一个循环，那么这个循环中的所有值都不会被释放。 使用弱引用可以打破这种循环，因为弱引用不会使其值存活，而是提供了一种方法，可以在该值仍然存活时检索强引用。 由于我们希望应用程序释放不需要的内存，因此我们应该在按钮上使用弱引用。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_memory_management/5/main.rs">listings/g_object_memory_management/5/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, glib, Application, ApplicationWindow, Button, Orientation};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectMemoryManagement5";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label("Increase")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label("Decrease")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">
</span>    // Connect callbacks
    // When a button is clicked, `number` and label of the other button will be changed
    button_increase.connect_clicked(clone!(
        #[weak]
        number,
        #[weak]
        button_decrease,
        move |_| {
            number.set(number.get() + 1);
            button_decrease.set_label(&amp;number.get().to_string());
        }
    ));
    button_decrease.connect_clicked(clone!(
        #[weak]
        button_increase,
        move |_| {
            number.set(number.get() - 1);
            button_increase.set_label(&amp;number.get().to_string());
        }
    ));
<span class="boring">
</span><span class="boring">    // Add buttons to `gtk_box`
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>现在循环引用被破坏了。</p>
<p>每次点击按钮时，<code>glib::clone</code> 都会尝试升级弱引用。 例如，如果我们现在点击了一个按钮，而另一个按钮已不存在，回调将被跳过。</p>
<p>默认情况下，它会立即从闭包返回，返回值为 <code>()</code> 。 如果闭包期望不同的返回值，可以指定 <code>@default-return</code>。</p>
<p>请注意，我们在第二个闭包中移动了 <code>number</code>。 如果我们在两个闭包中都移动了弱引用，那么没有任何东西能让 <code>number</code> 继续存活，闭包也不会被调用。 考虑到这一点，<code>button_increase</code> 和 <code>button_decrease</code> 也会在 <code>build_ui</code> 的作用域结束时被丢弃。 那么谁来保持按钮的存活呢？</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_memory_management/5/main.rs">listings/g_object_memory_management/5/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, glib, Application, ApplicationWindow, Button, Orientation};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectMemoryManagement5";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label("Increase")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label("Decrease")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">
</span><span class="boring">    // Connect callbacks
</span><span class="boring">    // When a button is clicked, `number` and label of the other button will be changed
</span><span class="boring">    button_increase.connect_clicked(clone!(
</span><span class="boring">        #[weak]
</span><span class="boring">        number,
</span><span class="boring">        #[weak]
</span><span class="boring">        button_decrease,
</span><span class="boring">        move |_| {
</span><span class="boring">            number.set(number.get() + 1);
</span><span class="boring">            button_decrease.set_label(&amp;number.get().to_string());
</span><span class="boring">        }
</span><span class="boring">    ));
</span><span class="boring">    button_decrease.connect_clicked(clone!(
</span><span class="boring">        #[weak]
</span><span class="boring">        button_increase,
</span><span class="boring">        move |_| {
</span><span class="boring">            number.set(number.get() - 1);
</span><span class="boring">            button_increase.set_label(&amp;number.get().to_string());
</span><span class="boring">        }
</span><span class="boring">    ));
</span><span class="boring">
</span>    // Add buttons to `gtk_box`
    let gtk_box = gtk::Box::builder()
        .orientation(Orientation::Vertical)
        .build();
    gtk_box.append(&amp;button_increase);
    gtk_box.append(&amp;button_decrease);
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>当我们将按钮附加到 <code>gtk_box</code> 时，<code>gtk_box</code> 会保留对按钮的强引用。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_memory_management/5/main.rs">listings/g_object_memory_management/5/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, glib, Application, ApplicationWindow, Button, Orientation};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectMemoryManagement5";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create two buttons
</span><span class="boring">    let button_increase = Button::builder()
</span><span class="boring">        .label("Increase")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">    let button_decrease = Button::builder()
</span><span class="boring">        .label("Decrease")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Reference-counted object with inner mutability
</span><span class="boring">    let number = Rc::new(Cell::new(0));
</span><span class="boring">
</span><span class="boring">    // Connect callbacks
</span><span class="boring">    // When a button is clicked, `number` and label of the other button will be changed
</span><span class="boring">    button_increase.connect_clicked(clone!(
</span><span class="boring">        #[weak]
</span><span class="boring">        number,
</span><span class="boring">        #[weak]
</span><span class="boring">        button_decrease,
</span><span class="boring">        move |_| {
</span><span class="boring">            number.set(number.get() + 1);
</span><span class="boring">            button_decrease.set_label(&amp;number.get().to_string());
</span><span class="boring">        }
</span><span class="boring">    ));
</span><span class="boring">    button_decrease.connect_clicked(clone!(
</span><span class="boring">        #[weak]
</span><span class="boring">        button_increase,
</span><span class="boring">        move |_| {
</span><span class="boring">            number.set(number.get() - 1);
</span><span class="boring">            button_increase.set_label(&amp;number.get().to_string());
</span><span class="boring">        }
</span><span class="boring">    ));
</span><span class="boring">
</span><span class="boring">    // Add buttons to `gtk_box`
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_increase);
</span><span class="boring">    gtk_box.append(&amp;button_decrease);
</span><span class="boring">
</span>    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .child(&amp;gtk_box)
        .build();
<span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>当我们将 <code>gtk_box</code> 设置为 <code>window</code> 的子窗口时，<code>window</code> 会保持对它的强引用。</p>
<p>直到我们关闭窗口，它都会保持 <code>gtk_box</code> 以及按钮的存活。</p>
<p>由于我们的应用程序只有一个窗口，关闭窗口也就意味着退出应用程序。</p>
<p>只要尽可能使用弱引用，您就会发现完全可以避免应用程序中的循环引用。 在没有循环引用的情况下，您可以依靠 GTK 来正确管理您传递给它的 GObject 的内存。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="子类化"><a class="header" href="#子类化">子类化</a></h1>
<p>GObject 在很大程度上依赖于继承。因此，如果我们想创建一个自定义的 GObject，通过子类化来实现是很合理的。 让我们用一个自定义按钮来替换 "Hello World!" 应用程序中的按钮，看看它是如何工作的。 首先，我们需要创建一个实现结构体来保存状态并重写虚方法。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_subclassing/1/custom_button/imp.rs">listings/g_object_subclassing/1/custom_button/imp.rs</a></p>
<pre><code class="language-rust">use gtk::glib;
use gtk::subclass::prelude::*;

// Object holding the state
#[derive(Default)]
pub struct CustomButton;

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for CustomButton {
    const NAME: &amp;'static str = "MyGtkAppCustomButton";
    type Type = super::CustomButton;
    type ParentType = gtk::Button;
}

// Trait shared by all GObjects
impl ObjectImpl for CustomButton {}

// Trait shared by all widgets
impl WidgetImpl for CustomButton {}

// Trait shared by all buttons
impl ButtonImpl for CustomButton {}</code></pre>
<p>有关子类化的说明请参见 <code>ObjectSubclass</code>.</p>
<ul>
<li><code>NAME</code> 应由 crate-name 和 object-name 组成，以避免名称冲突。这里应使用<a href="https://en.wikipedia.org/wiki/Camel_case">大驼峰命名法</a>。</li>
<li><code>Type</code> 指的是之后将创建的实际 GObject。</li>
<li><code>ParentType</code> 是我们继承的 GObject。</li>
</ul>
<p>之后，我们就可以选择重写我们祖先的虚方法。 由于我们现在只想拥有一个普通按钮，所以我们什么也不重写。 不过，我们仍然需要添加空的 <code>impl</code>。 接下来，我们将描述我们自定义的 GObject 的公共接口。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_subclassing/1/custom_button/mod.rs">listings/g_object_subclassing/1/custom_button/mod.rs</a></p>
<pre><code class="language-rust">mod imp;

use glib::Object;
use gtk::glib;

glib::wrapper! {
    pub struct CustomButton(ObjectSubclass&lt;imp::CustomButton&gt;)
        @extends gtk::Button, gtk::Widget,
        @implements gtk::Accessible, gtk::Actionable, gtk::Buildable, gtk::ConstraintTarget;
}

impl CustomButton {
    pub fn new() -&gt; Self {
        Object::builder().build()
    }

    pub fn with_label(label: &amp;str) -&gt; Self {
        Object::builder().property("label", label).build()
    }
}
<span class="boring">
</span><span class="boring">impl Default for CustomButton {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self::new()
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/macro.wrapper.html"><code>glib::wrapper!</code></a>实现了与 <code>ParentType</code> 相同的 trait。 理论上，这意味着 <code>ParentType</code> 也是我们唯一需要指定的。 不幸的是，还没有人找到好的方法来做到这一点。 这就是为什么到目前为止，在 Rust 中对 GObjects 进行子类化需要提及 <code>GObject</code> 和 <code>GInitiallyUnowned</code> 以外的所有祖先和接口。 对于 <code>gtk::Button</code>，我们可以在 GTK4 的相应 <a href="https://docs.gtk.org/gtk4/class.Button.html#hierarchy">文档页</a> 中查找其祖先和接口。</p>
<p>完成这些步骤后，我们就可以用自定义按钮( <code>CustomButton</code>)替换 <code>gtk::Button</code> 了。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_subclassing/1/main.rs">listings/g_object_subclassing/1/main.rs</a></p>
<pre><code class="language-rust">mod custom_button;

use custom_button::CustomButton;
use gtk::prelude::*;
use gtk::{glib, Application, ApplicationWindow};

const APP_ID: &amp;str = "org.gtk_rs.GObjectSubclassing1";

fn main() -&gt; glib::ExitCode {
    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to "activate" signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

fn build_ui(app: &amp;Application) {
    // Create a button
    let button = CustomButton::with_label("Press me!");
    button.set_margin_top(12);
    button.set_margin_bottom(12);
    button.set_margin_start(12);
    button.set_margin_end(12);

    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |button| {
        // Set the label to "Hello World!" after the button has been clicked on
        button.set_label("Hello World!");
    });

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .child(&amp;button)
        .build();

    // Present window
    window.present();
}</code></pre>
<blockquote>
<p>用两个结构体来描述对象是 C 语言中定义 GObject 的一种特殊方式。<code>imp::CustomButton</code> 处理 GObject 的状态和重写的虚方法。 <code>CustomButton</code> 从已实现的 trait 和添加的方法中确定要暴露的方法。</p>
</blockquote>
<h2 id="添加功能"><a class="header" href="#添加功能">添加功能</a></h2>
<p>我们可以用 <code>CustomButton</code> 代替 <code>gtk::Button</code>。 这很酷，但在实际应用中不太有吸引力。 尽管收益为零，但毕竟提供了不少代码模板。</p>
<p>所以，让我们把它变得更有趣一些吧！<code>gtk::Button</code> 并不会保存太多状态，但我们可以让 <code>CustomButton</code> 保存一个数字。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_subclassing/2/custom_button/imp.rs">listings/g_object_subclassing/2/custom_button/imp.rs</a></p>
<pre><code class="language-rust">use std::cell::Cell;

use gtk::glib;
use gtk::prelude::*;
use gtk::subclass::prelude::*;

// Object holding the state
#[derive(Default)]
pub struct CustomButton {
    number: Cell&lt;i32&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for CustomButton {
    const NAME: &amp;'static str = "MyGtkAppCustomButton";
    type Type = super::CustomButton;
    type ParentType = gtk::Button;
}

// Trait shared by all GObjects
impl ObjectImpl for CustomButton {
    fn constructed(&amp;self) {
        self.parent_constructed();
        self.obj().set_label(&amp;self.number.get().to_string());
    }
}

// Trait shared by all widgets
impl WidgetImpl for CustomButton {}

// Trait shared by all buttons
impl ButtonImpl for CustomButton {
    fn clicked(&amp;self) {
        self.number.set(self.number.get() + 1);
        self.obj().set_label(&amp;self.number.get().to_string())
    }
}</code></pre>
<p>我们在 <code>ObjectImpl</code> 中重写了 <code>constructed</code>，这样按钮的标签就会初始化为<code>number</code>.  我们还重写了 <code>ButtonImpl</code> 中的 <code>clicked</code>，这样每次点击都会使<code>number</code>自增并更新标签。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_subclassing/2/main.rs">listings/g_object_subclassing/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectSubclassing2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Create a button
    let button = CustomButton::new();
    button.set_margin_top(12);
    button.set_margin_bottom(12);
    button.set_margin_start(12);
    button.set_margin_end(12);

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .child(&amp;button)
        .build();

    // Present window
    window.present();
}</code></pre>
<p>在 <code>build_ui</code> 中，我们不再调用 <code>connect_clicked</code>，仅此而已。 重新构建后，应用程序出现了标签为 "0" 的自定义按钮。 每次点击按钮，标签显示的数字都会增加 1。</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/g_object_subclassing.webm" type="video/webm">
  <p>A video showing that pressing on a button increases the number</p>
 </video>
</div>
<p>那么，我们什么时候需要从 GObject 继承呢？</p>
<ul>
<li>我们想使用某个控件，但要添加状态和重写虚函数。</li>
<li>我们想将 Rust 对象传递给函数，但该函数需要一个 GObject。</li>
<li>我们想向对象添加属性或信号。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型值"><a class="header" href="#泛型值">泛型值</a></h1>
<p>一些与 GObject 相关的函数依赖于其参数或返回参数的泛型。 由于 GObject 的内省是通过 C 语言接口工作的，因此这些函数不能依赖于任何强大的 Rust 概念。 在这种情况下，需要使用<a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/value/struct.Value.html"><code>glib::Value</code></a> 或 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/variant/struct.Variant.html"><code>glib::Variant</code></a>.</p>
<h2 id="value"><a class="header" href="#value">Value</a></h2>
<p>我们先从 <code>Value</code> 开始。从概念上讲，<code>Value</code> 类似 Rust 的 <code>enum</code> ，定义如下：</p>
<pre><code class="language-rust  no_run noplayground">enum Value &lt;T&gt; {
    bool(bool),
    i8(i8),
    i32(i32),
    u32(u32),
    i64(i64),
    u64(u64),
    f32(f32),
    f64(f64),
    // boxed types
    String(Option&lt;String&gt;),
    Object(Option&lt;dyn IsA&lt;glib::Object&gt;&gt;),
}</code></pre>
<p>例如，您可以这样使用<code>Value</code> 代表  <code>i32</code> 的值。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_values/1/main.rs">listings/g_object_values/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // Store `i32` as `Value`
    let integer_value = 10.to_value();

    // Retrieve `i32` from `Value`
    let integer = integer_value
        .get::&lt;i32&gt;()
        .expect("The value needs to be of type `i32`.");

    // Check if the retrieved value is correct
    assert_eq!(integer, 10);
<span class="boring">
</span><span class="boring">    // Store string as `Value`
</span><span class="boring">    let string_value = "Hello!".to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `String` from `Value`
</span><span class="boring">    let string = string_value
</span><span class="boring">        .get::&lt;String&gt;()
</span><span class="boring">        .expect("The value needs to be of type `String`.");
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(string, "Hello!".to_string());
</span><span class="boring">
</span><span class="boring">    // Store `Option&lt;String&gt;` as `Value`
</span><span class="boring">    let string_some_value = "Hello!".to_value();
</span><span class="boring">    let string_none_value = None::&lt;String&gt;.to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `String` from `Value`
</span><span class="boring">    let string_some = string_some_value
</span><span class="boring">        .get::&lt;Option&lt;String&gt;&gt;()
</span><span class="boring">        .expect("The value needs to be of type `Option&lt;String&gt;`.");
</span><span class="boring">    let string_none = string_none_value
</span><span class="boring">        .get::&lt;Option&lt;String&gt;&gt;()
</span><span class="boring">        .expect("The value needs to be of type `Option&lt;String&gt;`.");
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(string_some, Some("Hello!".to_string()));
</span><span class="boring">    assert_eq!(string_none, None);
</span><span class="boring">}</span></code></pre>
<p>还要注意的是，在上述枚举中，<code>String</code> 或 <code>glib::Object</code> 等 <a href="https://gnome.pages.gitlab.gnome.org/libsoup/gobject/gobject-Boxed-Types.html">boxed</a> 类型被封装在一个 <code>Option</code> 中。 这源于 C 语言，在 C 语言中，每个 boxed 类型都有可能是 <code>None</code>（或 C 语言中的 <code>NULL</code>）。 您仍然可以按照与上述 <code>i32</code> 相同的方式访问它。如果指定了错误的类型，<a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/value/struct.Value.html#method.get"><code>get</code></a>  会返回 <code>Err</code>，而且如果 <code>Value</code> 代表 <code>None</code>，也会返回 <code>Err</code>。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_values/1/main.rs">listings/g_object_values/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Store `i32` as `Value`
</span><span class="boring">    let integer_value = 10.to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `i32` from `Value`
</span><span class="boring">    let integer = integer_value
</span><span class="boring">        .get::&lt;i32&gt;()
</span><span class="boring">        .expect("The value needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(integer, 10);
</span><span class="boring">
</span>    // Store string as `Value`
    let string_value = "Hello!".to_value();

    // Retrieve `String` from `Value`
    let string = string_value
        .get::&lt;String&gt;()
        .expect("The value needs to be of type `String`.");

    // Check if the retrieved value is correct
    assert_eq!(string, "Hello!".to_string());
<span class="boring">
</span><span class="boring">    // Store `Option&lt;String&gt;` as `Value`
</span><span class="boring">    let string_some_value = "Hello!".to_value();
</span><span class="boring">    let string_none_value = None::&lt;String&gt;.to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `String` from `Value`
</span><span class="boring">    let string_some = string_some_value
</span><span class="boring">        .get::&lt;Option&lt;String&gt;&gt;()
</span><span class="boring">        .expect("The value needs to be of type `Option&lt;String&gt;`.");
</span><span class="boring">    let string_none = string_none_value
</span><span class="boring">        .get::&lt;Option&lt;String&gt;&gt;()
</span><span class="boring">        .expect("The value needs to be of type `Option&lt;String&gt;`.");
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(string_some, Some("Hello!".to_string()));
</span><span class="boring">    assert_eq!(string_none, None);
</span><span class="boring">}</span></code></pre>
<p>如果要区分是指定了错误的类型还是 <code>Value</code> 值为 <code>None</code> ，只需调用 <code>get::&lt;Option&lt;T&gt;&gt;</code> 即可。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_values/1/main.rs">listings/g_object_values/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Store `i32` as `Value`
</span><span class="boring">    let integer_value = 10.to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `i32` from `Value`
</span><span class="boring">    let integer = integer_value
</span><span class="boring">        .get::&lt;i32&gt;()
</span><span class="boring">        .expect("The value needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(integer, 10);
</span><span class="boring">
</span><span class="boring">    // Store string as `Value`
</span><span class="boring">    let string_value = "Hello!".to_value();
</span><span class="boring">
</span><span class="boring">    // Retrieve `String` from `Value`
</span><span class="boring">    let string = string_value
</span><span class="boring">        .get::&lt;String&gt;()
</span><span class="boring">        .expect("The value needs to be of type `String`.");
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(string, "Hello!".to_string());
</span><span class="boring">
</span>    // Store `Option&lt;String&gt;` as `Value`
    let string_some_value = "Hello!".to_value();
    let string_none_value = None::&lt;String&gt;.to_value();

    // Retrieve `String` from `Value`
    let string_some = string_some_value
        .get::&lt;Option&lt;String&gt;&gt;()
        .expect("The value needs to be of type `Option&lt;String&gt;`.");
    let string_none = string_none_value
        .get::&lt;Option&lt;String&gt;&gt;()
        .expect("The value needs to be of type `Option&lt;String&gt;`.");

    // Check if the retrieved value is correct
    assert_eq!(string_some, Some("Hello!".to_string()));
    assert_eq!(string_none, None);
<span class="boring">}</span></code></pre>
<p>我们将在后面处理属性和信号时使用 <code>Value</code>。</p>
<h2 id="variant"><a class="header" href="#variant">Variant</a></h2>
<p>当数据需要序列化时，例如将数据发送到另一个进程或通过网络，或将数据存储到磁盘时，就会用到<code>Variant</code>. 虽然 <code>GVariant</code> 支持任意复杂的类型，但 Rust 绑定目前仅限于<code>bool</code>, <code>u8</code>, <code>i16</code>, <code>u16</code>, <code>i32</code>, <code>u32</code>, <code>i64</code>, <code>u64</code>, <code>f64</code>, <code>&amp;str</code>/<code>String</code> 和 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.VariantDict.html"><code>VariantDict</code></a>. 上述类型的容器也可以使用，如 <code>HashMap</code>、<code>Vec</code>、<code>Option</code>、最多 16 个元素的元组(typle)和 <code>Variant</code>。 只要 Rust 结构体的成员可以用<code>Variant</code>表示，<code>Variant</code>甚至可以从 Rust 结构体<a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib_macros/derive.Variant.html#">派生</a>。</p>
<p>在最简单的情况下，将 Rust 类型转换为 <code>Variant</code> 或反向转换，与处理 <code>Value</code> 的方式非常相似。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_values/2/main.rs">listings/g_object_values/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // Store `i32` as `Variant`
    let integer_variant = 10.to_variant();

    // Retrieve `i32` from `Variant`
    let integer = integer_variant
        .get::&lt;i32&gt;()
        .expect("The variant needs to be of type `i32`.");

    // Check if the retrieved value is correct
    assert_eq!(integer, 10);
<span class="boring">
</span><span class="boring">    let variant = vec!["Hello", "there!"].to_variant();
</span><span class="boring">    assert_eq!(variant.n_children(), 2);
</span><span class="boring">    let vec = &amp;variant
</span><span class="boring">        .get::&lt;Vec&lt;String&gt;&gt;()
</span><span class="boring">        .expect("The variant needs to be of type `String`.");
</span><span class="boring">    assert_eq!(vec[0], "Hello");
</span><span class="boring">}</span></code></pre>
<p>不过，<code>Variant</code> 也可以表示 <code>HashMap</code> 或 <code>Vec</code> 等容器。 下面的代码段展示了如何在 <code>Vec</code> 和 <code>Variant</code> 之间进行转换。 更多示例请参见<a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/variant/index.html">文档</a>。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_values/2/main.rs">listings/g_object_values/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Store `i32` as `Variant`
</span><span class="boring">    let integer_variant = 10.to_variant();
</span><span class="boring">
</span><span class="boring">    // Retrieve `i32` from `Variant`
</span><span class="boring">    let integer = integer_variant
</span><span class="boring">        .get::&lt;i32&gt;()
</span><span class="boring">        .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">    // Check if the retrieved value is correct
</span><span class="boring">    assert_eq!(integer, 10);
</span><span class="boring">
</span>    let variant = vec!["Hello", "there!"].to_variant();
    assert_eq!(variant.n_children(), 2);
    let vec = &amp;variant
        .get::&lt;Vec&lt;String&gt;&gt;()
        .expect("The variant needs to be of type `String`.");
    assert_eq!(vec[0], "Hello");
<span class="boring">}</span></code></pre>
<p>我们将在使用  <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Settings.html"><code>gio::Settings</code></a>  保存设置或通过 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Action.html"><code>gio::Action</code></a> 激活操作时使用 <code>Variant</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="属性"><a class="header" href="#属性">属性</a></h1>
<p>属性(Properties)为访问 GObject 的状态提供了一个公共 API.</p>
<p>让我们通过 <code>Switch</code> 控件来看看如何实现这一点。 它的一个属性叫做  <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Switch.html#active">active</a>. 根据 GTK 文档，它可以被读取和写入。 因此，<code>gtk-rs</code> 提供了相应的  <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Switch.html#method.is_active"><code>is_active</code></a> 和 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Switch.html#method.set_active"><code>set_active</code></a> 方法。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_properties/1/main.rs">listings/g_object_properties/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Align, Application, ApplicationWindow, Box, Orientation, Switch};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectProperties1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create the switch
    let switch = Switch::new();

    // Set and then immediately obtain active property
    switch.set_active(true);
    let switch_active = switch.is_active();

    // This prints: "The active property of switch is true"
    println!("The active property of switch is {}", switch_active);
<span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;switch);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>属性不仅可以通过 getter 和 setter 访问，还可以相互绑定。 让我们看看两个 <code>Switch</code> 实例是如何绑定的。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_properties/2/main.rs">listings/g_object_properties/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Align, Application, ApplicationWindow, Box, Orientation, Switch};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectProperties3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create the switches
    let switch_1 = Switch::new();
    let switch_2 = Switch::new();
<span class="boring">
</span><span class="boring">    switch_1
</span><span class="boring">        .bind_property("active", &amp;switch_2, "active")
</span><span class="boring">        .bidirectional()
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;switch_1);
</span><span class="boring">    gtk_box.append(&amp;switch_2);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>在本例中，我们希望将 <code>switch_1</code> 的 "active" 属性与 <code>switch_2</code> 的 "active" 属性绑定。 我们还希望绑定是双向的，因此通过调用 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/struct.BindingBuilder.html#method.bidirectional"><code>bidirectional</code></a> 方法来指定。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_properties/2/main.rs">listings/g_object_properties/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Align, Application, ApplicationWindow, Box, Orientation, Switch};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectProperties3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create the switches
</span><span class="boring">    let switch_1 = Switch::new();
</span><span class="boring">    let switch_2 = Switch::new();
</span><span class="boring">
</span>    switch_1
        .bind_property("active", &amp;switch_2, "active")
        .bidirectional()
        .build();
<span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;switch_1);
</span><span class="boring">    gtk_box.append(&amp;switch_2);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>现在，当我们点击两个开关中的一个时，另一个也会被切换。</p>
<div style="text-align:center">
 <video autoplay muted loop>
    <source src="vid/g_object_properties_switches.webm">
    <p>A video which shows that toggling one button also toggles the other one </p>
 </video>
</div>
<h2 id="给自定义-gobject-添加属性"><a class="header" href="#给自定义-gobject-添加属性">给自定义 GObject 添加属性</a></h2>
<p>我们还可以为自定义 GObject 添加属性。 我们可以通过将 <code>CustomButton</code> 的 <code>number</code> 绑定到一个属性来演示这一点。 大部分工作由 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/derive.Properties.html"><code>glib::Properties</code></a> 派生宏(derive macro)完成。 我们告诉它封装类型是 <code>super::CustomButton</code>。 我们还给 <code>number</code> 添加了注释，这样宏就知道它应该创建一个可读可写的属性 "number"。 宏还会生成本章稍后将使用的<a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/derive.Properties.html#generated-wrapper-methods">封装方法</a>。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_properties/3/custom_button/imp.rs">listings/g_object_properties/3/custom_button/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">use glib::Properties;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span>// Object holding the state
#[derive(Properties, Default)]
#[properties(wrapper_type = super::CustomButton)]
pub struct CustomButton {
    #[property(get, set)]
    number: Cell&lt;i32&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for CustomButton {
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppCustomButton";
</span><span class="boring">    type Type = super::CustomButton;
</span><span class="boring">    type ParentType = gtk::Button;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">#[glib::derived_properties]
</span><span class="boring">impl ObjectImpl for CustomButton {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Bind label to number
</span><span class="boring">        // `SYNC_CREATE` ensures that the label will be immediately set
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.bind_property("number", obj.as_ref(), "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all buttons
</span><span class="boring">impl ButtonImpl for CustomButton {
</span><span class="boring">    fn clicked(&amp;self) {
</span><span class="boring">        let incremented_number = self.obj().number() + 1;
</span><span class="boring">        self.obj().set_number(incremented_number);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/attr.derived_properties.html"><code>glib::derived_properties</code></a> 宏为每个使用 <code>Property</code> 宏生成属性的 GObject 生成了模板。 在 <code>constructed</code> 中，我们通过绑定 "label "属性来使用新属性 "number"。<code>bind_property</code> 会自行将 "number "的整数值转换为 "label "的字符串。 现在，我们不必再在 "clicked" 回调函数中调整标签了。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_properties/3/custom_button/imp.rs">listings/g_object_properties/3/custom_button/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">use glib::Properties;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(Properties, Default)]
</span><span class="boring">#[properties(wrapper_type = super::CustomButton)]
</span><span class="boring">pub struct CustomButton {
</span><span class="boring">    #[property(get, set)]
</span><span class="boring">    number: Cell&lt;i32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for CustomButton {
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppCustomButton";
</span><span class="boring">    type Type = super::CustomButton;
</span><span class="boring">    type ParentType = gtk::Button;
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
#[glib::derived_properties]
impl ObjectImpl for CustomButton {
    fn constructed(&amp;self) {
        self.parent_constructed();

        // Bind label to number
        // `SYNC_CREATE` ensures that the label will be immediately set
        let obj = self.obj();
        obj.bind_property("number", obj.as_ref(), "label")
            .sync_create()
            .build();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all buttons
</span><span class="boring">impl ButtonImpl for CustomButton {
</span><span class="boring">    fn clicked(&amp;self) {
</span><span class="boring">        let incremented_number = self.obj().number() + 1;
</span><span class="boring">        self.obj().set_number(incremented_number);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>我们还必须调整 <code>clicked</code> 方法。 以前我们直接修改 <code>number</code>，现在我们可以使用生成的封装方法 <code>number</code> 和 <code>set_number</code>。 这样就会发出 "notify "信号，这对于绑定正常工作是必要的。</p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">use glib::Properties;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(Properties, Default)]
</span><span class="boring">#[properties(wrapper_type = super::CustomButton)]
</span><span class="boring">pub struct CustomButton {
</span><span class="boring">    #[property(get, set)]
</span><span class="boring">    number: Cell&lt;i32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for CustomButton {
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppCustomButton";
</span><span class="boring">    type Type = super::CustomButton;
</span><span class="boring">    type ParentType = gtk::Button;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">#[glib::derived_properties]
</span><span class="boring">impl ObjectImpl for CustomButton {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Bind label to number
</span><span class="boring">        // `SYNC_CREATE` ensures that the label will be immediately set
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.bind_property("number", obj.as_ref(), "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span>// Trait shared by all buttons
impl ButtonImpl for CustomButton {
    fn clicked(&amp;self) {
        let incremented_number = self.obj().number() + 1;
        self.obj().set_number(incremented_number);
    }
}</code></pre>
<p>让我们通过创建两个自定义按钮来看看能做些什么。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_properties/3/main.rs">listings/g_object_properties/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Align, Application, ApplicationWindow, Box, Orientation};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectProperties4";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create the buttons
    let button_1 = CustomButton::new();
    let button_2 = CustomButton::new();
<span class="boring">
</span><span class="boring">    // Assure that "number" of `button_2` is always 1 higher than "number" of `button_1`
</span><span class="boring">    button_1
</span><span class="boring">        .bind_property("number", &amp;button_2, "number")
</span><span class="boring">        // How to transform "number" from `button_1` to "number" of `button_2`
</span><span class="boring">        .transform_to(|_, number: i32| {
</span><span class="boring">            let incremented_number = number + 1;
</span><span class="boring">            Some(incremented_number.to_value())
</span><span class="boring">        })
</span><span class="boring">        // How to transform "number" from `button_2` to "number" of `button_1`
</span><span class="boring">        .transform_from(|_, number: i32| {
</span><span class="boring">            let decremented_number = number - 1;
</span><span class="boring">            Some(decremented_number.to_value())
</span><span class="boring">        })
</span><span class="boring">        .bidirectional()
</span><span class="boring">        .sync_create()
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // The closure will be called
</span><span class="boring">    // whenever the property "number" of `button_1` gets changed
</span><span class="boring">    button_1.connect_number_notify(|button| {
</span><span class="boring">        println!("The current number of `button_1` is {}.", button.number());
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>我们已经看到，绑定的属性不一定必须是同一类型。 利用 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/struct.BindingBuilder.html#method.transform_to"><code>transform_to</code></a> 和 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/struct.BindingBuilder.html#method.transform_from"><code>transform_from</code></a>, 我们可以确保 <code>button_2</code> 显示的数字总是比 <code>button_1</code> 显示的数字大 1.</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_properties/3/main.rs">listings/g_object_properties/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Align, Application, ApplicationWindow, Box, Orientation};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectProperties4";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create the buttons
</span><span class="boring">    let button_1 = CustomButton::new();
</span><span class="boring">    let button_2 = CustomButton::new();
</span><span class="boring">
</span>    // Assure that "number" of `button_2` is always 1 higher than "number" of `button_1`
    button_1
        .bind_property("number", &amp;button_2, "number")
        // How to transform "number" from `button_1` to "number" of `button_2`
        .transform_to(|_, number: i32| {
            let incremented_number = number + 1;
            Some(incremented_number.to_value())
        })
        // How to transform "number" from `button_2` to "number" of `button_1`
        .transform_from(|_, number: i32| {
            let decremented_number = number - 1;
            Some(decremented_number.to_value())
        })
        .bidirectional()
        .sync_create()
        .build();
<span class="boring">
</span><span class="boring">    // The closure will be called
</span><span class="boring">    // whenever the property "number" of `button_1` gets changed
</span><span class="boring">    button_1.connect_number_notify(|button| {
</span><span class="boring">        println!("The current number of `button_1` is {}.", button.number());
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>现在，如果我们点击其中一个按钮，另一个按钮的 "number" 和 "label" 属性也会随之改变。</p>
<div style="text-align:center">
 <video autoplay muted loop>
    <source src="vid/g_object_properties_buttons.webm">
    <p>A video which shows that pressing on one button also changes the number on the other one</p>
 </video>
</div>
<p>属性的另一个优点是，当属性发生变化时，可以将回调连接到事件。 例如：</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_properties/3/main.rs">listings/g_object_properties/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Align, Application, ApplicationWindow, Box, Orientation};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectProperties4";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create the buttons
</span><span class="boring">    let button_1 = CustomButton::new();
</span><span class="boring">    let button_2 = CustomButton::new();
</span><span class="boring">
</span><span class="boring">    // Assure that "number" of `button_2` is always 1 higher than "number" of `button_1`
</span><span class="boring">    button_1
</span><span class="boring">        .bind_property("number", &amp;button_2, "number")
</span><span class="boring">        // How to transform "number" from `button_1` to "number" of `button_2`
</span><span class="boring">        .transform_to(|_, number: i32| {
</span><span class="boring">            let incremented_number = number + 1;
</span><span class="boring">            Some(incremented_number.to_value())
</span><span class="boring">        })
</span><span class="boring">        // How to transform "number" from `button_2` to "number" of `button_1`
</span><span class="boring">        .transform_from(|_, number: i32| {
</span><span class="boring">            let decremented_number = number - 1;
</span><span class="boring">            Some(decremented_number.to_value())
</span><span class="boring">        })
</span><span class="boring">        .bidirectional()
</span><span class="boring">        .sync_create()
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // The closure will be called
    // whenever the property "number" of `button_1` gets changed
    button_1.connect_number_notify(|button| {
        println!("The current number of `button_1` is {}.", button.number());
    });
<span class="boring">
</span><span class="boring">    // Set up box
</span><span class="boring">    let gtk_box = Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present the window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>现在，每当 "number" 属性发生变化时，闭包就会被执行，并将 "number" 的当前值打印到标准输出中。</p>
<p>将属性引入您的自定义 GObject 将会非常有用，如果您想：</p>
<ul>
<li>绑定（不同）GObject 的状态</li>
<li>在属性值发生变化时通知消费者</li>
</ul>
<p>请注意，每次值发生变化时发送信号都会产生（计算）代价。 如果您只想暴露内部状态，添加 getter 和 setter 方法是更好的选择。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="信号"><a class="header" href="#信号">信号</a></h1>
<p>GObject 信号是一个为特定事件注册回调的系统。 例如，如果我们按下一个按钮，"clicked（点击）"信号就会发出。 然后，该信号将负责执行所有已注册的回调函数。</p>
<p><code>gtk-rs</code> 提供了注册回调的便捷方法。 在我们的 "Hello World" 示例中，我们将 "clicked" 信号<a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.ButtonExt.html#tymethod.connect_clicked">连接</a>到一个闭包，一旦它被调用，就会将按钮的标签设置为 "Hello World"。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/hello_world/3/main.rs">listings/hello_world/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow, Button};
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.HelloWorld3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button with label and margins
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect to "clicked" signal of `button`
    button.connect_clicked(|button| {
        // Set the label to "Hello World!" after the button has been clicked on
        button.set_label("Hello World!");
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>如果我们愿意，可以使用通用的 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/trait.ObjectExt.html#tymethod.connect_closure"><code>connect_closure</code></a> 方法和 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/macro.closure_local.html"><code>glib::closure_local!</code></a> 宏来连接它。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_signals/1/main.rs">listings/g_object_signals/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::closure_local;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectSignals1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect to "clicked" signal of `button`
    button.connect_closure(
        "clicked",
        false,
        closure_local!(move |button: Button| {
            // Set the label to "Hello World!" after the button has been clicked on
            button.set_label("Hello World!");
        }),
    );

<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p><code>connect_closure</code> 的优势在于它还能与自定义信号一起使用。</p>
<blockquote>
<p>如果您需要在闭包中克隆引用计数对象，则不必将其封装在另一个<code>clone!</code> 宏中。
<code>closure_local!</code> 接受与创建强/弱引用相同的语法，并具有<a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/macro.closure.html#object-watching">监视</a>功能，一旦监视对象被删除，闭包就会自动断开连接。</p>
</blockquote>
<h2 id="向自定义-gobject-添加信号"><a class="header" href="#向自定义-gobject-添加信号">向自定义 GObject 添加信号</a></h2>
<p>让我们看看如何创建自己的信号。 现在，让我们可以来扩展 <code>CustomButton</code>。 首先，我们覆盖 <code>ObjectImpl</code> 中的 <code>signals</code> 方法。 <a href="https://doc.rust-lang.org/std/sync/struct.OnceLock.html"><code>std::sync::OnceLock</code></a> 可以确保 <code>SIGNALS</code> 只被初始化一次。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_signals/2/custom_button/imp.rs">listings/g_object_signals/2/custom_button/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">use std::sync::OnceLock;
</span><span class="boring">
</span><span class="boring">use glib::subclass::Signal;
</span><span class="boring">use glib::Properties;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(Properties, Default)]
</span><span class="boring">#[properties(wrapper_type = super::CustomButton)]
</span><span class="boring">pub struct CustomButton {
</span><span class="boring">    #[property(get, set)]
</span><span class="boring">    number: Cell&lt;i32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for CustomButton {
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppCustomButton";
</span><span class="boring">    type Type = super::CustomButton;
</span><span class="boring">    type ParentType = gtk::Button;
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
#[glib::derived_properties]
impl ObjectImpl for CustomButton {
    fn signals() -&gt; &amp;'static [Signal] {
        static SIGNALS: OnceLock&lt;Vec&lt;Signal&gt;&gt; = OnceLock::new();
        SIGNALS.get_or_init(|| {
            vec![Signal::builder("max-number-reached")
                .param_types([i32::static_type()])
                .build()]
        })
    }
<span class="boring">
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Bind label to number
</span><span class="boring">        // `SYNC_CREATE` ensures that the label will be immediately set
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.bind_property("number", obj.as_ref(), "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">static MAX_NUMBER: i32 = 8;
</span><span class="boring">
</span><span class="boring">// Trait shared by all buttons
</span><span class="boring">impl ButtonImpl for CustomButton {
</span><span class="boring">    fn clicked(&amp;self) {
</span><span class="boring">        let incremented_number = self.obj().number() + 1;
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        // If `number` reached `MAX_NUMBER`,
</span><span class="boring">        // emit "max-number-reached" signal and set `number` back to 0
</span><span class="boring">        if incremented_number == MAX_NUMBER {
</span><span class="boring">            obj.emit_by_name::&lt;()&gt;("max-number-reached", &amp;[&amp;incremented_number]);
</span><span class="boring">            obj.set_number(0);
</span><span class="boring">        } else {
</span><span class="boring">            obj.set_number(incremented_number);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>signals</code> 方法负责定义一组信号。 在本例中，我们只创建了一个名为 "max-number-reached" 的信号。 在命名信号时，我们确保使用<a href="https://en.wikipedia.org/wiki/Letter_case#Kebab_case">短横线命名法(kebab-case)</a>进行命名。 当信号发出时，它会发送一个 <code>i32</code> 值。</p>
<p>我们希望在<code>number</code> 达到 <code>MAX_NUMBER</code> 时发出信号。 在发送信号的同时，我们还将发送 <code>number</code> 当前的值。 之后，我们将<code>number</code> 重置为 0.</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_signals/2/custom_button/imp.rs">listings/g_object_signals/2/custom_button/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">use std::sync::OnceLock;
</span><span class="boring">
</span><span class="boring">use glib::subclass::Signal;
</span><span class="boring">use glib::Properties;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(Properties, Default)]
</span><span class="boring">#[properties(wrapper_type = super::CustomButton)]
</span><span class="boring">pub struct CustomButton {
</span><span class="boring">    #[property(get, set)]
</span><span class="boring">    number: Cell&lt;i32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for CustomButton {
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppCustomButton";
</span><span class="boring">    type Type = super::CustomButton;
</span><span class="boring">    type ParentType = gtk::Button;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">#[glib::derived_properties]
</span><span class="boring">impl ObjectImpl for CustomButton {
</span><span class="boring">    fn signals() -&gt; &amp;'static [Signal] {
</span><span class="boring">        static SIGNALS: OnceLock&lt;Vec&lt;Signal&gt;&gt; = OnceLock::new();
</span><span class="boring">        SIGNALS.get_or_init(|| {
</span><span class="boring">            vec![Signal::builder("max-number-reached")
</span><span class="boring">                .param_types([i32::static_type()])
</span><span class="boring">                .build()]
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Bind label to number
</span><span class="boring">        // `SYNC_CREATE` ensures that the label will be immediately set
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.bind_property("number", obj.as_ref(), "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span>static MAX_NUMBER: i32 = 8;

// Trait shared by all buttons
impl ButtonImpl for CustomButton {
    fn clicked(&amp;self) {
        let incremented_number = self.obj().number() + 1;
        let obj = self.obj();
        // If `number` reached `MAX_NUMBER`,
        // emit "max-number-reached" signal and set `number` back to 0
        if incremented_number == MAX_NUMBER {
            obj.emit_by_name::&lt;()&gt;("max-number-reached", &amp;[&amp;incremented_number]);
            obj.set_number(0);
        } else {
            obj.set_number(incremented_number);
        }
    }
}</code></pre>
<p>如果我们现在按下按钮，其标签上的数字就会增加，直到达到 <code>MAX_NUMBER</code>. 然后它会发出 "max-number-reached" 信号，我们可以很好地连接到该信号。 现在，每当我们收到 "max-number-reached" 信号时，相应的数字就会打印到<a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_output_(stdout)">标准输出</a>中。</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/g_object_signals/2/main.rs">listings/g_object_signals/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">use glib::closure_local;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.GObjectSignals2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = CustomButton::new();
</span><span class="boring">    button.set_margin_top(12);
</span><span class="boring">    button.set_margin_bottom(12);
</span><span class="boring">    button.set_margin_start(12);
</span><span class="boring">    button.set_margin_end(12);
</span><span class="boring">
</span>    button.connect_closure(
        "max-number-reached",
        false,
        closure_local!(move |_button: CustomButton, number: i32| {
            println!("The maximum number {} has been reached", number);
        }),
    );
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>现在，您已经知道如何连接各种信号以及如何创建自己的信号。 如果您想通知 GObject 的消费者发生了某一事件，自定义信号尤其有用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="主事件循环"><a class="header" href="#主事件循环">主事件循环</a></h1>
<p>我们现在已经能自如地使用回调了，但它们究竟是如何工作的呢？ 所有这些都是异步发生的，因此必须有一个东西来管理事件和调度响应。 不出所料，这就是所谓的主事件循环。</p>
<div style="text-align:center"><img src="img/main_event_loop.png" alt="Diagram showing the main event loop"/></div>
<p>主循环管理各种事件——从鼠标点击、键盘按下到文件事件。 所有这些工作都在同一线程内完成。 在所有任务之间快速迭代会给人一种并行的错觉。 这就是为什么你可以在进度条增长的同时移动窗口。</p>
<p>不过，你肯定见过图形界面无响应，至少有几秒钟是这样。 当单个任务耗时过长时，就会出现这种情况。 下面的示例使用  <a href="https://doc.rust-lang.org/std/thread/fn.sleep.html"><code>std::thread::sleep</code></a> 来表示一个长时间运行的任务。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/main_event_loop/1/main.rs">listings/main_event_loop/1/main.rs</a></p>
<pre><code class="language-rust">use std::thread;
use std::time::Duration;

use gtk::prelude::*;
use gtk::{self, glib, Application, ApplicationWindow, Button};

const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop1";

fn main() -&gt; glib::ExitCode {
    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to "activate" signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

fn build_ui(app: &amp;Application) {
    // Create a button
    let button = Button::builder()
        .label("Press me!")
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |_| {
        // GUI is blocked for 5 seconds after the button is pressed
        let five_seconds = Duration::from_secs(5);
        thread::sleep(five_seconds);
    });

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .child(&amp;button)
        .build();

    // Present window
    window.present();
}</code></pre>
<p>按下按钮后，界面会完全冻结五秒钟。 我们甚至无法移动窗口。 调用<code>sleep</code>是一个人为的例子，但我们经常希望一次性运行一个时间稍长的操作。</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/main_event_loop_1.webm" type="video/webm">
  <p>A video which shows that after pressing the button, the window can still be moved</p>
 </video>
</div>
<h2 id="如何避免阻塞主循环"><a class="header" href="#如何避免阻塞主循环">如何避免阻塞主循环</a></h2>
<p>为了避免阻塞主循环，我们可以使用 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/fn.spawn_blocking.html"><code>gio::spawn_blocking</code></a> 生成一个新任务，让操作在线程池中运行。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/main_event_loop/2/main.rs">listings/main_event_loop/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{self, gio, glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |_| {
        // The long running operation runs now in a separate thread
        gio::spawn_blocking(move || {
            let five_seconds = Duration::from_secs(5);
            thread::sleep(five_seconds);
        });
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>现在，当我们按下按钮时，界面不会冻结。 但是，每按一次按钮就会生成一个新任务。 这不一定是我们想要的。</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/main_event_loop_2.webm" type="video/webm">
  <p>A video which shows that after pressing the button, the window can still be moved</p>
 </video>
</div>
<blockquote>
<p>如果你来自 Rust 之外的其他语言，那么在考虑其他选项之前，你可能会对在独立线程中运行任务的想法感到不舒服。 幸运的是，Rust 的安全保证让你不再担心并发会带来令人讨厌的错误。</p>
</blockquote>
<h2 id="通道"><a class="header" href="#通道">通道</a></h2>
<p>通常，我们希望跟踪任务中的工作。 在我们的例子中，我们不希望用户在现有任务仍在运行时产生额外的任务。 为了与任务交换信息，我们可以使用 <a href="https://docs.rs/async-channel/latest/async_channel/index.html"><code>async-channel</code></a> 创建一个通道。 让我们在终端执行以下命令来添加它：</p>
<pre><code>cargo add async-channel
</code></pre>
<p>我们要发送一个 <code>bool</code> 值，以告知是否希望按钮对点击做出反应。 由于我们在单独的线程中发送，因此可以使用  <a href="https://docs.rs/async-channel/latest/async_channel/struct.Sender.html#method.send_blocking"><code>send_blocking</code></a>. 那接收呢？ 每次收到消息时，我们都想根据收到的 <code>bool</code> 设置按钮的灵敏度。 但是，我们不想在等待接收消息时阻塞主循环。 毕竟这才是整个练习的重点！</p>
<p>我们通过在一个异步(<a href="https://rust-lang.github.io/async-book/"><code>async</code></a>)代码块中等待消息来解决这个问题。 这个异步代码块在 <code>glib</code> 主循环中使用  <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/fn.spawn_future_local.html"><code>spawn_future_local</code></a> 生成。</p>
<blockquote>
<p>另请参阅  <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/fn.spawn_future.html"><code>spawn_future</code></a> ，从主线程外在主循环上生成异步代码块。</p>
</blockquote>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/main_event_loop/3/main.rs">listings/main_event_loop/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Create channel that can hold at most 1 message at a time
    let (sender, receiver) = async_channel::bounded(1);
    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |_| {
        let sender = sender.clone();
        // The long running operation runs now in a separate thread
        gio::spawn_blocking(move || {
            // Deactivate the button until the operation is done
            sender
                .send_blocking(false)
                .expect("The channel needs to be open.");
            let five_seconds = Duration::from_secs(5);
            thread::sleep(five_seconds);
            // Activate the button again
            sender
                .send_blocking(true)
                .expect("The channel needs to be open.");
        });
    });

    // The main loop executes the asynchronous block
    glib::spawn_future_local(clone!(
        #[weak]
        button,
        async move {
            while let Ok(enable_button) = receiver.recv().await {
                button.set_sensitive(enable_button);
            }
        }
    ));
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>正如你所看到的，生成一个任务仍然不会冻结我们的用户界面。 不过，现在我们无法同时启动多个任务，因为在启动第一个任务后，按钮就变得不敏感了。 任务完成后，按钮又会变得敏感。</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/main_event_loop_3.webm" type="video/webm">
  <p>The button now stops being responsive for 10 seconds after being pressed</p>
 </video>
</div>
如果任务本质上是异步的怎么办？ 让我们尝试用 [`glib::timeout_future_seconds`](https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/fn.timeout_future_seconds.html) 代替 `std::thread::sleep` 来表示我们的任务。 它返回一个 [`std::future::Future`](https://doc.rust-lang.org/std/future/trait.Future.html)，这意味着我们可以在异步上下文中等待它。 转换后的代码在外观和行为上与多线程代码非常相似。
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/main_event_loop/4/main.rs">listings/main_event_loop/4/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop4";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Create channel that can hold at most 1 message at a time
    let (sender, receiver) = async_channel::bounded(1);
    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |_| {
        glib::spawn_future_local(clone!(
            #[strong]
            sender,
            async move {
                // Deactivate the button until the operation is done
                sender
                    .send(false)
                    .await
                    .expect("The channel needs to be open.");
                glib::timeout_future_seconds(5).await;
                // Activate the button again
                sender
                    .send(true)
                    .await
                    .expect("The channel needs to be open.");
            }
        ));
    });

    // The main loop executes the asynchronous block
    glib::spawn_future_local(clone!(
        #[weak]
        button,
        async move {
            while let Ok(enable_button) = receiver.recv().await {
                button.set_sensitive(enable_button);
            }
        }
    ));
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>由于我们又是单线程运行，我们甚至可以不需要通道并实现相同结果。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/main_event_loop/5/main.rs">listings/main_event_loop/5/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop5";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |button| {
        glib::spawn_future_local(clone!(
            #[weak]
            button,
            async move {
                // Deactivate the button until the operation is done
                button.set_sensitive(false);
                glib::timeout_future_seconds(5).await;
                // Activate the button again
                button.set_sensitive(true);
            }
        ));
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>但我们为什么不在多线程示例中做同样的事情呢？</p>
<pre><code class="language-rust  no_run compile_fail"><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">use glib::{clone, MainContext, PRIORITY_DEFAULT};
</span><span class="boring">use gtk::{glib, gio};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">       .application_id("org.gtk_rs.MainEventLoop6")
</span><span class="boring">       .build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Get command-line arguments
</span><span class="boring">    let args: Vec&lt;String&gt; = args().collect();
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run(&amp;args);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// When the application is launched…
</span><span class="boring">fn build_ui(application: &amp;Application) {
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(application)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // DOES NOT COMPILE!
    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |button| {
        button.clone();
        // The long running operation runs now in a separate thread
        gio::spawn_blocking(move || {
            // Deactivate the button until the operation is done
            button.set_sensitive(false);
            let five_seconds = Duration::from_secs(5);
            thread::sleep(five_seconds);
            // Activate the button again
            button.set_sensitive(true);
        });
    });
<span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>原因很简单，因为我们会收到这样的错误信息：</p>
<pre><code class="language-console">error[E0277]: `NonNull&lt;GObject&gt;` cannot be shared between threads safely

help: within `gtk4::Button`, the trait `Sync` is not implemented for `NonNull&lt;GObject&gt;`
</code></pre>
<p>经过循环引用后，我们发现了 GTK GObjects 的第二个缺点： 它们不是线程安全的。</p>
<h2 id="在-async-上下文中嵌入阻塞调用"><a class="header" href="#在-async-上下文中嵌入阻塞调用">在 <code>async</code> 上下文中嵌入阻塞调用</a></h2>
<p>在前面的代码片段中，我们已经看到在 <code>glib</code> 主循环中生成一个 <code>async</code> 块或 <code>async</code> future 比在独立线程上运行任务能带来更简洁的代码。 在 gtk-rs 应用中执行 <code>async</code> 函数时，我们还可以关注一些有趣的方面。</p>
<p>首先，阻塞函数可以嵌入 <code>async</code> 上下文中。 在下面的列表中，我们要执行一个同步函数，该函数返回一个布尔值，运行时间为 10 秒。 为了将其集成到 <code>async</code> 代码块中，我们通过 <code>spawn_blocking</code> 在单独的线程中运行该函数。 然后，我们可以在 <code>spawn_blocking</code> 的返回值上调用 <code>await</code> 来获取函数的返回值。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/main_event_loop/6/main.rs">listings/main_event_loop/6/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop6";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |button| {
        // The main loop executes the asynchronous block
        glib::spawn_future_local(clone!(
            #[weak]
            button,
            async move {
                // Deactivate the button until the operation is done
                button.set_sensitive(false);
                let enable_button = gio::spawn_blocking(move || {
                    let five_seconds = Duration::from_secs(5);
                    thread::sleep(five_seconds);
                    true
                })
                .await
                .expect("Task needs to finish successfully.");
                // Set sensitivity of button to `enable_button`
                button.set_sensitive(enable_button);
            }
        ));
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<h2 id="从外部-crate-运行异步函数"><a class="header" href="#从外部-crate-运行异步函数">从外部 crate 运行异步函数</a></h2>
<p><code>glib</code> 生态系统中的异步函数总是可以在 <code>glib</code> 主循环中生成。 通常情况下，依赖于 <code>async-std</code> 或 <code>smol</code> 的 crate 也可以工作。 以 <code>ashpd</code> 为例，它允许沙箱应用程序与桌面交互。 默认情况下，它依赖于 <code>async-std</code>。 我们可以通过运行以下命令将其添加到我们的依赖中。</p>
<pre><code>cargo add ashpd --features gtk4
</code></pre>
<p>您需要使用 Linux 桌面环境才能在本地运行下面的示例。 此示例使用  <a href="https://docs.rs/ashpd/latest/ashpd/desktop/account/index.html"><code>ashpd::desktop::account::UserInformation</code></a> 访问用户信息。 我们从按钮获取一个 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Native.html"><code>gtk::Native</code></a> 对象，创建一个 <a href="https://docs.rs/ashpd/latest/ashpd/enum.WindowIdentifier.html"><code>ashp::WindowIdentifier</code></a> 并将其传递给用户信息请求。</p>
<blockquote>
<p>我们需要通过 <code>WindowIdentifier</code> 使对话框成为模态对话框。 这意味着对话框将位于窗口顶部，并冻结应用程序的其他部分，不让用户输入。</p>
</blockquote>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/main_event_loop/7/main.rs">listings/main_event_loop/7/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use ashpd::desktop::account::UserInformation;
</span><span class="boring">use ashpd::WindowIdentifier;
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{glib, Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop7";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |button| {
        // The main loop executes the asynchronous block
        glib::spawn_future_local(clone!(
            #[weak]
            button,
            async move {
                // Get native of button for window identifier
                let native = button.native().expect("Need to be able to get native.");
                // Get window identifier so that the dialog will be modal to the main window
                let identifier = WindowIdentifier::from_native(&amp;native).await;
                let request = UserInformation::request()
                    .reason("App would like to access user information.")
                    .identifier(identifier)
                    .send()
                    .await;

                if let Ok(response) = request.and_then(|r| r.response()) {
                    println!("User name: {}", response.name());
                } else {
                    println!("Could not access user information.")
                }
            }
        ));
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>按下按钮后，会打开一个对话框，显示将要共享的信息。 如果您决定共享，您的用户名将被打印在控制台上。</p>
<div style="text-align:center"><img src="img/main_event_loop_ashpd.png" alt="Dialog requesting user information."/></div>
<h2 id="tokio"><a class="header" href="#tokio">Tokio</a></h2>
<p><a href="https://docs.rs/tokio/latest/tokio/"><code>tokio</code></a> 是 Rust 最流行的异步平台。 因此，许多高质量的 crate 都是其生态系统的一部分。 网络客户端 <a href="https://docs.rs/reqwest/latest/reqwest/"><code>reqwest</code></a> 就属于这一类。 让我们执行以下命令来添加它</p>
<pre><code>cargo add reqwest@0.12 --features rustls-tls --no-default-features
</code></pre>
<p>一旦按下按钮，我们就会向 www.gtk-rs.org 发送 <code>GET</code> 请求。 然后通过通道将响应发送到主线程。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/main_event_loop/8/main.rs">listings/main_event_loop/8/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::clone;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop8";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    let (sender, receiver) = async_channel::bounded(1);
    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |_| {
        // The main loop executes the asynchronous block
        glib::spawn_future_local(clone!(
            #[strong]
            sender,
            async move {
                let response = reqwest::get("https://www.gtk-rs.org").await;
                sender
                    .send(response)
                    .await
                    .expect("The channel needs to be open.");
            }
        ));
    });

    // The main loop executes the asynchronous block
    glib::spawn_future_local(async move {
        while let Ok(response) = receiver.recv().await {
            if let Ok(response) = response {
                println!("Status: {}", response.status());
            } else {
                println!("Could not make a `GET` request.");
            }
        }
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>编译正常，甚至似乎可以运行。 但是，当我们按下按钮时却什么也没发生。 检查控制台时发现了以下错误信息：</p>
<pre><code>thread 'main' panicked at
'there is no reactor running, must be called from the context of a Tokio 1.x runtime'
</code></pre>
<p>在撰写本文时，<code>reqwest</code> 没有说明这一要求。 不幸的是，其他依赖 <code>tokio</code> 的库也是如此。 让我们咬咬牙，添加 <code>tokio</code>：</p>
<pre><code>cargo add tokio@1 --features rt-multi-thread
</code></pre>
<p>由于我们已经在主线程上运行了 <code>glib</code> 主循环，因此我们不想在主线程上运行 <code>tokio</code> 运行时。 因此，我们要避免使用 <code>#[tokio::main]</code> 宏或顶级 <code>block_on</code> 调用。 这样做会阻塞运行时的一个线程与 GLib 主循环，既浪费资源，又可能产生奇怪的 bug。</p>
<p>相反，我们将 <a href="https://docs.rs/tokio/latest/tokio/runtime/struct.Runtime.html"><code>tokio::runtime::Runtime</code></a> 与静态变量绑定。</p>
<pre><code class="language-rust"><span class="boring">use std::sync::OnceLock;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">use tokio::runtime::Runtime;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop0";
</span><span class="boring">
</span>// DOES NOT COMPILE!
static RUNTIME: Runtime =
    Runtime::new().expect("Setting up tokio runtime needs to succeed.");
<span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">   // Create a new application
</span><span class="boring">   let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">   // Connect to "activate" signal of `app`
</span><span class="boring">   app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">   // Run the application
</span><span class="boring">   app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">   // Create a button
</span><span class="boring">   let button = Button::builder()
</span><span class="boring">       .label("Press me!")
</span><span class="boring">       .margin_top(12)
</span><span class="boring">       .margin_bottom(12)
</span><span class="boring">       .margin_start(12)
</span><span class="boring">       .margin_end(12)
</span><span class="boring">       .build();
</span><span class="boring">
</span><span class="boring">   // ANCHOR: callback
</span><span class="boring">   let (sender, receiver) = async_channel::bounded(1);
</span><span class="boring">   // Connect to "clicked" signal of `button`
</span><span class="boring">   button.connect_clicked(move |_| {
</span><span class="boring">       RUNTIME.spawn(clone!(#[strong] sender, async move {
</span><span class="boring">           let response = reqwest::get("https://www.gtk-rs.org").await;
</span><span class="boring">           sender.send(response).await.expect("The channel needs to be open.");
</span><span class="boring">       }));
</span><span class="boring">   });
</span><span class="boring">
</span><span class="boring">   // The main loop executes the asynchronous block
</span><span class="boring">   glib::spawn_future_local(async move {
</span><span class="boring">       while let Ok(response) = receiver.recv().await {
</span><span class="boring">           if let Ok(response) = response {
</span><span class="boring">               println!("Status: {}", response.status());
</span><span class="boring">           } else {
</span><span class="boring">               println!("Could not make a `GET` request.");
</span><span class="boring">           }
</span><span class="boring">       }
</span><span class="boring">   });
</span><span class="boring">   // ANCHOR_END: callback
</span><span class="boring">
</span><span class="boring">   // Create a window
</span><span class="boring">   let window = ApplicationWindow::builder()
</span><span class="boring">       .application(app)
</span><span class="boring">       .title("My GTK App")
</span><span class="boring">       .child(&amp;button)
</span><span class="boring">       .build();
</span><span class="boring">
</span><span class="boring">   // Present window
</span><span class="boring">   window.present();
</span><span class="boring">}</span></code></pre>
<p>不幸的是，它无法编译。 和往常一样，Rust 的错误信息非常有用。</p>
<pre><code>cannot call non-const fn `tokio::runtime::Runtime::new` in statics
calls in statics are limited to constant functions, tuple structs and tuple variants
consider wrapping this expression in `Lazy::new(|| ...)` from the `once_cell` crate
</code></pre>
<p>我们可以直接遵循建议，但标准库也提供了相应的解决方案。 使用  <a href="https://doc.rust-lang.org/stable/std/sync/struct.OnceLock.html"><code>std::sync::OnceLock</code></a> 时，我们可以使用常函数 <code>OnceLock::new()</code> 初始化静态变量，并在函数 <code>runtime</code> 首次调用时初始化。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/main_event_loop/9/main.rs">listings/main_event_loop/9/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::sync::OnceLock;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">use tokio::runtime::Runtime;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop9";
</span><span class="boring">
</span>fn runtime() -&gt; &amp;'static Runtime {
    static RUNTIME: OnceLock&lt;Runtime&gt; = OnceLock::new();
    RUNTIME.get_or_init(|| {
        Runtime::new().expect("Setting up tokio runtime needs to succeed.")
    })
}
<span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    let (sender, receiver) = async_channel::bounded(1);
</span><span class="boring">    // Connect to "clicked" signal of `button`
</span><span class="boring">    button.connect_clicked(move |_| {
</span><span class="boring">        runtime().spawn(clone!(
</span><span class="boring">            #[strong]
</span><span class="boring">            sender,
</span><span class="boring">            async move {
</span><span class="boring">                let response = reqwest::get("https://www.gtk-rs.org").await;
</span><span class="boring">                sender
</span><span class="boring">                    .send(response)
</span><span class="boring">                    .await
</span><span class="boring">                    .expect("The channel needs to be open.");
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // The main loop executes the asynchronous block
</span><span class="boring">    glib::spawn_future_local(async move {
</span><span class="boring">        while let Ok(response) = receiver.recv().await {
</span><span class="boring">            if let Ok(response) = response {
</span><span class="boring">                println!("Status: {}", response.status());
</span><span class="boring">            } else {
</span><span class="boring">                println!("Could not make a `GET` request.");
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>在按钮回调中，我们现在可以使用 <code>tokio</code> 而不是 <code>glib</code> 来生成 <code>reqwest</code> <code>async</code> 代码块。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/main_event_loop/9/main.rs">listings/main_event_loop/9/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::sync::OnceLock;
</span><span class="boring">
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">use tokio::runtime::Runtime;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.MainEventLoop9";
</span><span class="boring">
</span><span class="boring">fn runtime() -&gt; &amp;'static Runtime {
</span><span class="boring">    static RUNTIME: OnceLock&lt;Runtime&gt; = OnceLock::new();
</span><span class="boring">    RUNTIME.get_or_init(|| {
</span><span class="boring">        Runtime::new().expect("Setting up tokio runtime needs to succeed.")
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a button
</span><span class="boring">    let button = Button::builder()
</span><span class="boring">        .label("Press me!")
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    let (sender, receiver) = async_channel::bounded(1);
    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |_| {
        runtime().spawn(clone!(
            #[strong]
            sender,
            async move {
                let response = reqwest::get("https://www.gtk-rs.org").await;
                sender
                    .send(response)
                    .await
                    .expect("The channel needs to be open.");
            }
        ));
    });

    // The main loop executes the asynchronous block
    glib::spawn_future_local(async move {
        while let Ok(response) = receiver.recv().await {
            if let Ok(response) = response {
                println!("Status: {}", response.status());
            } else {
                println!("Could not make a `GET` request.");
            }
        }
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;button)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>如果我们现在按下按钮，就会在控制台中看到以下信息：</p>
<pre><code>Status: 200 OK
</code></pre>
<p>在接下来的章节中，我们将不再需要 <code>tokio</code>、<code>reqwest</code> 或 <code>ashpd</code>，因此让我们再次执行删除操作：</p>
<pre><code>cargo remove tokio reqwest ashpd
</code></pre>
<p>如何确定能否在 <code>glib</code> 主循环中生成<code>async</code> 任务？当调用的函数来自以下库时，<code>glib</code> 应该能够生成任务：</p>
<ul>
<li>来自 <code>glib</code> 生态系统，</li>
<li>不依赖运行时，只依赖 <code>futures</code> 系列 crate (<code>futures-io</code>, <code>futures-core</code> 等等),</li>
<li>依赖于 <code>async-std</code> 或 <code>smol</code> 运行时，或</li>
<li>具有 cargo features 依赖于 <code>async-std</code>/<code>smol</code> 而不是 <code>tokio</code>.</li>
</ul>
<h2 id="结论"><a class="header" href="#结论">结论</a></h2>
<p>您不希望阻塞主线程足够长的时间，以至于用户察觉不到。 但是，什么时候应该执行异步任务，而不是在单独的线程中执行任务呢？ 让我们再来看看不同的情况。</p>
<p>如果任务将时间花在计算上，而不是等待网络响应，那么它就是计算密集型(<a href="https://en.wikipedia.org/wiki/CPU-bound">CPU-bound</a>). 这意味着你必须在一个单独的线程中运行任务，并让它通过一个通道发送结果。</p>
<p>如果您的任务是IO密集型(<a href="https://en.wikipedia.org/wiki/I/O_bound">IO bound</a>), 那么答案取决于您可以使用的 crate 和需要完成的工作类型。</p>
<ul>
<li>使用 <code>glib</code>、<code>smol</code>、<code>async-std</code> 或 <code>futures</code> trait 系列 crates 函数的轻量级 I/O 工作可以在主循环中启动。 这样，通常就能避免通过通道进行同步。</li>
<li>在独立线程/异步执行器中运行繁重的 I/O 工作仍可避免主循环饱和。 如果您不确定，建议进行基准测试。</li>
</ul>
<p>如果工作的最佳 crate 依赖于 <code>tokio</code>，则必须使用 tokio 运行时生成它，并通过通道进行通信。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设置settings"><a class="header" href="#设置settings">设置(Settings)</a></h1>
<p>我们现在已经学会了多种处理状态的方法。 但是，每次我们关闭应用程序时，它都消失了。 让我们学习如何通过在 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Settings.html"><code>gio::Settings</code></a> 中存储 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Switch.html"><code>Switch</code></a> 的状态来使用它。</p>
<p>一开始，我们必须创建一个<code>GSchema</code> xml 文件，以描述我们的应用程序计划在设置中存储的数据类型。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/settings/1/org.gtk_rs.Settings1.gschema.xml">listings/settings/1/org.gtk_rs.Settings1.gschema.xml</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;schemalist&gt;
  &lt;schema id="org.gtk_rs.Settings1" path="/org/gtk_rs/Settings1/"&gt;
    &lt;key name="is-switch-enabled" type="b"&gt;
      &lt;default&gt;false&lt;/default&gt;
      &lt;summary&gt;Default switch state&lt;/summary&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
</code></pre>
<p>让我们一步一步来。 这个<code>id</code>与我们在创建应用程序时使用的应用程序 ID 相同。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/settings/1/main.rs">listings/settings/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Align, Application, ApplicationWindow, Switch};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Settings1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span>    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();
<span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Initialize settings
</span><span class="boring">    let settings = Settings::new(APP_ID);
</span><span class="boring">
</span><span class="boring">    // Get the last switch state from the settings
</span><span class="boring">    let is_switch_enabled = settings.boolean("is-switch-enabled");
</span><span class="boring">
</span><span class="boring">    // Create a switch
</span><span class="boring">    let switch = Switch::builder()
</span><span class="boring">        .margin_top(48)
</span><span class="boring">        .margin_bottom(48)
</span><span class="boring">        .margin_start(48)
</span><span class="boring">        .margin_end(48)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .state(is_switch_enabled)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    switch.connect_state_set(move |_, is_enabled| {
</span><span class="boring">        // Save changed switch state in the settings
</span><span class="boring">        settings
</span><span class="boring">            .set_boolean("is-switch-enabled", is_enabled)
</span><span class="boring">            .expect("Could not set setting.");
</span><span class="boring">        // Allow to invoke other event handlers
</span><span class="boring">        glib::Propagation::Proceed
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;switch)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p><code>path</code> 必须以正斜杠字符 （'/'） 开头和结尾，并且不能包含两个连续的斜杠字符。 创建  <code>path</code> 时，我们建议使用<code>id</code>，将 '.' 替换为 '/'，并在开头和结尾添加 '/'。</p>
<p>我们只想存储一个<code>name</code>为 "is-switch-enabled" 的键。 这是一个布尔值，因此其类型为 "b"（其他选项请参见  <a href="https://docs.gtk.org/glib/gvariant-format-strings.html">GVariant Format Strings</a>）。 我们还将其默认值设为 <code>false</code>（完整语法请参见  <a href="https://docs.gtk.org/glib/gvariant-text-format.html">GVariant Text Format</a>）。 最后，我们添加一个摘要。</p>
<p>现在，我们需要复制并编译 schema.</p>
<blockquote>
<p>在 Linux 或 macOS 机器上执行以下命令即可安装 schema：</p>
<pre><code class="language-bash">mkdir -p $HOME/.local/share/glib-2.0/schemas
cp org.gtk_rs.Settings1.gschema.xml $HOME/.local/share/glib-2.0/schemas/
glib-compile-schemas $HOME/.local/share/glib-2.0/schemas/
</code></pre>
<p>或者在 Windows 上运行：</p>
<pre><code class="language-powershell">mkdir C:/ProgramData/glib-2.0/schemas/
cp org.gtk_rs.Settings1.gschema.xml C:/ProgramData/glib-2.0/schemas/
glib-compile-schemas C:/ProgramData/glib-2.0/schemas/
</code></pre>
</blockquote>
<p>我们通过指定应用程序 ID 来初始化 <code>Settings</code> 对象。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/settings/1/main.rs">listings/settings/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Align, Application, ApplicationWindow, Switch};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Settings1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Initialize settings
    let settings = Settings::new(APP_ID);
<span class="boring">
</span><span class="boring">    // Get the last switch state from the settings
</span><span class="boring">    let is_switch_enabled = settings.boolean("is-switch-enabled");
</span><span class="boring">
</span><span class="boring">    // Create a switch
</span><span class="boring">    let switch = Switch::builder()
</span><span class="boring">        .margin_top(48)
</span><span class="boring">        .margin_bottom(48)
</span><span class="boring">        .margin_start(48)
</span><span class="boring">        .margin_end(48)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .state(is_switch_enabled)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    switch.connect_state_set(move |_, is_enabled| {
</span><span class="boring">        // Save changed switch state in the settings
</span><span class="boring">        settings
</span><span class="boring">            .set_boolean("is-switch-enabled", is_enabled)
</span><span class="boring">            .expect("Could not set setting.");
</span><span class="boring">        // Allow to invoke other event handlers
</span><span class="boring">        glib::Propagation::Proceed
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;switch)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>然后我们获取设置密钥，并在创建 <code>Switch</code> 时使用它。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/settings/1/main.rs">listings/settings/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Align, Application, ApplicationWindow, Switch};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Settings1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Initialize settings
</span><span class="boring">    let settings = Settings::new(APP_ID);
</span><span class="boring">
</span>    // Get the last switch state from the settings
    let is_switch_enabled = settings.boolean("is-switch-enabled");

    // Create a switch
    let switch = Switch::builder()
        .margin_top(48)
        .margin_bottom(48)
        .margin_start(48)
        .margin_end(48)
        .valign(Align::Center)
        .halign(Align::Center)
        .state(is_switch_enabled)
        .build();
<span class="boring">
</span><span class="boring">    switch.connect_state_set(move |_, is_enabled| {
</span><span class="boring">        // Save changed switch state in the settings
</span><span class="boring">        settings
</span><span class="boring">            .set_boolean("is-switch-enabled", is_enabled)
</span><span class="boring">            .expect("Could not set setting.");
</span><span class="boring">        // Allow to invoke other event handlers
</span><span class="boring">        glib::Propagation::Proceed
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;switch)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>最后，我们保证，只要点击开关，开关状态就会保存在设置中。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/settings/1/main.rs">listings/settings/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Align, Application, ApplicationWindow, Switch};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Settings1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Initialize settings
</span><span class="boring">    let settings = Settings::new(APP_ID);
</span><span class="boring">
</span><span class="boring">    // Get the last switch state from the settings
</span><span class="boring">    let is_switch_enabled = settings.boolean("is-switch-enabled");
</span><span class="boring">
</span><span class="boring">    // Create a switch
</span><span class="boring">    let switch = Switch::builder()
</span><span class="boring">        .margin_top(48)
</span><span class="boring">        .margin_bottom(48)
</span><span class="boring">        .margin_start(48)
</span><span class="boring">        .margin_end(48)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .state(is_switch_enabled)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    switch.connect_state_set(move |_, is_enabled| {
        // Save changed switch state in the settings
        settings
            .set_boolean("is-switch-enabled", is_enabled)
            .expect("Could not set setting.");
        // Allow to invoke other event handlers
        glib::Propagation::Proceed
    });
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;switch)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/settings_1.webm" type="video/webm">
  <p>A video which shows that the app can now store the app state</p>
 </video>
</div>
现在，即使关闭应用程序，`Switch`也会保留其状态。 但我们可以做得更好。 开关有一个属性 "active"，而  `Settings` 允许我们将属性与特定设置绑定。 因此，我们就来做这件事。
<p>我们可以删除初始化 <code>Switch</code> 之前的 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/prelude/trait.SettingsExt.html#tymethod.boolean"><code>boolean</code></a> 调用以及 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Switch.html#method.connect_state_set"><code>connect_state_set</code></a> 调用。 然后，我们通过指定键、对象和属性名称将设置绑定到属性。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/settings/2/main.rs">listings/settings/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Align, Application, ApplicationWindow, Switch};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Settings2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Initialize settings
</span><span class="boring">    let settings = Settings::new(APP_ID);
</span><span class="boring">
</span><span class="boring">    // Create a switch
</span><span class="boring">    let switch = Switch::builder()
</span><span class="boring">        .margin_top(48)
</span><span class="boring">        .margin_bottom(48)
</span><span class="boring">        .margin_start(48)
</span><span class="boring">        .margin_end(48)
</span><span class="boring">        .valign(Align::Center)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .build();
</span><span class="boring">
</span>    settings
        .bind("is-switch-enabled", &amp;switch, "active")
        .build();
<span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;switch)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>只要有一个属性与一个设置很好地对应，你可能就会想把它绑定到设置上。 在其他情况下，通过 getter 和 setter 方法与设置交互往往是正确的选择。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="保存窗口状态"><a class="header" href="#保存窗口状态">保存窗口状态</a></h1>
<p>很多时候，我们希望窗口状态在会话之间持续存在。 如果用户调整窗口大小或将其最大化，他们可能会希望下次打开应用程序时，窗口仍保持同样的状态。 GTK 并没有提供这种功能，但幸运的是，手动实现它并不难。 我们基本上需要两个整数(高度 <code>height</code> 和 宽度 <code>width</code>) 和一个布尔值（<code>is_maximized</code>）来持久化。 我们已经知道如何通过使用  <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Settings.html"><code>gio::Settings</code></a> 来做到这一点。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/saving_window_state/1/org.gtk_rs.SavingWindowState1.gschema.xml">listings/saving_window_state/1/org.gtk_rs.SavingWindowState1.gschema.xml</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;schemalist&gt;
  &lt;schema id="org.gtk_rs.SavingWindowState1" path="/org/gtk_rs/SavingWindowState1/"&gt;
    &lt;key name="window-width" type="i"&gt;
      &lt;default&gt;-1&lt;/default&gt;
      &lt;summary&gt;Default window width&lt;/summary&gt;
    &lt;/key&gt;
    &lt;key name="window-height" type="i"&gt;
      &lt;default&gt;-1&lt;/default&gt;
      &lt;summary&gt;Default window height&lt;/summary&gt;
    &lt;/key&gt;
    &lt;key name="is-maximized" type="b"&gt;
      &lt;default&gt;false&lt;/default&gt;
      &lt;summary&gt;Default window maximized behaviour&lt;/summary&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
</code></pre>
<p>由于我们不关心中间状态，因此只在构建窗口时加载窗口状态，并在关闭窗口时保存窗口状态。 这可以通过创建自定义窗口来实现。 首先，我们创建一个窗口，并添加用于访问设置和窗口状态的便捷方法。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/saving_window_state/1/custom_window/mod.rs">listings/saving_window_state/1/custom_window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application};
</span><span class="boring">
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span>glib::wrapper! {
    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
}

impl Window {
    pub fn new(app: &amp;Application) -&gt; Self {
        // Create new window
        Object::builder().property("application", app).build()
    }

    fn setup_settings(&amp;self) {
        let settings = Settings::new(APP_ID);
        self.imp()
            .settings
            .set(settings)
            .expect("`settings` should not be set before calling `setup_settings`.");
    }

    fn settings(&amp;self) -&gt; &amp;Settings {
        self.imp()
            .settings
            .get()
            .expect("`settings` should be set in `setup_settings`.")
    }

    pub fn save_window_size(&amp;self) -&gt; Result&lt;(), glib::BoolError&gt; {
        // Get the size of the window
        let size = self.default_size();

        // Set the window state in `settings`
        self.settings().set_int("window-width", size.0)?;
        self.settings().set_int("window-height", size.1)?;
        self.settings()
            .set_boolean("is-maximized", self.is_maximized())?;

        Ok(())
    }

    fn load_window_size(&amp;self) {
        // Get the window state from `settings`
        let width = self.settings().int("window-width");
        let height = self.settings().int("window-height");
        let is_maximized = self.settings().boolean("is-maximized");

        // Set the size of the window
        self.set_default_size(width, height);

        // If the window was maximized when it was closed, maximize it again
        if is_maximized {
            self.maximize();
        }
    }
}</code></pre>
<blockquote>
<p>我们通过将 "application" 属性传递给 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/object/struct.Object.html#method.new"><code>glib::Object::new</code></a> 来设置该属性。 您甚至可以用这种方法设置多个属性。 在创建新的 GObject 时，这比手动调用 setter 方法要好得多。</p>
</blockquote>
<p>实现的结构包含 <code>settings</code>. 您可以看到，我们将 <code>settings</code> 嵌入到  <a href="https://doc.rust-lang.org/std/cell/struct.OnceCell.html"><code>std::cell::OnceCell</code></a> 中。 当你知道只需初始化一次值时，这是 <code>RefCell&lt;Option&lt;T&gt;&gt;</code> 的一个很好的替代方法。 我们还重写了 <code>constructed</code> 和 <code>close_request</code> 方法，通过它们来加载或保存窗口状态。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/saving_window_state/1/custom_window/imp.rs">listings/saving_window_state/1/custom_window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::Settings;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, ApplicationWindow};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span>#[derive(Default)]
pub struct Window {
    pub settings: OnceCell&lt;Settings&gt;,
}

#[glib::object_subclass]
impl ObjectSubclass for Window {
    const NAME: &amp;'static str = "MyGtkAppWindow";
    type Type = super::Window;
    type ParentType = ApplicationWindow;
}
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        self.parent_constructed();
        // Load latest window state
        let obj = self.obj();
        obj.setup_settings();
        obj.load_window_size();
    }
}
impl WidgetImpl for Window {}
impl WindowImpl for Window {
    // Save window state right before the window will be closed
    fn close_request(&amp;self) -&gt; glib::Propagation {
        // Save window size
        self.obj()
            .save_window_size()
            .expect("Failed to save window state");
        // Allow to invoke other event handlers
        glib::Propagation::Proceed
    }
}
impl ApplicationWindowImpl for Window {}</code></pre>
<p>就是这样！ 现在，我们的窗口可以在应用程序会话之间保持状态。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="列表控件"><a class="header" href="#列表控件">列表控件</a></h1>
<p>有时，您想以某种排列方式显示元素列表。<a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ListBox.html"><code>gtk::ListBox</code></a> 和 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.FlowBox.html"><code>gtk::FlowBox</code></a> 是两个容器部件，可以让您做到这一点。 <code>ListBox</code> 是垂直列表，而 <code>FlowBox</code> 是网格。</p>
<p>让我们通过在 <code>ListBox</code> 中添加标签来探索这一概念。 标签将显示从 0 到 100 的整数。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/list_widgets/1/main.rs">listings/list_widgets/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    glib, Application, ApplicationWindow, Label, ListBox, PolicyType, ScrolledWindow,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create a `ListBox` and add labels with integers from 0 to 100
    let list_box = ListBox::new();
    for number in 0..=100 {
        let label = Label::new(Some(&amp;number.to_string()));
        list_box.append(&amp;label);
    }
<span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>我们不能同时显示这么多部件。 因此，我们将 <code>ListBox</code> 添加到 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ScrolledWindow.html"><code>gtk::ScrolledWindow</code></a> 中。 现在我们可以滚动浏览我们的元素了。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/list_widgets/1/main.rs">listings/list_widgets/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    glib, Application, ApplicationWindow, Label, ListBox, PolicyType, ScrolledWindow,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `ListBox` and add labels with integers from 0 to 100
</span><span class="boring">    let list_box = ListBox::new();
</span><span class="boring">    for number in 0..=100 {
</span><span class="boring">        let label = Label::new(Some(&amp;number.to_string()));
</span><span class="boring">        list_box.append(&amp;label);
</span><span class="boring">    }
</span><span class="boring">
</span>    let scrolled_window = ScrolledWindow::builder()
        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
        .min_content_width(360)
        .child(&amp;list_box)
        .build();

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .default_width(600)
        .default_height(300)
        .child(&amp;scrolled_window)
        .build();

    // Present window
    window.present();
<span class="boring">}</span></code></pre>
<div style="text-align:center"><img src="img/lists_list_box.png" alt="Window with a list of integers"/></div>
<h2 id="views"><a class="header" href="#views">Views</a></h2>
<p>这很简单。 不过，目前我们为每个元素创建一个小部件。 由于每个窗口小部件都会占用一些资源，因此很多窗口小部件会导致用户界面反应变慢。 根据部件类型的不同，即使有成千上万个元素也可能不是问题。 但是，我们怎么可能处理社交媒体时间线中无数的帖子呢？</p>
<p>我们改用可扩展列表！</p>
<ul>
<li>**模型(model)**保存我们的数据，对其进行过滤并描述其顺序。</li>
<li>**列表项工厂(list item factory)**定义了数据如何转换为控件。</li>
<li>**视图(view)**指定控件的排列方式。</li>
</ul>
<p>使这一概念具有可扩展性的是，GTK 只需创建略多于我们目前所能看到的控件。 当我们滚动浏览元素时，不可见的控件将被重复使用。 下图演示了实际操作过程。</p>
<div style="text-align:center"><img src="img/scalable_lists_concept.png" alt="Diagram showing how list widgets are being recycled"/></div>
<p>100000 个元素是 <code>ListBox</code> 难以承受的，因此让我们用它来演示可扩展列表。</p>
<p>我们首先定义并填充模型。 该模型是 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.ListStore.html"><code>gio::ListStore</code></a> 的一个实例。 这里的主要限制是 <code>gio::ListStore</code> 只接受 GObject. 因此，让我们创建一个用数字初始化的自定义 GObject <code>IntegerObject</code>.</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/list_widgets/2/integer_object/mod.rs">listings/list_widgets/2/integer_object/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">
</span>glib::wrapper! {
    pub struct IntegerObject(ObjectSubclass&lt;imp::IntegerObject&gt;);
}

impl IntegerObject {
    pub fn new(number: i32) -&gt; Self {
        Object::builder().property("number", number).build()
    }
}
<span class="boring"></span></code></pre>
<p><code>number</code> 代表 <code>IntegerObject</code> 的内部状态。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/list_widgets/2/integer_object/imp.rs">listings/list_widgets/2/integer_object/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">use glib::Properties;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span>// Object holding the state
#[derive(Properties, Default)]
#[properties(wrapper_type = super::IntegerObject)]
pub struct IntegerObject {
    #[property(get, set)]
    number: Cell&lt;i32&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for IntegerObject {
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppIntegerObject";
</span><span class="boring">    type Type = super::IntegerObject;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">#[glib::derived_properties]
</span><span class="boring">impl ObjectImpl for IntegerObject {}
</span><span class="boring"></span></code></pre>
<p>现在我们用 0 到 100000 的整数填充模型。 请注意，模型只处理数据。 这里没有提及标签或任何其他控件。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/list_widgets/2/main.rs">listings/list_widgets/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, Label, ListView, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();

    // Create new model
    let model = gio::ListStore::new::&lt;IntegerObject&gt;();

    // Add the vector to the model
    model.extend_from_slice(&amp;vector);
<span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    factory.connect_bind(move |_, list_item| {
</span><span class="boring">        // Get `IntegerObject` from `ListItem`
</span><span class="boring">        let integer_object = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .item()
</span><span class="boring">            .and_downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The item has to be an `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Get `Label` from `ListItem`
</span><span class="boring">        let label = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .child()
</span><span class="boring">            .and_downcast::&lt;Label&gt;()
</span><span class="boring">            .expect("The child has to be a `Label`.");
</span><span class="boring">
</span><span class="boring">        // Set "label" to "number"
</span><span class="boring">        label.set_label(&amp;integer_object.number().to_string());
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p><code>ListItemFactory</code> 负责处理控件及其与模型的关系。 在这里，我们使用了  <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.SignalListItemFactory.html"><code>SignalListItemFactory</code></a> ，它可以为 <code>ListItem</code> 生命周期中的每一个相关步骤发出一个信号。 当需要创建新的部件时，"setup"（设置）信号就会发出。 我们连接到该信号，为每个请求的部件创建一个标签。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/list_widgets/2/main.rs">listings/list_widgets/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, Label, ListView, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new::&lt;IntegerObject&gt;();
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model
</span><span class="boring">    model.extend_from_slice(&amp;vector);
</span><span class="boring">
</span>    let factory = SignalListItemFactory::new();
    factory.connect_setup(move |_, list_item| {
        let label = Label::new(None);
        list_item
            .downcast_ref::&lt;ListItem&gt;()
            .expect("Needs to be ListItem")
            .set_child(Some(&amp;label));
    });
<span class="boring">
</span><span class="boring">    factory.connect_bind(move |_, list_item| {
</span><span class="boring">        // Get `IntegerObject` from `ListItem`
</span><span class="boring">        let integer_object = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .item()
</span><span class="boring">            .and_downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The item has to be an `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Get `Label` from `ListItem`
</span><span class="boring">        let label = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .child()
</span><span class="boring">            .and_downcast::&lt;Label&gt;()
</span><span class="boring">            .expect("The child has to be a `Label`.");
</span><span class="boring">
</span><span class="boring">        // Set "label" to "number"
</span><span class="boring">        label.set_label(&amp;integer_object.number().to_string());
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>在“绑定”步骤中，我们将模型中的数据绑定到各个列表项。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/list_widgets/2/main.rs">listings/list_widgets/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, Label, ListView, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new::&lt;IntegerObject&gt;();
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model
</span><span class="boring">    model.extend_from_slice(&amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span>    factory.connect_bind(move |_, list_item| {
        // Get `IntegerObject` from `ListItem`
        let integer_object = list_item
            .downcast_ref::&lt;ListItem&gt;()
            .expect("Needs to be ListItem")
            .item()
            .and_downcast::&lt;IntegerObject&gt;()
            .expect("The item has to be an `IntegerObject`.");

        // Get `Label` from `ListItem`
        let label = list_item
            .downcast_ref::&lt;ListItem&gt;()
            .expect("Needs to be ListItem")
            .child()
            .and_downcast::&lt;Label&gt;()
            .expect("The child has to be a `Label`.");

        // Set "label" to "number"
        label.set_label(&amp;integer_object.number().to_string());
    });
<span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>我们只希望单个项目可选，因此选择了  <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.SingleSelection.html"><code>SingleSelection</code></a>。 其他选项是多选（<a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.MultiSelection.html"><code>MultiSelection</code></a>）和不选（<a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.NoSelection.html"><code>NoSelection</code></a>）。然后，我们将模型和工厂传递给  <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ListView.html"><code>ListView</code></a>。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/list_widgets/2/main.rs">listings/list_widgets/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, Label, ListView, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new::&lt;IntegerObject&gt;();
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model
</span><span class="boring">    model.extend_from_slice(&amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    factory.connect_bind(move |_, list_item| {
</span><span class="boring">        // Get `IntegerObject` from `ListItem`
</span><span class="boring">        let integer_object = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .item()
</span><span class="boring">            .and_downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The item has to be an `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Get `Label` from `ListItem`
</span><span class="boring">        let label = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .child()
</span><span class="boring">            .and_downcast::&lt;Label&gt;()
</span><span class="boring">            .expect("The child has to be a `Label`.");
</span><span class="boring">
</span><span class="boring">        // Set "label" to "number"
</span><span class="boring">        label.set_label(&amp;integer_object.number().to_string());
</span><span class="boring">    });
</span><span class="boring">
</span>    let selection_model = SingleSelection::new(Some(model));
    let list_view = ListView::new(Some(selection_model), Some(factory));
<span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>每个 <code>ListView</code> 都必须是 <code>ScrolledWindow</code> 的直接子窗口，因此我们要将其添加到 <code>ScrolledWindow</code> 中。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/list_widgets/2/main.rs">listings/list_widgets/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, Label, ListView, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new::&lt;IntegerObject&gt;();
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model
</span><span class="boring">    model.extend_from_slice(&amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    factory.connect_bind(move |_, list_item| {
</span><span class="boring">        // Get `IntegerObject` from `ListItem`
</span><span class="boring">        let integer_object = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .item()
</span><span class="boring">            .and_downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The item has to be an `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Get `Label` from `ListItem`
</span><span class="boring">        let label = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .child()
</span><span class="boring">            .and_downcast::&lt;Label&gt;()
</span><span class="boring">            .expect("The child has to be a `Label`.");
</span><span class="boring">
</span><span class="boring">        // Set "label" to "number"
</span><span class="boring">        label.set_label(&amp;integer_object.number().to_string());
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span>    let scrolled_window = ScrolledWindow::builder()
        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
        .min_content_width(360)
        .child(&amp;list_view)
        .build();

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .default_width(600)
        .default_height(300)
        .child(&amp;scrolled_window)
        .build();

    // Present window
    window.present();
<span class="boring">}</span></code></pre>
<p>现在，我们可以轻松地滚动浏览一长串整数。</p>
<div style="text-align:center"><img src="img/lists_list_view_1.png" alt="Window with a list of 100 000 integers"/></div>
<p>让我们看看还能做些什么。 我们可能想在每次激活行时增加数字。 为此，我们首先要为 <code>IntegerObject</code> 添加 <code>increase_number</code> 方法。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/list_widgets/3/integer_object/mod.rs">listings/list_widgets/3/integer_object/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct IntegerObject(ObjectSubclass&lt;imp::IntegerObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span>impl IntegerObject {
    pub fn new(number: i32) -&gt; Self {
        Object::builder().property("number", number).build()
    }

    pub fn increase_number(self) {
        self.set_number(self.number() + 1);
    }
}</code></pre>
<p>为了与 <code>ListView</code> 交互，我们要连接到它的 "激活(activate)" 信号。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/list_widgets/3/main.rs">listings/list_widgets/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, Label, ListView, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new::&lt;IntegerObject&gt;();
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model
</span><span class="boring">    model.extend_from_slice(&amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    factory.connect_bind(move |_, list_item| {
</span><span class="boring">        // Get `IntegerObject` from `ListItem`
</span><span class="boring">        let integer_object = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .item()
</span><span class="boring">            .and_downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The item has to be an `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Get `Label` from `ListItem`
</span><span class="boring">        let label = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .child()
</span><span class="boring">            .and_downcast::&lt;Label&gt;()
</span><span class="boring">            .expect("The child has to be a `Label`.");
</span><span class="boring">
</span><span class="boring">        // Bind "label" to "number"
</span><span class="boring">        integer_object
</span><span class="boring">            .bind_property("number", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span>    list_view.connect_activate(move |list_view, position| {
        // Get `IntegerObject` from model
        let model = list_view.model().expect("The model has to exist.");
        let integer_object = model
            .item(position)
            .and_downcast::&lt;IntegerObject&gt;()
            .expect("The item has to be an `IntegerObject`.");

        // Increase "number" of `IntegerObject`
        integer_object.increase_number();
    });
<span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>现在，每当我们激活一个元素，例如双击该元素，模型中 <code>IntegerObject</code> 对应的 "数字(number)" 属性就会增加 1. 然而，<code>IntegerObject</code> 被修改后，对应的 <code>Label</code> 并不会立即改变。 一种简单的方法是在 <code>SignalListItemFactory</code> 的 "绑定(bind)"步骤中绑定属性。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/list_widgets/3/main.rs">listings/list_widgets/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, Label, ListView, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, SingleSelection,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new::&lt;IntegerObject&gt;();
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model
</span><span class="boring">    model.extend_from_slice(&amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem")
</span><span class="boring">            .set_child(Some(&amp;label));
</span><span class="boring">    });
</span><span class="boring">
</span>    factory.connect_bind(move |_, list_item| {
        // Get `IntegerObject` from `ListItem`
        let integer_object = list_item
            .downcast_ref::&lt;ListItem&gt;()
            .expect("Needs to be ListItem")
            .item()
            .and_downcast::&lt;IntegerObject&gt;()
            .expect("The item has to be an `IntegerObject`.");

        // Get `Label` from `ListItem`
        let label = list_item
            .downcast_ref::&lt;ListItem&gt;()
            .expect("Needs to be ListItem")
            .child()
            .and_downcast::&lt;Label&gt;()
            .expect("The child has to be a `Label`.");

        // Bind "label" to "number"
        integer_object
            .bind_property("number", &amp;label, "label")
            .sync_create()
            .build();
    });
<span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span><span class="boring">    list_view.connect_activate(move |list_view, position| {
</span><span class="boring">        // Get `IntegerObject` from model
</span><span class="boring">        let model = list_view.model().expect("The model has to exist.");
</span><span class="boring">        let integer_object = model
</span><span class="boring">            .item(position)
</span><span class="boring">            .and_downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The item has to be an `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Increase "number" of `IntegerObject`
</span><span class="boring">        integer_object.increase_number();
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>乍一看，这似乎可行。 但是，当你滚动并激活几个列表元素时，你会发现有时多个数字会发生变化，即使你只激活了一个。 这与视图的内部工作方式有关。 并不是每个模型项都属于一个部件，而是随着视图的滚动，部件会被循环使用。 这也意味着，在我们的例子中，多个数字将绑定到同一个部件上。</p>
<h3 id="表达式expressions"><a class="header" href="#表达式expressions">表达式(Expressions)</a></h3>
<p>类似这样的情况非常常见，因此 GTK 提供了一种属性绑定的替代方法：<a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Expression.html">表达式(Expression)</a>。 作为第一步，它允许我们删除 "绑定(bind)" 步骤。 让我们看看 "设置(setup)" 步骤现在是如何工作的。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/list_widgets/4/main.rs">listings/list_widgets/4/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, Label, ListView, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, SingleSelection, Widget,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets4";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new::&lt;IntegerObject&gt;();
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model
</span><span class="boring">    model.extend_from_slice(&amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span>    factory.connect_setup(move |_, list_item| {
        // Create label
        let label = Label::new(None);
        let list_item = list_item
            .downcast_ref::&lt;ListItem&gt;()
            .expect("Needs to be ListItem");
        list_item.set_child(Some(&amp;label));

        // Bind `list_item-&gt;item-&gt;number` to `label-&gt;label`
        list_item
            .property_expression("item")
            .chain_property::&lt;IntegerObject&gt;("number")
            .bind(&amp;label, "label", Widget::NONE);
    });
<span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span><span class="boring">    list_view.connect_activate(move |list_view, position| {
</span><span class="boring">        // Get `IntegerObject` from model
</span><span class="boring">        let model = list_view.model().expect("The model has to exist.");
</span><span class="boring">        let integer_object = model
</span><span class="boring">            .item(position)
</span><span class="boring">            .and_downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The item has to be an `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Increase "number" of `IntegerObject`
</span><span class="boring">        integer_object.increase_number();
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>表达式提供了一种描述值引用的方法。 有趣的是，这些引用可以是几步之外的。 这样，在上面的代码段中，我们就可以将 <code>list_item</code> 的属性 "item" 的 "number" 属性与标签的 "label" 属性绑定。</p>
<p>值得注意的是，在 "设置(setup)" 阶段，我们无法知道哪个列表项属于哪个标签，因为当我们滚动列表时，这一点会发生变化。 在这里，表达式的另一个功能就显现出来了。 表达式允许我们描述对象或属性之间的关系，而这些关系可能还不存在。 我们只需告诉它，只要属于它的数字发生变化，就必须更改标签。 这样，我们也不会遇到多个标签绑定到同一个数字上的问题。 现在，当我们激活一个标签时，只有相应的数字会发生可见的变化。</p>
<p>让我们进一步扩展应用程序。 例如，我们可以过滤我们的模型，使其只允许偶数。 为此，我们可以将其与 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.CustomFilter.html"><code>gtk::CustomFilter</code></a> 一起传递给  <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.FilterListModel.html"><code>gtk::FilterListModel</code></a> .</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/list_widgets/5/main.rs">listings/list_widgets/5/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, CustomFilter, CustomSorter,
</span><span class="boring">    FilterChange, FilterListModel, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection, SortListModel, SorterChange, Widget,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets5";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new::&lt;IntegerObject&gt;();
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model
</span><span class="boring">    model.extend_from_slice(&amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        // Create label
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        let list_item = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem");
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">
</span><span class="boring">        // Bind `list_item-&gt;item-&gt;number` to `label-&gt;label`
</span><span class="boring">        list_item
</span><span class="boring">            .property_expression("item")
</span><span class="boring">            .chain_property::&lt;IntegerObject&gt;("number")
</span><span class="boring">            .bind(&amp;label, "label", Widget::NONE);
</span><span class="boring">    });
</span><span class="boring">
</span>    let filter = CustomFilter::new(move |obj| {
        // Get `IntegerObject` from `glib::Object`
        let integer_object = obj
            .downcast_ref::&lt;IntegerObject&gt;()
            .expect("The object needs to be of type `IntegerObject`.");

        // Only allow even numbers
        integer_object.number() % 2 == 0
    });
    let filter_model = FilterListModel::new(Some(model), Some(filter.clone()));
<span class="boring">
</span><span class="boring">    let sorter = CustomSorter::new(move |obj1, obj2| {
</span><span class="boring">        // Get `IntegerObject` from `glib::Object`
</span><span class="boring">        let integer_object_1 = obj1
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The object needs to be of type `IntegerObject`.");
</span><span class="boring">        let integer_object_2 = obj2
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The object needs to be of type `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Get property "number" from `IntegerObject`
</span><span class="boring">        let number_1 = integer_object_1.number();
</span><span class="boring">        let number_2 = integer_object_2.number();
</span><span class="boring">
</span><span class="boring">        // Reverse sorting order -&gt; large numbers come first
</span><span class="boring">        number_2.cmp(&amp;number_1).into()
</span><span class="boring">    });
</span><span class="boring">    let sort_model = SortListModel::new(Some(filter_model), Some(sorter.clone()));
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(sort_model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span><span class="boring">    list_view.connect_activate(move |list_view, position| {
</span><span class="boring">        // Get `IntegerObject` from model
</span><span class="boring">        let model = list_view.model().expect("The model has to exist.");
</span><span class="boring">        let integer_object = model
</span><span class="boring">            .item(position)
</span><span class="boring">            .and_downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The item has to be an `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Increase "number" of `IntegerObject`
</span><span class="boring">        integer_object.increase_number();
</span><span class="boring">
</span><span class="boring">        // Notify that the filter and sorter have been changed
</span><span class="boring">        filter.changed(FilterChange::Different);
</span><span class="boring">        sorter.changed(SorterChange::Different);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>此外，我们还可以颠倒模型的顺序。 现在，我们将过滤后的模型与 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.CustomSorter.html"><code>gtk::CustomSorter</code></a> 一起传递给 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.SortListModel.html"><code>gtk::SortListModel</code></a>.</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/list_widgets/5/main.rs">listings/list_widgets/5/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, CustomFilter, CustomSorter,
</span><span class="boring">    FilterChange, FilterListModel, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection, SortListModel, SorterChange, Widget,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets5";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new::&lt;IntegerObject&gt;();
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model
</span><span class="boring">    model.extend_from_slice(&amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        // Create label
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        let list_item = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem");
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">
</span><span class="boring">        // Bind `list_item-&gt;item-&gt;number` to `label-&gt;label`
</span><span class="boring">        list_item
</span><span class="boring">            .property_expression("item")
</span><span class="boring">            .chain_property::&lt;IntegerObject&gt;("number")
</span><span class="boring">            .bind(&amp;label, "label", Widget::NONE);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let filter = CustomFilter::new(move |obj| {
</span><span class="boring">        // Get `IntegerObject` from `glib::Object`
</span><span class="boring">        let integer_object = obj
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The object needs to be of type `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Only allow even numbers
</span><span class="boring">        integer_object.number() % 2 == 0
</span><span class="boring">    });
</span><span class="boring">    let filter_model = FilterListModel::new(Some(model), Some(filter.clone()));
</span><span class="boring">
</span>    let sorter = CustomSorter::new(move |obj1, obj2| {
        // Get `IntegerObject` from `glib::Object`
        let integer_object_1 = obj1
            .downcast_ref::&lt;IntegerObject&gt;()
            .expect("The object needs to be of type `IntegerObject`.");
        let integer_object_2 = obj2
            .downcast_ref::&lt;IntegerObject&gt;()
            .expect("The object needs to be of type `IntegerObject`.");

        // Get property "number" from `IntegerObject`
        let number_1 = integer_object_1.number();
        let number_2 = integer_object_2.number();

        // Reverse sorting order -&gt; large numbers come first
        number_2.cmp(&amp;number_1).into()
    });
    let sort_model = SortListModel::new(Some(filter_model), Some(sorter.clone()));
<span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(sort_model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span><span class="boring">    list_view.connect_activate(move |list_view, position| {
</span><span class="boring">        // Get `IntegerObject` from model
</span><span class="boring">        let model = list_view.model().expect("The model has to exist.");
</span><span class="boring">        let integer_object = model
</span><span class="boring">            .item(position)
</span><span class="boring">            .and_downcast::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The item has to be an `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Increase "number" of `IntegerObject`
</span><span class="boring">        integer_object.increase_number();
</span><span class="boring">
</span><span class="boring">        // Notify that the filter and sorter have been changed
</span><span class="boring">        filter.changed(FilterChange::Different);
</span><span class="boring">        sorter.changed(SorterChange::Different);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>为了确保在修改数字时，我们的过滤器和排序器能得到更新，我们调用了它们的 <code>changed</code> 方法。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/list_widgets/5/main.rs">listings/list_widgets/5/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod integer_object;
</span><span class="boring">
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, ApplicationWindow, CustomFilter, CustomSorter,
</span><span class="boring">    FilterChange, FilterListModel, Label, ListView, PolicyType, ScrolledWindow,
</span><span class="boring">    SignalListItemFactory, SingleSelection, SortListModel, SorterChange, Widget,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">use integer_object::IntegerObject;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets5";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `Vec&lt;IntegerObject&gt;` with numbers from 0 to 100_000
</span><span class="boring">    let vector: Vec&lt;IntegerObject&gt; = (0..=100_000).map(IntegerObject::new).collect();
</span><span class="boring">
</span><span class="boring">    // Create new model
</span><span class="boring">    let model = gio::ListStore::new::&lt;IntegerObject&gt;();
</span><span class="boring">
</span><span class="boring">    // Add the vector to the model
</span><span class="boring">    model.extend_from_slice(&amp;vector);
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        // Create label
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        let list_item = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem");
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">
</span><span class="boring">        // Bind `list_item-&gt;item-&gt;number` to `label-&gt;label`
</span><span class="boring">        list_item
</span><span class="boring">            .property_expression("item")
</span><span class="boring">            .chain_property::&lt;IntegerObject&gt;("number")
</span><span class="boring">            .bind(&amp;label, "label", Widget::NONE);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let filter = CustomFilter::new(move |obj| {
</span><span class="boring">        // Get `IntegerObject` from `glib::Object`
</span><span class="boring">        let integer_object = obj
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The object needs to be of type `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Only allow even numbers
</span><span class="boring">        integer_object.number() % 2 == 0
</span><span class="boring">    });
</span><span class="boring">    let filter_model = FilterListModel::new(Some(model), Some(filter.clone()));
</span><span class="boring">
</span><span class="boring">    let sorter = CustomSorter::new(move |obj1, obj2| {
</span><span class="boring">        // Get `IntegerObject` from `glib::Object`
</span><span class="boring">        let integer_object_1 = obj1
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The object needs to be of type `IntegerObject`.");
</span><span class="boring">        let integer_object_2 = obj2
</span><span class="boring">            .downcast_ref::&lt;IntegerObject&gt;()
</span><span class="boring">            .expect("The object needs to be of type `IntegerObject`.");
</span><span class="boring">
</span><span class="boring">        // Get property "number" from `IntegerObject`
</span><span class="boring">        let number_1 = integer_object_1.number();
</span><span class="boring">        let number_2 = integer_object_2.number();
</span><span class="boring">
</span><span class="boring">        // Reverse sorting order -&gt; large numbers come first
</span><span class="boring">        number_2.cmp(&amp;number_1).into()
</span><span class="boring">    });
</span><span class="boring">    let sort_model = SortListModel::new(Some(filter_model), Some(sorter.clone()));
</span><span class="boring">
</span><span class="boring">    let selection_model = SingleSelection::new(Some(sort_model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span>    list_view.connect_activate(move |list_view, position| {
        // Get `IntegerObject` from model
        let model = list_view.model().expect("The model has to exist.");
        let integer_object = model
            .item(position)
            .and_downcast::&lt;IntegerObject&gt;()
            .expect("The item has to be an `IntegerObject`.");

        // Increase "number" of `IntegerObject`
        integer_object.increase_number();

        // Notify that the filter and sorter have been changed
        filter.changed(FilterChange::Different);
        sorter.changed(SorterChange::Different);
    });
<span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>更改后，应用程序看起来就像这样：</p>
<div style="text-align:center"><img src="img/lists_list_view_2.png" alt="Window with a list of 100 000 integers, starting from 100 000"/></div>
<h3 id="字符串列表"><a class="header" href="#字符串列表">字符串列表</a></h3>
<p>通常情况下，您只想显示一个字符串列表。 但是，如果您需要对显示的数据进行过滤和排序，或者元素太多，无法用 <code>ListBox</code> 显示，您仍然需要使用视图。 GTK 为这种情况提供了一个方便的模型： <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.StringList.html"><code>gtk::StringList</code></a>.</p>
<p>让我们通过一个小例子来看看如何使用这个 API。 过滤器和排序器由工厂控制，所以这里没有什么变化。</p>
<p>首先，我们向模型中添加一系列字符串。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/list_widgets/6/main.rs">listings/list_widgets/6/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::{glib, prelude::*, ListItem};
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, NoSelection, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, StringList, StringObject, Widget,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets6";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create a `StringList` with number from 0 to 100_000
    // `StringList` implements FromIterator&lt;String&gt;
    let model: StringList = (0..=100_000).map(|number| number.to_string()).collect();
<span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span><span class="boring">    factory.connect_setup(move |_, list_item| {
</span><span class="boring">        // Create label
</span><span class="boring">        let label = Label::new(None);
</span><span class="boring">        let list_item = list_item
</span><span class="boring">            .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">            .expect("Needs to be ListItem");
</span><span class="boring">        list_item.set_child(Some(&amp;label));
</span><span class="boring">
</span><span class="boring">        // Bind `list_item-&gt;item-&gt;string` to `label-&gt;label`
</span><span class="boring">        list_item
</span><span class="boring">            .property_expression("item")
</span><span class="boring">            .chain_property::&lt;StringObject&gt;("string")
</span><span class="boring">            .bind(&amp;label, "label", Widget::NONE);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let selection_model = NoSelection::new(Some(model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>请注意，我们可以直接从字符串的迭代器中创建一个 <code>StringList</code>. 这意味着我们不必再为我们的模型创建一个自定义的 GObject.</p>
<p>像往常一样，我们通过表达式将标签与列表项连接起来。 在这里，我们可以使用  <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.StringObject.html"><code>StringObject</code></a>, 它可以通过<a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.StringObject.html#string">属性 "string"</a>显示内容。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/list_widgets/6/main.rs">listings/list_widgets/6/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::{glib, prelude::*, ListItem};
</span><span class="boring">use gtk::{
</span><span class="boring">    Application, ApplicationWindow, Label, ListView, NoSelection, PolicyType,
</span><span class="boring">    ScrolledWindow, SignalListItemFactory, StringList, StringObject, Widget,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.ListWidgets6";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a `StringList` with number from 0 to 100_000
</span><span class="boring">    // `StringList` implements FromIterator&lt;String&gt;
</span><span class="boring">    let model: StringList = (0..=100_000).map(|number| number.to_string()).collect();
</span><span class="boring">
</span><span class="boring">    let factory = SignalListItemFactory::new();
</span>    factory.connect_setup(move |_, list_item| {
        // Create label
        let label = Label::new(None);
        let list_item = list_item
            .downcast_ref::&lt;ListItem&gt;()
            .expect("Needs to be ListItem");
        list_item.set_child(Some(&amp;label));

        // Bind `list_item-&gt;item-&gt;string` to `label-&gt;label`
        list_item
            .property_expression("item")
            .chain_property::&lt;StringObject&gt;("string")
            .bind(&amp;label, "label", Widget::NONE);
    });
<span class="boring">
</span><span class="boring">    let selection_model = NoSelection::new(Some(model));
</span><span class="boring">    let list_view = ListView::new(Some(selection_model), Some(factory));
</span><span class="boring">
</span><span class="boring">    let scrolled_window = ScrolledWindow::builder()
</span><span class="boring">        .hscrollbar_policy(PolicyType::Never) // Disable horizontal scrolling
</span><span class="boring">        .min_content_width(360)
</span><span class="boring">        .child(&amp;list_view)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a window
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .default_width(600)
</span><span class="boring">        .default_height(300)
</span><span class="boring">        .child(&amp;scrolled_window)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<h2 id="结论-1"><a class="header" href="#结论-1">结论</a></h2>
<p>我们现在知道了如何显示数据列表。 少量元素可由 <code>ListBox</code> 或 <code>FlowBox</code> 处理。 这些窗口小部件使用方便，必要时还可以绑定到 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.ListStore.html"><code>gio::ListStore</code></a> 等模型上。 这样就可以更方便地修改、排序和过滤数据。 但是，如果我们需要这些部件具有可扩展性，我们仍然需要使用  <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ListView.html"><code>ListView</code></a>, <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ColumnView.html"><code>ColumnView</code></a> 或 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.GridView.html"><code>GridView</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="composite-templates"><a class="header" href="#composite-templates">Composite Templates</a></h1>
<p>Until now, whenever we constructed pre-defined widgets we relied on the <a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html">builder pattern</a>.
As a reminder, that is how we used it to build our trusty "Hello World!" app.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/hello_world/3/main.rs">listings/hello_world/3/main.rs</a></p>
<pre><code class="language-rust">use gtk::prelude::*;
use gtk::{glib, Application, ApplicationWindow, Button};
const APP_ID: &amp;str = "org.gtk_rs.HelloWorld3";

fn main() -&gt; glib::ExitCode {
    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to "activate" signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

fn build_ui(app: &amp;Application) {
    // Create a button with label and margins
    let button = Button::builder()
        .label("Press me!")
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // Connect to "clicked" signal of `button`
    button.connect_clicked(|button| {
        // Set the label to "Hello World!" after the button has been clicked on
        button.set_label("Hello World!");
    });

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .child(&amp;button)
        .build();

    // Present window
    window.present();
}</code></pre>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/hello_world_button.webm" type="video/webm">
  <p>A video which shows that pressing on a button changes its label</p>
 </video>
</div>
<p>Creating widgets directly from code is fine, but it makes it harder to separate the logic from the user interface.
This is why most toolkits allow to describe the user interface with a markup language and GTK is no exception here.
For example the following <code>xml</code> file describes the window widget of the "Hello World!" app.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/composite_templates/1/resources/window.ui">listings/composite_templates/1/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkButton" id="button"&gt;
        &lt;property name="label"&gt;Press me!&lt;/property&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;  
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>The most outer tag always has to be the <code>&lt;interface&gt;</code>.
Then you start listing the elements you want to describe.
In order to define a composite template, we specify the name <code>MyGtkAppWindow</code> of the custom widget we want to create and the parent <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ApplicationWindow.html"><code>gtk::ApplicationWindow</code></a> it derives of.
These <code>xml</code> files are independent of the programming language, which is why the classes have the original names.
Luckily, they all convert like this: <code>gtk::ApplicationWindow</code> → <code>GtkApplicationWindow</code>.
Then we can specify properties which are listed <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ApplicationWindow.html#properties">here</a> for <code>ApplicationWindow</code>.
Since <code>ApplicationWindow</code> can contain other widgets we use the <code>&lt;child&gt;</code> tag to add a <code>gtk::Button</code>.
We want to be able to refer to the button later on so we also set its <code>id</code>.</p>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<p>In order to embed the template file into our application we take advantage of <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Resource.html"><code>gio::Resource</code></a>.
The files to embed are again described by an <code>xml</code> file.
For our template file we also add the <code>compressed</code> and <code>preprocess</code> attribute in order to reduce the final size of the resources.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/composite_templates/1/resources/resources.gresource.xml">listings/composite_templates/1/resources/resources.gresource.xml</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;gresources&gt;
  &lt;gresource prefix="/org/gtk_rs/example/"&gt;
    &lt;file compressed="true" preprocess="xml-stripblanks"&gt;window.ui&lt;/file&gt;
  &lt;/gresource&gt;
&lt;/gresources&gt;
</code></pre>
<p>Now we have to compile the resources and link it to our application.
One way to do this is to execute <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib_build_tools/fn.compile_resources.html"><code>glib_build_tools::compile_resources</code></a> within a cargo <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build script</a>.</p>
<p>First, we have to add <code>glib-build-tools</code> as build dependency in <code>Cargo.toml</code> by executing:</p>
<pre><code>cargo add glib-build-tools --build
</code></pre>
<p>Then, we create a <code>build.rs</code> at the root of our package with the following content.
This will compile the resources whenever we trigger a build with cargo and then statically link our executable to them.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/build.rs">listings/build.rs</a></p>
<pre><code class="language-rust">fn main() {
    glib_build_tools::compile_resources(
        &amp;["composite_templates/1/resources"],
        "composite_templates/1/resources/resources.gresource.xml",
        "composite_templates_1.gresource",
    );
}</code></pre>
<p>Finally, we register and include the resources by calling the macro <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/macro.resources_register_include.html"><code>gio::resources_register_include!</code></a>.
In your own apps take care to register the resources before creating the <code>gtk::Application</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/composite_templates/1/main.rs">listings/composite_templates/1/main.rs</a></p>
<pre><code class="language-rust">mod window;

use gtk::prelude::*;
use gtk::{gio, glib, Application};
use window::Window;

const APP_ID: &amp;str = "org.gtk_rs.CompositeTemplates1";

fn main() -&gt; glib::ExitCode {
    // Register and include resources
    gio::resources_register_include!("composite_templates_1.gresource")
        .expect("Failed to register resources.");

    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to "activate" signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}
fn build_ui(app: &amp;Application) {
    // Create new window and present it
    let window = Window::new(app);
    window.present();
}</code></pre>
<p>Within our code we create a custom widget inheriting from <code>gtk::ApplicationWindow</code> to make use of our template.
Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/composite_templates/1/window/mod.rs">listings/composite_templates/1/window/mod.rs</a></p>
<pre><code class="language-rust">mod imp;

use glib::Object;
use gtk::{gio, glib, Application};

glib::wrapper! {
    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
}

impl Window {
    pub fn new(app: &amp;Application) -&gt; Self {
        // Create new window
        Object::builder().property("application", app).build()
    }
}</code></pre>
<p>In the implementation struct, we then add the derive macro <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4_macros/derive.CompositeTemplate.html"><code>gtk::CompositeTemplate</code></a>.
We also specify that the template information comes from a resource of prefix <code>/org/gtk-rs/example</code> containing a file <code>window.ui</code>.</p>
<p>One very convenient feature of templates is the template child.
You use it by adding a struct member with the same name as one <code>id</code> attribute in the template.
<a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/subclass/widget/struct.TemplateChild.html"><code>TemplateChild</code></a> then stores a reference to the widget for later use.
This will be useful later, when we want to add a callback to our button.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/composite_templates/1/window/imp.rs">listings/composite_templates/1/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, Button, CompositeTemplate};
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/example/window.ui")]
pub struct Window {
    #[template_child]
    pub button: TemplateChild&lt;Button&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Connect to "clicked" signal of `button`
</span><span class="boring">        self.button.connect_clicked(move |button| {
</span><span class="boring">            // Set the label to "Hello World!" after the button has been clicked on
</span><span class="boring">            button.set_label("Hello World!");
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Within the <code>ObjectSubclass</code> trait, we make sure that <code>NAME</code> corresponds to <code>class</code> in the template and <code>ParentType</code> corresponds to <code>parent</code> in the template.
We also bind and initialize the template in <code>class_init</code> and <code>instance_init</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/composite_templates/1/window/imp.rs">listings/composite_templates/1/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, Button, CompositeTemplate};
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/example/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub button: TemplateChild&lt;Button&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "MyGtkAppWindow";
    type Type = super::Window;
    type ParentType = gtk::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Connect to "clicked" signal of `button`
</span><span class="boring">        self.button.connect_clicked(move |button| {
</span><span class="boring">            // Set the label to "Hello World!" after the button has been clicked on
</span><span class="boring">            button.set_label("Hello World!");
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Finally, we connect the callback to the "clicked" signal of <code>button</code> within <code>constructed</code>.
The button is easily available thanks to the stored reference in <code>self</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/composite_templates/1/window/imp.rs">listings/composite_templates/1/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, Button, CompositeTemplate};
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/example/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub button: TemplateChild&lt;Button&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        // Call "constructed" on parent
        self.parent_constructed();

        // Connect to "clicked" signal of `button`
        self.button.connect_clicked(move |button| {
            // Set the label to "Hello World!" after the button has been clicked on
            button.set_label("Hello World!");
        });
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<h2 id="custom-widgets"><a class="header" href="#custom-widgets">Custom Widgets</a></h2>
<p>We can also instantiate custom widgets within a template file.
First we define <code>CustomButton</code> that inherits from <code>gtk::Button</code>.
As usual, we define the implementation struct within <code>imp.rs</code>.
Note the <code>NAME</code> we define here, we will need it later to refer to it in the template.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/composite_templates/2/custom_button/imp.rs">listings/composite_templates/2/custom_button/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span>// Object holding the state
#[derive(Default)]
pub struct CustomButton;

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for CustomButton {
    const NAME: &amp;'static str = "MyGtkAppCustomButton";
    type Type = super::CustomButton;
    type ParentType = gtk::Button;
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all buttons
</span><span class="boring">impl ButtonImpl for CustomButton {}</span></code></pre>
<p>We also define the public struct in <code>mod.rs</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/composite_templates/2/custom_button/mod.rs">listings/composite_templates/2/custom_button/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">
</span>mod imp;

glib::wrapper! {
    pub struct CustomButton(ObjectSubclass&lt;imp::CustomButton&gt;)
        @extends gtk::Button, gtk::Widget,
        @implements gtk::Accessible, gtk::Actionable,
                    gtk::Buildable, gtk::ConstraintTarget;
}
<span class="boring">
</span><span class="boring">impl CustomButton {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Object::builder().build()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for CustomButton {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self::new()
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Since we want to refer to a <code>CustomButton</code> now we also have to change the type of the template child to it.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/composite_templates/2/window/imp.rs">listings/composite_templates/2/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CompositeTemplate};
</span><span class="boring">
</span><span class="boring">use crate::custom_button::CustomButton;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/example/window.ui")]
pub struct Window {
    #[template_child]
    pub button: TemplateChild&lt;CustomButton&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Connect to "clicked" signal of `button`
</span><span class="boring">        self.button.connect_clicked(move |button| {
</span><span class="boring">            // Set the label to "Hello World!" after the button has been clicked on
</span><span class="boring">            button.set_label("Hello World!");
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Finally, we can replace <code>GtkButton</code> with <code>MyGtkAppCustomButton</code> within our composite template.
Since the custom button is a direct subclass of <code>gtk::Button</code> without any modifications, the behavior of our app stays the same.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/composite_templates/2/resources/window.ui">listings/composite_templates/2/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="MyGtkAppCustomButton" id="button"&gt;
        &lt;property name="label"&gt;Press me!&lt;/property&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;  
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<h2 id="template-callbacks"><a class="header" href="#template-callbacks">Template Callbacks</a></h2>
<p>We can even specify the handlers of signals within composite templates.
This can be done with a <code>&lt;signal&gt;</code> tag containing the name of the signal and the handler in our Rust code.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/composite_templates/3/resources/window.ui">listings/composite_templates/3/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="MyGtkAppCustomButton" id="button"&gt;
        &lt;signal name="clicked" handler="handle_button_clicked"/&gt;
        &lt;property name="label"&gt;Press me!&lt;/property&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;  
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>Then we define the <code>handle_button_clicked</code> with the <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4_macros/attr.template_callbacks.html"><code>template_callbacks</code></a> macro applied to it.
We can determine the function signature by having a look at the <code>connect_*</code> method of the signal we want to handle.
In our case that would be <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.ButtonExt.html#tymethod.connect_clicked"><code>connect_clicked</code></a>.
It takes a function of type <code>Fn(&amp;Self)</code>.
<code>Self</code> refers to our button.
This means that <code>handle_button_clicked</code> has a single parameter of type <code>&amp;CustomButton</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/composite_templates/3/window/imp.rs">listings/composite_templates/3/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CompositeTemplate};
</span><span class="boring">
</span><span class="boring">use crate::custom_button::CustomButton;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/example/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub button: TemplateChild&lt;CustomButton&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">        klass.bind_template_callbacks();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[gtk::template_callbacks]
impl Window {
    #[template_callback]
    fn handle_button_clicked(button: &amp;CustomButton) {
        // Set the label to "Hello World!" after the button has been clicked on
        button.set_label("Hello World!");
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Then we have to bind the template callbacks with <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/subclass/widget/trait.CompositeTemplateCallbacksClass.html#tymethod.bind_template_callbacks"><code>bind_template_callbacks</code></a>.
We also need to remove the <code>button.connect_clicked</code> callback implemented in <code>window/imp.rs</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/composite_templates/3/window/imp.rs">listings/composite_templates/3/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CompositeTemplate};
</span><span class="boring">
</span><span class="boring">use crate::custom_button::CustomButton;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/example/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub button: TemplateChild&lt;CustomButton&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "MyGtkAppWindow";
    type Type = super::Window;
    type ParentType = gtk::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();
        klass.bind_template_callbacks();
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">#[gtk::template_callbacks]
</span><span class="boring">impl Window {
</span><span class="boring">    #[template_callback]
</span><span class="boring">    fn handle_button_clicked(button: &amp;CustomButton) {
</span><span class="boring">        // Set the label to "Hello World!" after the button has been clicked on
</span><span class="boring">        button.set_label("Hello World!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>We can also access the state of our widget.
Let's say we want to manipulate a <code>number</code> stored in <code>imp::Window</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/composite_templates/4/window/imp.rs">listings/composite_templates/4/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CompositeTemplate};
</span><span class="boring">
</span><span class="boring">use crate::custom_button::CustomButton;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/example/window.ui")]
pub struct Window {
    #[template_child]
    pub button: TemplateChild&lt;CustomButton&gt;,
    pub number: Cell&lt;i32&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">        klass.bind_template_callbacks();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[gtk::template_callbacks]
</span><span class="boring">impl Window {
</span><span class="boring">    #[template_callback]
</span><span class="boring">    fn handle_button_clicked(&amp;self, button: &amp;CustomButton) {
</span><span class="boring">        let number_increased = self.number.get() + 1;
</span><span class="boring">        self.number.set(number_increased);
</span><span class="boring">        button.set_label(&amp;number_increased.to_string())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>In order to access the widget's state we have to add <code>swapped="true"</code> to the <code>signal</code> tag.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/composite_templates/4/resources/window.ui">listings/composite_templates/4/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="MyGtkAppCustomButton" id="button"&gt;
        &lt;signal name="clicked" handler="handle_button_clicked" swapped="true"/&gt;
        &lt;property name="label"&gt;Press me!&lt;/property&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;  
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>Now we can add <code>&amp;self</code> as first parameter to <code>handle_button_clicked</code>.
This lets us access the state of the window and therefore manipulate <code>number</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/composite_templates/4/window/imp.rs">listings/composite_templates/4/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CompositeTemplate};
</span><span class="boring">
</span><span class="boring">use crate::custom_button::CustomButton;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/example/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub button: TemplateChild&lt;CustomButton&gt;,
</span><span class="boring">    pub number: Cell&lt;i32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">        klass.bind_template_callbacks();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[gtk::template_callbacks]
impl Window {
    #[template_callback]
    fn handle_button_clicked(&amp;self, button: &amp;CustomButton) {
        let number_increased = self.number.get() + 1;
        self.number.set(number_increased);
        button.set_label(&amp;number_increased.to_string())
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<h2 id="registering-types"><a class="header" href="#registering-types">Registering Types</a></h2>
<p>Now that we use template callbacks we don't access the template child anymore.
Let's remove it.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/composite_templates/5/window/imp.rs">listings/composite_templates/5/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CompositeTemplate};
</span><span class="boring">
</span><span class="boring">use crate::custom_button::CustomButton;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/example/window.ui")]
pub struct Window {
    pub number: Cell&lt;i32&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">        klass.bind_template_callbacks();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[gtk::template_callbacks]
</span><span class="boring">impl Window {
</span><span class="boring">    #[template_callback]
</span><span class="boring">    fn handle_button_clicked(&amp;self, button: &amp;CustomButton) {
</span><span class="boring">        let number_increased = self.number.get() + 1;
</span><span class="boring">        self.number.set(number_increased);
</span><span class="boring">        button.set_label(&amp;number_increased.to_string())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>However, when we now run it GTK doesn't see <code>MyGtkAppCustomButton</code> as valid object type anymore.
So what happened here?</p>
<pre><code>Gtk-CRITICAL **: Error building template class 'MyGtkAppWindow' for an instance of
                 type 'MyGtkAppWindow': Invalid object type 'MyGtkAppCustomButton'
</code></pre>
<p>Turns out adding a template child not only gives a convenient reference to a widget within the template.
It also ensures that the widget type is registered.
Luckily we can also do that by ourselves.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/composite_templates/6/window/imp.rs">listings/composite_templates/6/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CompositeTemplate};
</span><span class="boring">
</span><span class="boring">use crate::custom_button::CustomButton;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/example/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    pub number: Cell&lt;i32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "MyGtkAppWindow";
    type Type = super::Window;
    type ParentType = gtk::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        // Register `CustomButton`
        CustomButton::ensure_type();

        klass.bind_template();
        klass.bind_template_callbacks();
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">#[gtk::template_callbacks]
</span><span class="boring">impl Window {
</span><span class="boring">    #[template_callback]
</span><span class="boring">    fn handle_button_clicked(&amp;self, button: &amp;CustomButton) {
</span><span class="boring">        let number_increased = self.number.get() + 1;
</span><span class="boring">        self.number.set(number_increased);
</span><span class="boring">        button.set_label(&amp;number_increased.to_string())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>We call the <code>ensure_type</code> method within <code>class_init</code> and voilà: our app works again.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Thanks to custom widgets we can</p>
<ul>
<li>keep state and part of it as properties,</li>
<li>add signals as well as</li>
<li>override behavior.</li>
</ul>
<p>Thanks to composite templates we can</p>
<ul>
<li>describe complex user interfaces concisely,</li>
<li>easily access widgets within the template as well as</li>
<li>specify handler functions for signals.</li>
</ul>
<p>The API involved here is extensive so especially at the beginning you will want to check out the documentation.
The basic syntax of the <code>ui</code> files is explained within <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Builder.html#gtkbuilder-ui-definitions"><code>Builder</code></a>, syntax specific to widgets within <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Widget.html#gtkwidget-as-gtkbuildable"><code>Widget</code></a>.
If a certain widget accepts additional element, then they are typically explained in the docs of the widget.</p>
<p>In the following chapter, we will see how composite templates help us to create slightly bigger apps such as a To-Do app.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-simple-to-do-app"><a class="header" href="#building-a-simple-to-do-app">Building a Simple To-Do App</a></h1>
<p>After we have learned so many concepts, it is finally time to put them into practice.
We are going to build a To-Do app!</p>
<p>For now, we would already be satisfied with a minimal version.
An entry to input new tasks and a list view to display them will suffice.
Something like this:</p>
<div style="text-align:center"><img src="img/todo_1_mockup.png" alt="To-Do App with a couple of tasks, some of them crossed-off"/></div>
<h2 id="window"><a class="header" href="#window">Window</a></h2>
<p>This mockup can be described by the following composite template.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/1/resources/window.ui">listings/todo/1/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="TodoWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="width-request"&gt;360&lt;/property&gt;
    &lt;property name="title" translatable="yes"&gt;To-Do&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkBox"&gt;
        &lt;property name="orientation"&gt;vertical&lt;/property&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;
        &lt;property name="spacing"&gt;6&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkEntry" id="entry"&gt;
            &lt;property name="placeholder-text" translatable="yes"&gt;Enter a Task…&lt;/property&gt;
            &lt;property name="secondary-icon-name"&gt;list-add-symbolic&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class="GtkScrolledWindow"&gt;
            &lt;property name="hscrollbar-policy"&gt;never&lt;/property&gt;
            &lt;property name="min-content-height"&gt;360&lt;/property&gt;
            &lt;property name="vexpand"&gt;true&lt;/property&gt;
            &lt;child&gt;
              &lt;object class="GtkListView" id="tasks_list"&gt;
                &lt;property name="valign"&gt;start&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>In order to use the composite template, we create a custom widget.
The <code>parent</code> is <code>gtk::ApplicationWindow</code>, so we inherit from it.
As usual, we have to list all <a href="https://docs.gtk.org/gtk4/class.ApplicationWindow.html#ancestors">ancestors</a> and <a href="https://docs.gtk.org/gtk4/class.ApplicationWindow.html#implements">interfaces</a> apart from <code>GObject</code> and <code>GInitiallyUnowned</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/1/window/mod.rs">listings/todo/1/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, NoSelection, SignalListItemFactory};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">
</span>glib::wrapper! {
    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
}
<span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with selection and pass it to the list view
</span><span class="boring">        let selection_model = NoSelection::new(Some(self.tasks()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Then we initialize the composite template for <code>imp::Window</code>.
We store references to the entry, the list view as well as the list model.
This will come in handy when we later add methods to our window.
After that, we add the typical boilerplate for initializing composite templates.
We only have to assure that the <code>class</code> attribute of the template in <code>window.ui</code> matches <code>NAME</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/1/window/imp.rs">listings/todo/1/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListView};
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/Todo1/window.ui")]
pub struct Window {
    #[template_child]
    pub entry: TemplateChild&lt;Entry&gt;,
    #[template_child]
    pub tasks_list: TemplateChild&lt;ListView&gt;,
    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "TodoWindow";
    type Type = super::Window;
    type ParentType = gtk::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_factory();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p><code>main.rs</code> also does not hold any surprises for us.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/1/main.rs">listings/todo/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod task_object;
</span><span class="boring">mod task_row;
</span><span class="boring">mod window;
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application};
</span><span class="boring">use window::Window;
</span><span class="boring">
</span>fn main() -&gt; glib::ExitCode {
    // Register and include resources
    gio::resources_register_include!("todo_1.gresource")
        .expect("Failed to register resources.");

    // Create a new application
    let app = Application::builder()
        .application_id("org.gtk_rs.Todo1")
        .build();

    // Connect to "activate" signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

fn build_ui(app: &amp;Application) {
    // Create a new custom window and present it
    let window = Window::new(app);
    window.present();
}</code></pre>
<p>Finally, we specify our resources.
Here, they already include <code>task_row.ui</code> which we will handle later in this chapter.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/1/resources/resources.gresource.xml">listings/todo/1/resources/resources.gresource.xml</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;gresources&gt;
  &lt;gresource prefix="/org/gtk_rs/Todo1/"&gt;
    &lt;file compressed="true" preprocess="xml-stripblanks"&gt;task_row.ui&lt;/file&gt;
    &lt;file compressed="true" preprocess="xml-stripblanks"&gt;window.ui&lt;/file&gt;
  &lt;/gresource&gt;
&lt;/gresources&gt;
</code></pre>
<h2 id="task-object"><a class="header" href="#task-object">Task Object</a></h2>
<p>So far so good.
The main user interface is done, but the entry does not react to input yet.
Also, where would the input go?
We haven't even set up the list model yet.
Let's do that!</p>
<div style="text-align:center"><img src="img/todo_1_empty.png" alt="To-Do app without any content"/></div>
<p>As discussed in the <a href="./list_widgets.html">list widgets chapter</a>,
we start out by creating a custom GObject.
This object will store the state of the task consisting of:</p>
<ul>
<li>a boolean describing whether the task is completed or not, and</li>
<li>a string holding the task name.</li>
</ul>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/1/task_object/mod.rs">listings/todo/1/task_object/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">
</span>glib::wrapper! {
    pub struct TaskObject(ObjectSubclass&lt;imp::TaskObject&gt;);
}

impl TaskObject {
    pub fn new(completed: bool, content: String) -&gt; Self {
        Object::builder()
            .property("completed", completed)
            .property("content", content)
            .build()
    }
}
<span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct TaskData {
</span><span class="boring">    pub completed: bool,
</span><span class="boring">    pub content: String,
</span><span class="boring">}</span></code></pre>
<p>Unlike the lists chapter, the state is stored in a struct rather than in individual members of <code>imp::TaskObject</code>.
This will be very convenient when saving the state in one of the following chapters.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/1/task_object/mod.rs">listings/todo/1/task_object/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct TaskObject(ObjectSubclass&lt;imp::TaskObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TaskObject {
</span><span class="boring">    pub fn new(completed: bool, content: String) -&gt; Self {
</span><span class="boring">        Object::builder()
</span><span class="boring">            .property("completed", completed)
</span><span class="boring">            .property("content", content)
</span><span class="boring">            .build()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Default)]
pub struct TaskData {
    pub completed: bool,
    pub content: String,
}</code></pre>
<p>We are going to expose <code>completed</code> and <code>content</code> as properties.
Since the data is now inside a struct rather than individual member variables we have to add more annotations.
For each property we additionally specify the name, the type and which member variable of <code>TaskData</code> we want to access.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/1/task_object/imp.rs">listings/todo/1/task_object/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">use glib::Properties;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">use super::TaskData;
</span><span class="boring">
</span>// Object holding the state
#[derive(Properties, Default)]
#[properties(wrapper_type = super::TaskObject)]
pub struct TaskObject {
    #[property(name = "completed", get, set, type = bool, member = completed)]
    #[property(name = "content", get, set, type = String, member = content)]
    pub data: RefCell&lt;TaskData&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for TaskObject {
    const NAME: &amp;'static str = "TodoTaskObject";
    type Type = super::TaskObject;
}

// Trait shared by all GObjects
#[glib::derived_properties]
impl ObjectImpl for TaskObject {}</code></pre>
<h2 id="task-row"><a class="header" href="#task-row">Task Row</a></h2>
<p>Let's move on to the individual tasks.
The row of a task should look like this:</p>
<div style="text-align:center"><img src="img/task_row.png" alt="A single task widget"/></div>
<p>Again, we describe the mockup with a composite template.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/1/resources/task_row.ui">listings/todo/1/resources/task_row.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="TodoTaskRow" parent="GtkBox"&gt;
    &lt;child&gt;
      &lt;object class="GtkCheckButton" id="completed_button"&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;
      &lt;/object&gt;
    &lt;/child&gt;
    &lt;child&gt;
      &lt;object class="GtkLabel" id="content_label"&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>In the code, we <a href="https://docs.gtk.org/gtk4/class.Box.html#hierarchy">derive</a> <code>TaskRow</code> from <code>gtk:Box</code>:</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/1/task_row/mod.rs">listings/todo/1/task_row/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, pango};
</span><span class="boring">use pango::{AttrInt, AttrList};
</span><span class="boring">
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">
</span>glib::wrapper! {
    pub struct TaskRow(ObjectSubclass&lt;imp::TaskRow&gt;)
    @extends gtk::Box, gtk::Widget,
    @implements gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget, gtk::Orientable;
}
<span class="boring">
</span><span class="boring">impl Default for TaskRow {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self::new()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TaskRow {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Object::builder().build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn bind(&amp;self, task_object: &amp;TaskObject) {
</span><span class="boring">        // Get state
</span><span class="boring">        let completed_button = self.imp().completed_button.get();
</span><span class="boring">        let content_label = self.imp().content_label.get();
</span><span class="boring">        let mut bindings = self.imp().bindings.borrow_mut();
</span><span class="boring">
</span><span class="boring">        // Bind `task_object.completed` to `task_row.completed_button.active`
</span><span class="boring">        let completed_button_binding = task_object
</span><span class="boring">            .bind_property("completed", &amp;completed_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(completed_button_binding);
</span><span class="boring">
</span><span class="boring">        // Bind `task_object.content` to `task_row.content_label.label`
</span><span class="boring">        let content_label_binding = task_object
</span><span class="boring">            .bind_property("content", &amp;content_label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(content_label_binding);
</span><span class="boring">
</span><span class="boring">        // Bind `task_object.completed` to `task_row.content_label.attributes`
</span><span class="boring">        let content_label_binding = task_object
</span><span class="boring">            .bind_property("completed", &amp;content_label, "attributes")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .transform_to(|_, active| {
</span><span class="boring">                let attribute_list = AttrList::new();
</span><span class="boring">                if active {
</span><span class="boring">                    // If "active" is true, content of the label will be strikethrough
</span><span class="boring">                    let attribute = AttrInt::new_strikethrough(true);
</span><span class="boring">                    attribute_list.insert(attribute);
</span><span class="boring">                }
</span><span class="boring">                Some(attribute_list.to_value())
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(content_label_binding);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn unbind(&amp;self) {
</span><span class="boring">        // Unbind all stored bindings
</span><span class="boring">        for binding in self.imp().bindings.borrow_mut().drain(..) {
</span><span class="boring">            binding.unbind();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>In <code>imp::TaskRow</code>, we hold references to <code>completed_button</code> and <code>content_label</code>.
We also store a mutable vector of bindings.
Why we need that will become clear as soon as we get to bind the state of <code>TaskObject</code> to the corresponding <code>TaskRow</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/1/task_row/imp.rs">listings/todo/1/task_row/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">use glib::Binding;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CheckButton, CompositeTemplate, Label};
</span><span class="boring">
</span>// Object holding the state
#[derive(Default, CompositeTemplate)]
#[template(resource = "/org/gtk_rs/Todo1/task_row.ui")]
pub struct TaskRow {
    #[template_child]
    pub completed_button: TemplateChild&lt;CheckButton&gt;,
    #[template_child]
    pub content_label: TemplateChild&lt;Label&gt;,
    // Vector holding the bindings to properties of `TaskObject`
    pub bindings: RefCell&lt;Vec&lt;Binding&gt;&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for TaskRow {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "TodoTaskRow";
    type Type = super::TaskRow;
    type ParentType = gtk::Box;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();
    }

    fn instance_init(obj: &amp;glib::subclass::InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for TaskRow {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for TaskRow {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all boxes
</span><span class="boring">impl BoxImpl for TaskRow {}</span></code></pre>
<p>Now we can bring everything together.
We override the <code>imp::Window::constructed</code> in order to set up window contents at the time of its construction.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/1/window/imp.rs">listings/todo/1/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListView};
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo1/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListView&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        // Call "constructed" on parent
        self.parent_constructed();

        // Setup
        let obj = self.obj();
        obj.setup_tasks();
        obj.setup_callbacks();
        obj.setup_factory();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Since we need to access the list model quite often, we add the convenience method <code>Window::tasks</code> for that.
In <code>Window::setup_tasks</code> we create a new model.
Then we store a reference to the model in <code>imp::Window</code> as well as in <code>gtk::ListView</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/1/window/mod.rs">listings/todo/1/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, NoSelection, SignalListItemFactory};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span>    fn tasks(&amp;self) -&gt; gio::ListStore {
        // Get state
        self.imp()
            .tasks
            .borrow()
            .clone()
            .expect("Could not get current tasks.")
    }

    fn setup_tasks(&amp;self) {
        // Create new model
        let model = gio::ListStore::new::&lt;TaskObject&gt;();

        // Get state and set model
        self.imp().tasks.replace(Some(model));

        // Wrap model with selection and pass it to the list view
        let selection_model = NoSelection::new(Some(self.tasks()));
        self.imp().tasks_list.set_model(Some(&amp;selection_model));
    }
<span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We also create a method <code>new_task</code> which takes the content of the entry, clears the entry and uses the content to create a new task.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/1/window/mod.rs">listings/todo/1/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, NoSelection, SignalListItemFactory};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with selection and pass it to the list view
</span><span class="boring">        let selection_model = NoSelection::new(Some(self.tasks()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span>    fn new_task(&amp;self) {
        // Get content from entry and clear it
        let buffer = self.imp().entry.buffer();
        let content = buffer.text().to_string();
        if content.is_empty() {
            return;
        }
        buffer.set_text("");

        // Add new task to model
        let task = TaskObject::new(false, content);
        self.tasks().append(&amp;task);
    }
<span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>In <code>Window::setup_callbacks</code> we connect to the "activate" signal of the entry.
This signal is triggered when we press the enter key in the entry.
Then a new <code>TaskObject</code> with the content will be created and appended to the model.
Finally, the entry will be cleared.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/1/window/mod.rs">listings/todo/1/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, NoSelection, SignalListItemFactory};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with selection and pass it to the list view
</span><span class="boring">        let selection_model = NoSelection::new(Some(self.tasks()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_callbacks(&amp;self) {
        // Setup callback for activation of the entry
        self.imp().entry.connect_activate(clone!(
            #[weak(rename_to = window)]
            self,
            move |_| {
                window.new_task();
            }
        ));

        // Setup callback for clicking (and the releasing) the icon of the entry
        self.imp().entry.connect_icon_release(clone!(
            #[weak(rename_to = window)]
            self,
            move |_, _| {
                window.new_task();
            }
        ));
    }
<span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>The list elements for the <code>gtk::ListView</code> are produced by a factory.
Before we move on to the implementation, let's take a step back and think about which behavior we expect here.
<code>content_label</code> of <code>TaskRow</code> should follow <code>content</code> of <code>TaskObject</code>.
We also want <code>completed_button</code> of <code>TaskRow</code> follow <code>completed</code> of <code>TaskObject</code>.
This could be achieved with expressions similar to what we did in the lists chapter.</p>
<p>However, if we toggle the state of <code>completed_button</code> of <code>TaskRow</code>, <code>completed</code> of <code>TaskObject</code> should change too.
Unfortunately, expressions cannot handle bidirectional relationships.
This means we have to use property bindings.
We will need to unbind them manually when they are no longer needed.</p>
<p>We will create empty <code>TaskRow</code> objects in the "setup" step in <code>Window::setup_factory</code> and deal with binding in the "bind" and "unbind" steps.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/1/window/mod.rs">listings/todo/1/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, NoSelection, SignalListItemFactory};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with selection and pass it to the list view
</span><span class="boring">        let selection_model = NoSelection::new(Some(self.tasks()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_factory(&amp;self) {
        // Create a new factory
        let factory = SignalListItemFactory::new();

        // Create an empty `TaskRow` during setup
        factory.connect_setup(move |_, list_item| {
            // Create `TaskRow`
            let task_row = TaskRow::new();
            list_item
                .downcast_ref::&lt;ListItem&gt;()
                .expect("Needs to be ListItem")
                .set_child(Some(&amp;task_row));
        });

        // Tell factory how to bind `TaskRow` to a `TaskObject`
        factory.connect_bind(move |_, list_item| {
            // Get `TaskObject` from `ListItem`
            let task_object = list_item
                .downcast_ref::&lt;ListItem&gt;()
                .expect("Needs to be ListItem")
                .item()
                .and_downcast::&lt;TaskObject&gt;()
                .expect("The item has to be an `TaskObject`.");

            // Get `TaskRow` from `ListItem`
            let task_row = list_item
                .downcast_ref::&lt;ListItem&gt;()
                .expect("Needs to be ListItem")
                .child()
                .and_downcast::&lt;TaskRow&gt;()
                .expect("The child has to be a `TaskRow`.");

            task_row.bind(&amp;task_object);
        });

        // Tell factory how to unbind `TaskRow` from `TaskObject`
        factory.connect_unbind(move |_, list_item| {
            // Get `TaskRow` from `ListItem`
            let task_row = list_item
                .downcast_ref::&lt;ListItem&gt;()
                .expect("Needs to be ListItem")
                .child()
                .and_downcast::&lt;TaskRow&gt;()
                .expect("The child has to be a `TaskRow`.");

            task_row.unbind();
        });

        // Set the factory of the list view
        self.imp().tasks_list.set_factory(Some(&amp;factory));
    }
<span class="boring">}</span></code></pre>
<p>Binding properties in <code>TaskRow::bind</code> works just like in former chapters.
The only difference is that we store the bindings in a vector.
This is necessary because a <code>TaskRow</code> will be reused as you scroll through the list.
That means that over time a <code>TaskRow</code> will need to bound to a new <code>TaskObject</code> and has to be unbound from the old one.
Unbinding will only work if it can access the stored <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.Binding.html"><code>glib::Binding</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/1/task_row/mod.rs">listings/todo/1/task_row/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, pango};
</span><span class="boring">use pango::{AttrInt, AttrList};
</span><span class="boring">
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct TaskRow(ObjectSubclass&lt;imp::TaskRow&gt;)
</span><span class="boring">    @extends gtk::Box, gtk::Widget,
</span><span class="boring">    @implements gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget, gtk::Orientable;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for TaskRow {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self::new()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TaskRow {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Object::builder().build()
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn bind(&amp;self, task_object: &amp;TaskObject) {
        // Get state
        let completed_button = self.imp().completed_button.get();
        let content_label = self.imp().content_label.get();
        let mut bindings = self.imp().bindings.borrow_mut();

        // Bind `task_object.completed` to `task_row.completed_button.active`
        let completed_button_binding = task_object
            .bind_property("completed", &amp;completed_button, "active")
            .bidirectional()
            .sync_create()
            .build();
        // Save binding
        bindings.push(completed_button_binding);

        // Bind `task_object.content` to `task_row.content_label.label`
        let content_label_binding = task_object
            .bind_property("content", &amp;content_label, "label")
            .sync_create()
            .build();
        // Save binding
        bindings.push(content_label_binding);

        // Bind `task_object.completed` to `task_row.content_label.attributes`
        let content_label_binding = task_object
            .bind_property("completed", &amp;content_label, "attributes")
            .sync_create()
            .transform_to(|_, active| {
                let attribute_list = AttrList::new();
                if active {
                    // If "active" is true, content of the label will be strikethrough
                    let attribute = AttrInt::new_strikethrough(true);
                    attribute_list.insert(attribute);
                }
                Some(attribute_list.to_value())
            })
            .build();
        // Save binding
        bindings.push(content_label_binding);
    }
<span class="boring">
</span><span class="boring">    pub fn unbind(&amp;self) {
</span><span class="boring">        // Unbind all stored bindings
</span><span class="boring">        for binding in self.imp().bindings.borrow_mut().drain(..) {
</span><span class="boring">            binding.unbind();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>TaskRow::unbind</code> takes care of the cleanup.
It iterates through the vector and unbinds each binding.
In the end, it clears the vector.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/1/task_row/mod.rs">listings/todo/1/task_row/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, pango};
</span><span class="boring">use pango::{AttrInt, AttrList};
</span><span class="boring">
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct TaskRow(ObjectSubclass&lt;imp::TaskRow&gt;)
</span><span class="boring">    @extends gtk::Box, gtk::Widget,
</span><span class="boring">    @implements gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget, gtk::Orientable;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for TaskRow {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self::new()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TaskRow {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Object::builder().build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn bind(&amp;self, task_object: &amp;TaskObject) {
</span><span class="boring">        // Get state
</span><span class="boring">        let completed_button = self.imp().completed_button.get();
</span><span class="boring">        let content_label = self.imp().content_label.get();
</span><span class="boring">        let mut bindings = self.imp().bindings.borrow_mut();
</span><span class="boring">
</span><span class="boring">        // Bind `task_object.completed` to `task_row.completed_button.active`
</span><span class="boring">        let completed_button_binding = task_object
</span><span class="boring">            .bind_property("completed", &amp;completed_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(completed_button_binding);
</span><span class="boring">
</span><span class="boring">        // Bind `task_object.content` to `task_row.content_label.label`
</span><span class="boring">        let content_label_binding = task_object
</span><span class="boring">            .bind_property("content", &amp;content_label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(content_label_binding);
</span><span class="boring">
</span><span class="boring">        // Bind `task_object.completed` to `task_row.content_label.attributes`
</span><span class="boring">        let content_label_binding = task_object
</span><span class="boring">            .bind_property("completed", &amp;content_label, "attributes")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .transform_to(|_, active| {
</span><span class="boring">                let attribute_list = AttrList::new();
</span><span class="boring">                if active {
</span><span class="boring">                    // If "active" is true, content of the label will be strikethrough
</span><span class="boring">                    let attribute = AttrInt::new_strikethrough(true);
</span><span class="boring">                    attribute_list.insert(attribute);
</span><span class="boring">                }
</span><span class="boring">                Some(attribute_list.to_value())
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(content_label_binding);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn unbind(&amp;self) {
        // Unbind all stored bindings
        for binding in self.imp().bindings.borrow_mut().drain(..) {
            binding.unbind();
        }
    }
<span class="boring">}</span></code></pre>
<p>That was it, we created a basic To-Do app!
We will extend it with additional functionality in the following chapters.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_1_animation.webm" type="video/webm">
  <p>A video which shows how to enter tasks to the To-Do app</p>
 </video>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actions"><a class="header" href="#actions">Actions</a></h1>
<p>By now, we've already learned many ways to glue our widgets together.
We can send messages through channels, emit signals, share reference-counted state and bind properties.
Now, we will complete our set by learning about actions.</p>
<p>An action is a piece of functionality bound to a certain GObject.
Let's check out the simplest case where we activate an action without a parameter.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/1/main.rs">listings/actions/1/main.rs</a></p>
<pre><code class="language-rust no_run"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Actions1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Set keyboard accelerator to trigger "win.close".
</span><span class="boring">    app.set_accels_for_action("win.close", &amp;["&lt;Ctrl&gt;W"]);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Create a window and set the title
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .width_request(360)
        .build();

    // Add action "close" to `window` taking no parameter
    let action_close = ActionEntry::builder("close")
        .activate(|window: &amp;ApplicationWindow, _, _| {
            window.close();
        })
        .build();
    window.add_action_entries([action_close]);

    // Present window
    window.present();
}</code></pre>
<p>First, we created a new <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.ActionEntry.html"><code>gio::ActionEntry</code></a> which is named "close" and takes no parameter.
We also connected a callback which closes the window when the action is activated.
Finally, we add the action entry to the window via <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/prelude/trait.ActionMapExtManual.html#method.add_action_entries"><code>add_action_entries</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/1/main.rs">listings/actions/1/main.rs</a></p>
<pre><code class="language-rust no_run"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, ApplicationWindow};
</span><span class="boring">
</span>const APP_ID: &amp;str = "org.gtk_rs.Actions1";

fn main() -&gt; glib::ExitCode {
    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to "activate" signal of `app`
    app.connect_activate(build_ui);

    // Set keyboard accelerator to trigger "win.close".
    app.set_accels_for_action("win.close", &amp;["&lt;Ctrl&gt;W"]);

    // Run the application
    app.run()
}
<span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window and set the title
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .width_request(360)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Add action "close" to `window` taking no parameter
</span><span class="boring">    let action_close = ActionEntry::builder("close")
</span><span class="boring">        .activate(|window: &amp;ApplicationWindow, _, _| {
</span><span class="boring">            window.close();
</span><span class="boring">        })
</span><span class="boring">        .build();
</span><span class="boring">    window.add_action_entries([action_close]);
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>One of the most popular reasons to use actions are keyboard accelerators, so we added one here.
With <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.GtkApplicationExt.html#tymethod.set_accels_for_action"><code>set_accels_for_action</code></a> one can assign one or more accelerators to a certain action.
Check the documentation of <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/functions/fn.accelerator_parse.html"><code>accelerator_parse</code></a> in order to learn more about its syntax.</p>
<p>Before we move on to other aspects of actions, let's appreciate a few things that are curious here.
The "win" part of "win.close" is the group of the action.
But how does GTK know that "win" is the action group of our window?
The answer is that it is so common to add actions to windows and applications that there are already two predefined groups available:</p>
<ul>
<li>"app" for actions global to the application, and</li>
<li>"win" for actions tied to an application window.</li>
</ul>
<p>We can add an action group to any widget via the method <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.WidgetExt.html#method.insert_action_group"><code>insert_action_group</code></a>.
Let's add our action to the action group "custom-group" and add the group then to our window.
The action entry isn't specific to our window anymore, the first parameter of the "activate" callback is of type <code>SimpleActionGroup</code> instead of <code>ApplicationWindow</code>.
This means we have to clone <code>window</code> into the closure.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/2/main.rs">listings/actions/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::gio::SimpleActionGroup;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Actions2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">    // Set keyboard accelerator to trigger "custom-group.close".
</span><span class="boring">    app.set_accels_for_action("custom-group.close", &amp;["&lt;Ctrl&gt;W"]);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Create a window and set the title
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .width_request(360)
        .build();

    // Add action "close" to `window` taking no parameter
    let action_close = ActionEntry::builder("close")
        .activate(clone!(
            #[weak]
            window,
            move |_, _, _| {
                window.close();
            }
        ))
        .build();

    // Create a new action group and add actions to it
    let actions = SimpleActionGroup::new();
    actions.add_action_entries([action_close]);
    window.insert_action_group("custom-group", Some(&amp;actions));

    // Present window
    window.present();
}</code></pre>
<p>If we bind the accelerator to "custom-group.close", it works just as before.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/2/main.rs">listings/actions/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::gio::SimpleActionGroup;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Actions2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span>    // Set keyboard accelerator to trigger "custom-group.close".
    app.set_accels_for_action("custom-group.close", &amp;["&lt;Ctrl&gt;W"]);
<span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window and set the title
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .width_request(360)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Add action "close" to `window` taking no parameter
</span><span class="boring">    let action_close = ActionEntry::builder("close")
</span><span class="boring">        .activate(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            window,
</span><span class="boring">            move |_, _, _| {
</span><span class="boring">                window.close();
</span><span class="boring">            }
</span><span class="boring">        ))
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a new action group and add actions to it
</span><span class="boring">    let actions = SimpleActionGroup::new();
</span><span class="boring">    actions.add_action_entries([action_close]);
</span><span class="boring">    window.insert_action_group("custom-group", Some(&amp;actions));
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Also, if we had multiple instances of the same windows, we would expect that only the currently focused window will be closed when activating "win.close".
And indeed, the "win.close" will be dispatched to the currently focused window.
However, that also means that we actually define one action per window instance.
If we want to have a single globally accessible action instead, we call <code>add_action_entries</code> on our application instead.</p>
<blockquote>
<p>Adding "win.close" was useful as a simple example.
However, in the future we will use the pre-defined <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Window.html#actions">"window.close"</a> action which does exactly the same thing.</p>
</blockquote>
<h2 id="parameter-and-state"><a class="header" href="#parameter-and-state">Parameter and State</a></h2>
<p>An action, like most functions, can take a parameter.
However, unlike most functions it can also be stateful.
Let's see how this works.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/3/main.rs">listings/actions/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Align, Application, ApplicationWindow, Button, Label, Orientation,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Actions3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    let original_state = 0;
    let label = Label::builder()
        .label(format!("Counter: {original_state}"))
        .build();

    // Create a button with label
    let button = Button::builder().label("Press me!").build();

    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |button| {
        // Activate "win.count" and pass "1" as parameter
        let parameter = 1;
        button
            .activate_action("win.count", Some(&amp;parameter.to_variant()))
            .expect("The action does not exist.");
    });

    // Create a `gtk::Box` and add `button` and `label` to it
    let gtk_box = gtk::Box::builder()
        .orientation(Orientation::Vertical)
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .spacing(12)
        .halign(Align::Center)
        .build();
    gtk_box.append(&amp;button);
    gtk_box.append(&amp;label);

    // Create a window, set the title and add `gtk_box` to it
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .width_request(360)
        .child(&amp;gtk_box)
        .build();

    // Add action "count" to `window` taking an integer as parameter
    let action_count = ActionEntry::builder("count")
        .parameter_type(Some(&amp;i32::static_variant_type()))
        .state(original_state.to_variant())
        .activate(move |_, action, parameter| {
            // Get state
            let mut state = action
                .state()
                .expect("Could not get state.")
                .get::&lt;i32&gt;()
                .expect("The variant needs to be of type `i32`.");

            // Get parameter
            let parameter = parameter
                .expect("Could not get parameter.")
                .get::&lt;i32&gt;()
                .expect("The variant needs to be of type `i32`.");

            // Increase state by parameter and store state
            state += parameter;
            action.set_state(&amp;state.to_variant());

            // Update label with new state
            label.set_label(&amp;format!("Counter: {state}"));
        })
        .build();
    window.add_action_entries([action_count]);

    // Present window
    window.present();
}</code></pre>
<p>Here, we created a "win.count" action that increases its state by the given parameter every time it is activated.
It also takes care of updating the <code>label</code> with the current state.
The button activates the action with each click while passing "1" as parameter.
This is how our app works:</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/actions_counter.webm" type="video/webm">
  <p>A video which shows that pressing on one button also changes the label below</p>
 </video>
</div>
<h2 id="actionable"><a class="header" href="#actionable">Actionable</a></h2>
<p>Connecting actions to the "clicked" signal of buttons is a typical use case, which is why all buttons implement the <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Actionable.html"><code>Actionable</code></a> interface.
This way, the action can be specified by setting the "action-name" property.
If the action accepts a parameter, it can be set via the "action-target" property.
With <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/builders/struct.ButtonBuilder.html"><code>ButtonBuilder</code></a>, we can set everything up by calling its methods.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/4/main.rs">listings/actions/4/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Align, Application, ApplicationWindow, Button, Label, Orientation,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Actions4";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    let original_state = 0;
</span><span class="boring">    let label = Label::builder()
</span><span class="boring">        .label(format!("Counter: {original_state}"))
</span><span class="boring">        .build();
</span>    // Create a button with label and action
    let button = Button::builder()
        .label("Press me!")
        .action_name("win.count")
        .action_target(&amp;1.to_variant())
        .build();
<span class="boring">
</span><span class="boring">    // Create `gtk_box` and add `button` and `label` to it
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button);
</span><span class="boring">    gtk_box.append(&amp;label);
</span><span class="boring">
</span><span class="boring">    // Create a window and set the title
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .width_request(360)
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Add action "count" to `window` taking an integer as parameter
</span><span class="boring">    let action_count = ActionEntry::builder("count")
</span><span class="boring">        .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">        .state(original_state.to_variant())
</span><span class="boring">        .activate(move |_, action, parameter| {
</span><span class="boring">            // Get state
</span><span class="boring">            let mut state = action
</span><span class="boring">                .state()
</span><span class="boring">                .expect("Could not get state.")
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">            // Get parameter
</span><span class="boring">            let parameter = parameter
</span><span class="boring">                .expect("Could not get parameter.")
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">            // Increase state by parameter and store state
</span><span class="boring">            state += parameter;
</span><span class="boring">            action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">            // Update label with new state
</span><span class="boring">            label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">        })
</span><span class="boring">        .build();
</span><span class="boring">    window.add_action_entries([action_count]);
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Actionable widgets are also easily accessible through the interface builder.
As usual, we build up the window via a composite template.
Within the template we can then set the "action-name" and "action-target" properties.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/5/resources/window.ui">listings/actions/5/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkBox" id="gtk_box"&gt;
        &lt;property name="orientation"&gt;vertical&lt;/property&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;
        &lt;property name="spacing"&gt;12&lt;/property&gt;
        &lt;property name="halign"&gt;center&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkButton" id="button"&gt;
            &lt;property name="label"&gt;Press me!&lt;/property&gt;
            &lt;property name="action-name"&gt;win.count&lt;/property&gt;
            &lt;property name="action-target"&gt;1&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class="GtkLabel" id="label"&gt;
            &lt;property name="label"&gt;Counter: 0&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>We will connect the actions and add them to the window in the <code>Window::setup_actions</code> method.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/5/window/mod.rs">listings/actions/5/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::ActionEntry;
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span>impl Window {
    pub fn new(app: &amp;Application) -&gt; Self {
        // Create new window
        Object::builder().property("application", app).build()
    }

    fn setup_actions(&amp;self) {
        // Add stateful action "count" to `window` taking an integer as parameter
        let original_state = 0;
        let action_count = ActionEntry::builder("count")
            .parameter_type(Some(&amp;i32::static_variant_type()))
            .state(original_state.to_variant())
            .activate(move |window: &amp;Self, action, parameter| {
                // Get state
                let mut state = action
                    .state()
                    .expect("Could not get state.")
                    .get::&lt;i32&gt;()
                    .expect("The variant needs to be of type `i32`.");

                // Get parameter
                let parameter = parameter
                    .expect("Could not get parameter.")
                    .get::&lt;i32&gt;()
                    .expect("The variant needs to be of type `i32`.");

                // Increase state by parameter and store state
                state += parameter;
                action.set_state(&amp;state.to_variant());

                // Update label with new state
                window.imp().label.set_label(&amp;format!("Counter: {state}"));
            })
            .build();
        self.add_action_entries([action_count]);
    }
}</code></pre>
<p>Finally, <code>setup_actions</code> will be called within <code>constructed</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/5/window/imp.rs">listings/actions/5/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CompositeTemplate, Label};
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/example/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub label: TemplateChild&lt;Label&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        // Call "constructed" on parent
        self.parent_constructed();

        // Add actions
        self.obj().setup_actions();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>This app behaves the same as our previous example, but it will make it simpler for us to add a menu in the following section.</p>
<h2 id="menus"><a class="header" href="#menus">Menus</a></h2>
<p>If you want to create a <a href="https://developer.gnome.org/hig/patterns/controls/menus.html">menu</a>, you have to use actions, and you will want to use the interface builder.
Typically, a menu entry has an action fitting one of these three descriptions:</p>
<ul>
<li>no parameter and no state, or</li>
<li>no parameter and boolean state, or</li>
<li>string parameter and string state.</li>
</ul>
<p>Let's modify our small app to demonstrate these cases.
First, we extend <code>setup_actions</code>.
For the action without parameter or state, we can use the pre-defined "window.close" action.
Therefore, we don't have to add anything here.</p>
<p>With the action "button-frame", we manipulate the "has-frame" property of <code>button</code>.
Here, the convention is that actions with no parameter and boolean state should behave like toggle actions.
This means that the caller can expect the boolean state to toggle after activating the action. Luckily for us, that is the default behavior for <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.PropertyAction.html"><code>gio::PropertyAction</code></a> with a boolean property.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/6/window/mod.rs">listings/actions/6/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{ActionEntry, PropertyAction};
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, Orientation};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Add stateful action "count" to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = ActionEntry::builder("count")
</span><span class="boring">            .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">            .state(original_state.to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get state
</span><span class="boring">                let mut state = action
</span><span class="boring">                    .state()
</span><span class="boring">                    .expect("Could not get state.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Increase state by parameter and store state
</span><span class="boring">                state += parameter;
</span><span class="boring">                action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">                // Update label with new state
</span><span class="boring">                window.imp().label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">            })
</span><span class="boring">            .build();
</span>        // Add property action "button-frame" to `window`
        let button = self.imp().button.get();
        let action_button_frame =
            PropertyAction::new("button-frame", &amp;button, "has-frame");
        self.add_action(&amp;action_button_frame);
<span class="boring">
</span><span class="boring">        // Add stateful action "orientation" to `window` taking a string as parameter
</span><span class="boring">        let action_orientation = ActionEntry::builder("orientation")
</span><span class="boring">            .parameter_type(Some(&amp;String::static_variant_type()))
</span><span class="boring">            .state("Vertical".to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;String&gt;()
</span><span class="boring">                    .expect("The value needs to be of type `String`.");
</span><span class="boring">
</span><span class="boring">                let orientation = match parameter.as_str() {
</span><span class="boring">                    "Horizontal" =&gt; Orientation::Horizontal,
</span><span class="boring">                    "Vertical" =&gt; Orientation::Vertical,
</span><span class="boring">                    _ =&gt; unreachable!(),
</span><span class="boring">                };
</span><span class="boring">
</span><span class="boring">                // Set orientation and save state
</span><span class="boring">                window.imp().gtk_box.set_orientation(orientation);
</span><span class="boring">                action.set_state(&amp;parameter.to_variant());
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        self.add_action_entries([action_count, action_orientation]);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<blockquote>
<p>A <code>PropertyAction</code> is useful when you need an action that manipulates the property of a GObject.
The property then acts as the state of the action.
As mentioned above, if the property is a boolean the action has no parameter and toggles the property on activation.
In all other cases, the action has a parameter of the same type as the property.
When activating the action, the property gets set to the same value as the parameter of the action.</p>
</blockquote>
<p>Finally, we add "win.orientation", an action with string parameter and string state.
This action can be used to change the orientation of <code>gtk_box</code>.
Here the convention is that the state should be set to the given parameter.
We don't need the action state to implement orientation switching, however it is useful for making the menu display the current orientation.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/6/window/mod.rs">listings/actions/6/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{ActionEntry, PropertyAction};
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, Orientation};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Add stateful action "count" to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = ActionEntry::builder("count")
</span><span class="boring">            .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">            .state(original_state.to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get state
</span><span class="boring">                let mut state = action
</span><span class="boring">                    .state()
</span><span class="boring">                    .expect("Could not get state.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Increase state by parameter and store state
</span><span class="boring">                state += parameter;
</span><span class="boring">                action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">                // Update label with new state
</span><span class="boring">                window.imp().label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        // Add property action "button-frame" to `window`
</span><span class="boring">        let button = self.imp().button.get();
</span><span class="boring">        let action_button_frame =
</span><span class="boring">            PropertyAction::new("button-frame", &amp;button, "has-frame");
</span><span class="boring">        self.add_action(&amp;action_button_frame);
</span><span class="boring">
</span>        // Add stateful action "orientation" to `window` taking a string as parameter
        let action_orientation = ActionEntry::builder("orientation")
            .parameter_type(Some(&amp;String::static_variant_type()))
            .state("Vertical".to_variant())
            .activate(move |window: &amp;Self, action, parameter| {
                // Get parameter
                let parameter = parameter
                    .expect("Could not get parameter.")
                    .get::&lt;String&gt;()
                    .expect("The value needs to be of type `String`.");

                let orientation = match parameter.as_str() {
                    "Horizontal" =&gt; Orientation::Horizontal,
                    "Vertical" =&gt; Orientation::Vertical,
                    _ =&gt; unreachable!(),
                };

                // Set orientation and save state
                window.imp().gtk_box.set_orientation(orientation);
                action.set_state(&amp;parameter.to_variant());
            })
            .build();
        self.add_action_entries([action_count, action_orientation]);
<span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Even though <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Menu.html"><code>gio::Menu</code></a> can also be created with the bindings, the most convenient way is to use the interface builder for that.
We do that by adding the menu in front of the template.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/6/resources/window.ui">listings/actions/6/resources/window.ui</a></p>
<pre><code class="language-diff"> &lt;?xml version="1.0" encoding="UTF-8"?&gt;
 &lt;interface&gt;
+  &lt;menu id="main-menu"&gt;
+    &lt;item&gt;
+      &lt;attribute name="label" translatable="yes"&gt;_Close window&lt;/attribute&gt;
+      &lt;attribute name="action"&gt;window.close&lt;/attribute&gt;
+    &lt;/item&gt;
+    &lt;item&gt;
+      &lt;attribute name="label" translatable="yes"&gt;_Toggle button frame&lt;/attribute&gt;
+      &lt;attribute name="action"&gt;win.button-frame&lt;/attribute&gt;
+    &lt;/item&gt;
+    &lt;section&gt;
+      &lt;attribute name="label" translatable="yes"&gt;Orientation&lt;/attribute&gt;
+      &lt;item&gt;
+        &lt;attribute name="label" translatable="yes"&gt;_Horizontal&lt;/attribute&gt;
+        &lt;attribute name="action"&gt;win.orientation&lt;/attribute&gt;
+        &lt;attribute name="target"&gt;Horizontal&lt;/attribute&gt;
+      &lt;/item&gt;
+      &lt;item&gt;
+        &lt;attribute name="label" translatable="yes"&gt;_Vertical&lt;/attribute&gt;
+        &lt;attribute name="action"&gt;win.orientation&lt;/attribute&gt;
+        &lt;attribute name="target"&gt;Vertical&lt;/attribute&gt;
+      &lt;/item&gt;
+    &lt;/section&gt;
+  &lt;/menu&gt;
   &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
     &lt;property name="title"&gt;My GTK App&lt;/property&gt;
+    &lt;property name="width-request"&gt;360&lt;/property&gt;
+    &lt;child type="titlebar"&gt;
+      &lt;object class="GtkHeaderBar"&gt;
+        &lt;child type ="end"&gt;
+          &lt;object class="GtkMenuButton"&gt;
+            &lt;property name="icon-name"&gt;open-menu-symbolic&lt;/property&gt;
+            &lt;property name="menu-model"&gt;main-menu&lt;/property&gt;
+          &lt;/object&gt;
+        &lt;/child&gt;
+      &lt;/object&gt;
+    &lt;/child&gt;
     &lt;child&gt;
       &lt;object class="GtkBox" id="gtk_box"&gt;
         &lt;property name="orientation"&gt;vertical&lt;/property&gt;
</code></pre>
<p>Since we connect the menu to the <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.MenuButton.html"><code>gtk::MenuButton</code></a> via the <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.MenuButton.html#menu-model">menu-model</a> property, the <code>Menu</code> is expected to be a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.PopoverMenu.html"><code>gtk::PopoverMenu</code></a>.
The <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.PopoverMenu.html">documentation</a> for <code>PopoverMenu</code> also explains its <code>xml</code> syntax for the interface builder.</p>
<p>Also note how we specified the target:</p>
<pre><code class="language-xml">&lt;attribute name="target"&gt;Horizontal&lt;/attribute&gt;
</code></pre>
<p>String is the default type of the target which is why we did not have to specify a type.
With targets of other types you need to manually specify the correct <a href="https://docs.gtk.org/glib/gvariant-format-strings.html">GVariant format string</a>.
For example, an <code>i32</code> variable with value "5" would correspond to this:</p>
<pre><code class="language-xml">&lt;attribute name="target" type="i"&gt;5&lt;/attribute&gt;
</code></pre>
<p>This is how the app looks in action:</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/actions_menu.webm" type="video/webm">
  <p>A video which now also shows the menu</p>
 </video>
</div>
<blockquote>
<p>We changed the icon of the <code>MenuButton</code> by setting its property "icon-name" to "open-menu-symbolic".
You can find more icons with the <a href="https://flathub.org/apps/org.gnome.design.IconLibrary">Icon Library</a>.
They can be embedded with <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Resource.html"><code>gio::Resource</code></a> and then be referenced within the composite templates (or other places).</p>
</blockquote>
<h2 id="settings"><a class="header" href="#settings">Settings</a></h2>
<p>The menu entries nicely display the state of our stateful actions, but after the app is closed, all changes to that state are lost.
As usual, we solve this problem with <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Settings.html"><code>gio::Settings</code></a>.
First we create a schema with settings corresponding to the stateful actions we created before.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/7/org.gtk_rs.Actions7.gschema.xml">listings/actions/7/org.gtk_rs.Actions7.gschema.xml</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;schemalist&gt;
  &lt;schema id="org.gtk_rs.Actions7" path="/org/gtk_rs/Actions7/"&gt;
    &lt;key name="button-frame" type="b"&gt;
      &lt;default&gt;true&lt;/default&gt;
      &lt;summary&gt;Whether the button has a frame&lt;/summary&gt;
    &lt;/key&gt;
    &lt;key name="orientation" type="s"&gt;
      &lt;choices&gt;
        &lt;choice value='Horizontal'/&gt;
        &lt;choice value='Vertical'/&gt;
      &lt;/choices&gt;
      &lt;default&gt;'Vertical'&lt;/default&gt;
      &lt;summary&gt;Orientation of GtkBox&lt;/summary&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
</code></pre>
<p>Again, we install the schema as described in the settings <a href="./settings.html">chapter</a>.
Then we add the settings to <code>imp::Window</code>.
Since <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Settings.html"><code>gio::Settings</code></a> does not implement <code>Default</code>, we wrap it in a <a href="https://doc.rust-lang.org/std/cell/struct.OnceCell.html"><code>std::cell::OnceCell</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/7/window/imp.rs">listings/actions/7/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Button, CompositeTemplate, Label};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/example/window.ui")]
pub struct Window {
    #[template_child]
    pub gtk_box: TemplateChild&lt;gtk::Box&gt;,
    #[template_child]
    pub button: TemplateChild&lt;Button&gt;,
    #[template_child]
    pub label: TemplateChild&lt;Label&gt;,
    pub settings: OnceCell&lt;Settings&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">        obj.bind_settings();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Now we create functions to make it easier to access settings.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/7/window/mod.rs">listings/actions/7/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{ActionEntry, Settings};
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, Orientation};
</span><span class="boring">
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_settings(&amp;self) {
        let settings = Settings::new(APP_ID);
        self.imp()
            .settings
            .set(settings)
            .expect("`settings` should not be set before calling `setup_settings`.");
    }

    fn settings(&amp;self) -&gt; &amp;Settings {
        self.imp()
            .settings
            .get()
            .expect("`settings` should be set in `setup_settings`.")
    }
<span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Add stateful action "count" to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = ActionEntry::builder("count")
</span><span class="boring">            .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">            .state(original_state.to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get state
</span><span class="boring">                let mut state = action
</span><span class="boring">                    .state()
</span><span class="boring">                    .expect("Could not get state.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Increase state by parameter and store state
</span><span class="boring">                state += parameter;
</span><span class="boring">                action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">                // Update label with new state
</span><span class="boring">                window.imp().label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        self.add_action_entries([action_count]);
</span><span class="boring">
</span><span class="boring">        // Create action from key "button-frame" and add to action group "win"
</span><span class="boring">        let action_button_frame = self.settings().create_action("button-frame");
</span><span class="boring">        self.add_action(&amp;action_button_frame);
</span><span class="boring">
</span><span class="boring">        // Create action from key "orientation" and add to action group "win"
</span><span class="boring">        let action_orientation = self.settings().create_action("orientation");
</span><span class="boring">        self.add_action(&amp;action_orientation);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn bind_settings(&amp;self) {
</span><span class="boring">        // Bind setting "button-frame" to "has-frame" property of `button`
</span><span class="boring">        let button = self.imp().button.get();
</span><span class="boring">        self.settings()
</span><span class="boring">            .bind("button-frame", &amp;button, "has-frame")
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Bind setting "orientation" to "orientation" property of `button`
</span><span class="boring">        let gtk_box = self.imp().gtk_box.get();
</span><span class="boring">        self.settings()
</span><span class="boring">            .bind("orientation", &amp;gtk_box, "orientation")
</span><span class="boring">            .mapping(|variant, _| {
</span><span class="boring">                let orientation = variant
</span><span class="boring">                    .get::&lt;String&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `String`.");
</span><span class="boring">
</span><span class="boring">                let orientation = match orientation.as_str() {
</span><span class="boring">                    "Horizontal" =&gt; Orientation::Horizontal,
</span><span class="boring">                    "Vertical" =&gt; Orientation::Vertical,
</span><span class="boring">                    _ =&gt; unreachable!(),
</span><span class="boring">                };
</span><span class="boring">
</span><span class="boring">                Some(orientation.to_value())
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Creating stateful actions from setting entries is so common that <code>Settings</code> provides a method for that exact purpose.
We create actions with the<a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/prelude/trait.SettingsExt.html#tymethod.create_action"> <code>create_action</code></a> method and then add them to the action group of our window.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/7/window/mod.rs">listings/actions/7/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{ActionEntry, Settings};
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, Orientation};
</span><span class="boring">
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Add stateful action "count" to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = ActionEntry::builder("count")
</span><span class="boring">            .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">            .state(original_state.to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get state
</span><span class="boring">                let mut state = action
</span><span class="boring">                    .state()
</span><span class="boring">                    .expect("Could not get state.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Increase state by parameter and store state
</span><span class="boring">                state += parameter;
</span><span class="boring">                action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">                // Update label with new state
</span><span class="boring">                window.imp().label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        self.add_action_entries([action_count]);
</span><span class="boring">
</span>        // Create action from key "button-frame" and add to action group "win"
        let action_button_frame = self.settings().create_action("button-frame");
        self.add_action(&amp;action_button_frame);

        // Create action from key "orientation" and add to action group "win"
        let action_orientation = self.settings().create_action("orientation");
        self.add_action(&amp;action_orientation);
<span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn bind_settings(&amp;self) {
</span><span class="boring">        // Bind setting "button-frame" to "has-frame" property of `button`
</span><span class="boring">        let button = self.imp().button.get();
</span><span class="boring">        self.settings()
</span><span class="boring">            .bind("button-frame", &amp;button, "has-frame")
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Bind setting "orientation" to "orientation" property of `button`
</span><span class="boring">        let gtk_box = self.imp().gtk_box.get();
</span><span class="boring">        self.settings()
</span><span class="boring">            .bind("orientation", &amp;gtk_box, "orientation")
</span><span class="boring">            .mapping(|variant, _| {
</span><span class="boring">                let orientation = variant
</span><span class="boring">                    .get::&lt;String&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `String`.");
</span><span class="boring">
</span><span class="boring">                let orientation = match orientation.as_str() {
</span><span class="boring">                    "Horizontal" =&gt; Orientation::Horizontal,
</span><span class="boring">                    "Vertical" =&gt; Orientation::Vertical,
</span><span class="boring">                    _ =&gt; unreachable!(),
</span><span class="boring">                };
</span><span class="boring">
</span><span class="boring">                Some(orientation.to_value())
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Since actions from <code>create_action</code> follow the aforementioned conventions, we can keep further changes to a minimum.
The action "win.button-frame" toggles its state with each activation and the state of the "win.orientation" action follows the given parameter.</p>
<p>We still have to specify what should happen when the actions are activated though.
For the stateful actions, instead of adding callbacks to their "activate" signals, we bind the settings to properties we want to manipulate.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/7/window/mod.rs">listings/actions/7/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{ActionEntry, Settings};
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, Orientation};
</span><span class="boring">
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Add stateful action "count" to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = ActionEntry::builder("count")
</span><span class="boring">            .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">            .state(original_state.to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get state
</span><span class="boring">                let mut state = action
</span><span class="boring">                    .state()
</span><span class="boring">                    .expect("Could not get state.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Increase state by parameter and store state
</span><span class="boring">                state += parameter;
</span><span class="boring">                action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">                // Update label with new state
</span><span class="boring">                window.imp().label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        self.add_action_entries([action_count]);
</span><span class="boring">
</span><span class="boring">        // Create action from key "button-frame" and add to action group "win"
</span><span class="boring">        let action_button_frame = self.settings().create_action("button-frame");
</span><span class="boring">        self.add_action(&amp;action_button_frame);
</span><span class="boring">
</span><span class="boring">        // Create action from key "orientation" and add to action group "win"
</span><span class="boring">        let action_orientation = self.settings().create_action("orientation");
</span><span class="boring">        self.add_action(&amp;action_orientation);
</span><span class="boring">    }
</span><span class="boring">
</span>    fn bind_settings(&amp;self) {
        // Bind setting "button-frame" to "has-frame" property of `button`
        let button = self.imp().button.get();
        self.settings()
            .bind("button-frame", &amp;button, "has-frame")
            .build();

        // Bind setting "orientation" to "orientation" property of `button`
        let gtk_box = self.imp().gtk_box.get();
        self.settings()
            .bind("orientation", &amp;gtk_box, "orientation")
            .mapping(|variant, _| {
                let orientation = variant
                    .get::&lt;String&gt;()
                    .expect("The variant needs to be of type `String`.");

                let orientation = match orientation.as_str() {
                    "Horizontal" =&gt; Orientation::Horizontal,
                    "Vertical" =&gt; Orientation::Vertical,
                    _ =&gt; unreachable!(),
                };

                Some(orientation.to_value())
            })
            .build();
    }
<span class="boring">}</span></code></pre>
<p>Finally, we make sure that <code>bind_settings</code> is called within <code>constructed</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/7/window/imp.rs">listings/actions/7/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Button, CompositeTemplate, Label};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/example/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub gtk_box: TemplateChild&lt;gtk::Box&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub button: TemplateChild&lt;Button&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub label: TemplateChild&lt;Label&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        // Call "constructed" on parent
        self.parent_constructed();

        // Setup
        let obj = self.obj();
        obj.setup_settings();
        obj.setup_actions();
        obj.bind_settings();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Actions are extremely powerful, and we are only scratching the surface here.
If you want to learn more about them, the <a href="https://developer.gnome.org/documentation/tutorials/actions.html">GNOME developer documentation</a> is a good place to start.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manipulating-state-of-to-do-app"><a class="header" href="#manipulating-state-of-to-do-app">Manipulating State of To-Do App</a></h1>
<h2 id="filtering-tasks"><a class="header" href="#filtering-tasks">Filtering Tasks</a></h2>
<p>Now it is time to continue working on our To-Do app.
One nice feature to add would be filtering of the tasks.
What a chance to use our newly gained knowledge of actions!
Using actions, we can access the filter via the menu as well as via keyboard shortcuts.
This is how we want this to work in the end:</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_2_animation.webm" type="video/webm">
  <p>A video which shows a more featureful To-Do app/p>
 </video>
</div>
<p>Note that the screencast also shows a button with label "Clear" which will remove all done tasks.
This will come in handy when we later make the app preserve the tasks between sessions.</p>
<p>Let's start by adding a menu and a header bar to <code>window.ui</code>.
After reading the <a href="actions.html">actions</a> chapter the added code should feel familiar.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/resources/window.ui">listings/todo/2/resources/window.ui</a></p>
<pre><code class="language-diff"> &lt;?xml version="1.0" encoding="UTF-8"?&gt;
 &lt;interface&gt;
+  &lt;menu id="main-menu"&gt;
+    &lt;submenu&gt;
+      &lt;attribute name="label" translatable="yes"&gt;_Filter&lt;/attribute&gt;
+      &lt;item&gt;
+        &lt;attribute name="label" translatable="yes"&gt;_All&lt;/attribute&gt;
+        &lt;attribute name="action"&gt;win.filter&lt;/attribute&gt;
+        &lt;attribute name="target"&gt;All&lt;/attribute&gt;
+      &lt;/item&gt;
+      &lt;item&gt;
+        &lt;attribute name="label" translatable="yes"&gt;_Open&lt;/attribute&gt;
+        &lt;attribute name="action"&gt;win.filter&lt;/attribute&gt;
+        &lt;attribute name="target"&gt;Open&lt;/attribute&gt;
+      &lt;/item&gt;
+      &lt;item&gt;
+        &lt;attribute name="label" translatable="yes"&gt;_Done&lt;/attribute&gt;
+        &lt;attribute name="action"&gt;win.filter&lt;/attribute&gt;
+        &lt;attribute name="target"&gt;Done&lt;/attribute&gt;
+      &lt;/item&gt;
+    &lt;/submenu&gt;
+    &lt;item&gt;
+      &lt;attribute name="label" translatable="yes"&gt;_Remove Done Tasks&lt;/attribute&gt;
+      &lt;attribute name="action"&gt;win.remove-done-tasks&lt;/attribute&gt;
+    &lt;/item&gt;
+    &lt;item&gt;
+      &lt;attribute name="label" translatable="yes"&gt;_Keyboard Shortcuts&lt;/attribute&gt;
+      &lt;attribute name="action"&gt;win.show-help-overlay&lt;/attribute&gt;
+    &lt;/item&gt;
+  &lt;/menu&gt;
   &lt;template class="TodoWindow" parent="GtkApplicationWindow"&gt;
     &lt;property name="width-request"&gt;360&lt;/property&gt;
     &lt;property name="title" translatable="yes"&gt;To-Do&lt;/property&gt;
+    &lt;child type="titlebar"&gt;
+      &lt;object class="GtkHeaderBar"&gt;
+        &lt;child type="end"&gt;
+          &lt;object class="GtkMenuButton" id="menu_button"&gt;
+            &lt;property name="icon-name"&gt;open-menu-symbolic&lt;/property&gt;
+            &lt;property name="menu-model"&gt;main-menu&lt;/property&gt;
+          &lt;/object&gt;
+        &lt;/child&gt;
+      &lt;/object&gt;
+    &lt;/child&gt;
</code></pre>
<p>Then, we create a settings schema.
Again, the "filter" setting correspond to the stateful actions called by the menu.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/org.gtk_rs.Todo2.gschema.xml">listings/todo/2/org.gtk_rs.Todo2.gschema.xml</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;schemalist&gt;
  &lt;schema id="org.gtk_rs.Todo2" path="/org/gtk_rs/Todo2/"&gt;
    &lt;key name="filter" type="s"&gt;
      &lt;choices&gt;
        &lt;choice value='All'/&gt;
        &lt;choice value='Open'/&gt;
        &lt;choice value='Done'/&gt;
      &lt;/choices&gt;
      &lt;default&gt;'All'&lt;/default&gt;
      &lt;summary&gt;Filter of the tasks&lt;/summary&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
</code></pre>
<p>We install the schema as described in the settings <a href="./settings.html">chapter</a>
Then we add a reference to <code>settings</code> to <code>imp::Window</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/window/imp.rs">listings/todo/2/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListView};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/Todo2/window.ui")]
pub struct Window {
    #[template_child]
    pub entry: TemplateChild&lt;Entry&gt;,
    #[template_child]
    pub tasks_list: TemplateChild&lt;ListView&gt;,
    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
    pub settings: OnceCell&lt;Settings&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_factory();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Again, we create functions to make it easier to access settings.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/window/mod.rs">listings/todo/2/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, CustomFilter, FilterListModel, NoSelection,
</span><span class="boring">    SignalListItemFactory,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_settings(&amp;self) {
        let settings = Settings::new(APP_ID);
        self.imp()
            .settings
            .set(settings)
            .expect("`settings` should not be set before calling `setup_settings`.");
    }

    fn settings(&amp;self) -&gt; &amp;Settings {
        self.imp()
            .settings
            .get()
            .expect("`settings` should be set in `setup_settings`.")
    }
<span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter_state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We also add the methods <code>is_completed</code>, <code>task_data</code> and <code>from_task_data</code> to <code>TaskObject</code>.
We will make use of them in the following snippets.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/task_object/mod.rs">listings/todo/2/task_object/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct TaskObject(ObjectSubclass&lt;imp::TaskObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span>impl TaskObject {
    pub fn new(completed: bool, content: String) -&gt; Self {
        Object::builder()
            .property("completed", completed)
            .property("content", content)
            .build()
    }

    pub fn is_completed(&amp;self) -&gt; bool {
        self.imp().data.borrow().completed
    }

    pub fn task_data(&amp;self) -&gt; TaskData {
        self.imp().data.borrow().clone()
    }

    pub fn from_task_data(task_data: TaskData) -&gt; Self {
        Self::new(task_data.completed, task_data.content)
    }
}
<span class="boring">
</span><span class="boring">#[derive(Default, Clone, Serialize, Deserialize)]
</span><span class="boring">pub struct TaskData {
</span><span class="boring">    pub completed: bool,
</span><span class="boring">    pub content: String,
</span><span class="boring">}</span></code></pre>
<p>Similar to the previous chapter, we let <code>settings</code> create the action.
Then we add the newly created action "filter" to our window.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/window/mod.rs">listings/todo/2/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, CustomFilter, FilterListModel, NoSelection,
</span><span class="boring">    SignalListItemFactory,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter_state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_actions(&amp;self) {
        // Create action from key "filter" and add to action group "win"
        let action_filter = self.settings().create_action("filter");
        self.add_action(&amp;action_filter);
    }
<span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We also add an action which allows us to remove done tasks.
This time we use another method called <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/subclass/widget/trait.WidgetClassExt.html#method.install_action"><code>install_action</code></a>.
This method has a couple of limitation.
It can only be used when subclassing widgets, and it doesn't support stateful actions.
On the flipside, its usage is concise and it has a corresponding sister-method <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/subclass/widget/trait.WidgetClassExt.html#method.install_action_async"><code>install_action_async</code></a> which we will use in one of the future chapters.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/window/imp.rs">listings/todo/2/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListView};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo2/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListView&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "TodoWindow";
    type Type = super::Window;
    type ParentType = gtk::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();

        // Create action to remove done tasks and add to action group "win"
        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
            window.remove_done_tasks();
        });
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_factory();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>This is the implementation of <code>remove_done_tasks</code>.
We iterate through the <code>gio::ListStore</code> and remove all completed task objects.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/window/mod.rs">listings/todo/2/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, CustomFilter, FilterListModel, NoSelection,
</span><span class="boring">    SignalListItemFactory,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter_state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span>    fn remove_done_tasks(&amp;self) {
        let tasks = self.tasks();
        let mut position = 0;
        while let Some(item) = tasks.item(position) {
            // Get `TaskObject` from `glib::Object`
            let task_object = item
                .downcast_ref::&lt;TaskObject&gt;()
                .expect("The object needs to be of type `TaskObject`.");

            if task_object.is_completed() {
                tasks.remove(position);
            } else {
                position += 1;
            }
        }
    }
<span class="boring">}</span></code></pre>
<p>After activating the action "win.filter", the corresponding setting will be changed.
So we need a method which translates this setting into a filter that the <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.FilterListModel.html"><code>gtk::FilterListModel</code></a> understands.
The possible states are "All", "Open" and "Done".
We return <code>Some(filter)</code> for "Open" and "Done".
If the state is "All" nothing has to be filtered out, so we return <code>None</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/window/mod.rs">listings/todo/2/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, CustomFilter, FilterListModel, NoSelection,
</span><span class="boring">    SignalListItemFactory,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span>    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
        // Get filter_state from settings
        let filter_state: String = self.settings().get("filter");

        // Create custom filters
        let filter_open = CustomFilter::new(|obj| {
            // Get `TaskObject` from `glib::Object`
            let task_object = obj
                .downcast_ref::&lt;TaskObject&gt;()
                .expect("The object needs to be of type `TaskObject`.");

            // Only allow completed tasks
            !task_object.is_completed()
        });
        let filter_done = CustomFilter::new(|obj| {
            // Get `TaskObject` from `glib::Object`
            let task_object = obj
                .downcast_ref::&lt;TaskObject&gt;()
                .expect("The object needs to be of type `TaskObject`.");

            // Only allow done tasks
            task_object.is_completed()
        });

        // Return the correct filter
        match filter_state.as_str() {
            "All" =&gt; None,
            "Open" =&gt; Some(filter_open),
            "Done" =&gt; Some(filter_done),
            _ =&gt; unreachable!(),
        }
    }
<span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Now, we can set up the model.
We initialize <code>filter_model</code> with the state from the settings by calling the method <code>filter</code>.
Whenever the state of the key "filter" changes, we call the method <code>filter</code> again to get the updated <code>filter_model</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/window/mod.rs">listings/todo/2/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, CustomFilter, FilterListModel, NoSelection,
</span><span class="boring">    SignalListItemFactory,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter_state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_tasks(&amp;self) {
        // Create new model
        let model = gio::ListStore::new::&lt;TaskObject&gt;();

        // Get state and set model
        self.imp().tasks.replace(Some(model));

        // Wrap model with filter and selection and pass it to the list view
        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
        let selection_model = NoSelection::new(Some(filter_model.clone()));
        self.imp().tasks_list.set_model(Some(&amp;selection_model));

        // Filter model whenever the value of the key "filter" changes
        self.settings().connect_changed(
            Some("filter"),
            clone!(
                #[weak(rename_to = window)]
                self,
                #[weak]
                filter_model,
                move |_, _| {
                    filter_model.set_filter(window.filter().as_ref());
                }
            ),
        );
    }
<span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Then, we bind the shortcuts to their actions with <code>set_accels_for_action</code>.
Here as well, a detailed action name is used.
Since this has to be done at the application level, <code>setup_shortcuts</code> takes a <code>gtk::Application</code> as parameter.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/main.rs">listings/todo/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod task_object;
</span><span class="boring">mod task_row;
</span><span class="boring">mod utils;
</span><span class="boring">mod window;
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application};
</span><span class="boring">use window::Window;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Todo2";
</span><span class="boring">
</span>fn main() -&gt; glib::ExitCode {
    // Register and include resources
    gio::resources_register_include!("todo_2.gresource")
        .expect("Failed to register resources.");

    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to signals
    app.connect_startup(setup_shortcuts);
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

fn setup_shortcuts(app: &amp;Application) {
    app.set_accels_for_action("win.filter('All')", &amp;["&lt;Ctrl&gt;a"]);
    app.set_accels_for_action("win.filter('Open')", &amp;["&lt;Ctrl&gt;o"]);
    app.set_accels_for_action("win.filter('Done')", &amp;["&lt;Ctrl&gt;d"]);
}
<span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a new custom window and present it
</span><span class="boring">    let window = Window::new(app);
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Now that we created all these nice shortcuts we will want our users to find them.
We do that by creating a shortcut window.
Again we use an <code>ui</code> file to describe it, but here we don't want to use it as template for our custom widget.
Instead we instantiate a widget of the existing class <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ShortcutsWindow.html"><code>gtk::ShortcutsWindow</code></a> with it.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/resources/shortcuts.ui">listings/todo/2/resources/shortcuts.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;object class="GtkShortcutsWindow" id="help_overlay"&gt;
    &lt;property name="modal"&gt;True&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkShortcutsSection"&gt;
        &lt;property name="section-name"&gt;shortcuts&lt;/property&gt;
        &lt;property name="max-height"&gt;10&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkShortcutsGroup"&gt;
            &lt;property name="title" translatable="yes" context="shortcut window"&gt;General&lt;/property&gt;
            &lt;child&gt;
              &lt;object class="GtkShortcutsShortcut"&gt;
                &lt;property name="title" translatable="yes" context="shortcut window"&gt;Show shortcuts&lt;/property&gt;
                &lt;property name="action-name"&gt;win.show-help-overlay&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
            &lt;child&gt;
              &lt;object class="GtkShortcutsShortcut"&gt;
                &lt;property name="title" translatable="yes" context="shortcut window"&gt;Filter to show all tasks&lt;/property&gt;
                &lt;property name="action-name"&gt;win.filter('All')&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
            &lt;child&gt;
              &lt;object class="GtkShortcutsShortcut"&gt;
                &lt;property name="title" translatable="yes" context="shortcut window"&gt;Filter to show only open tasks&lt;/property&gt;
                &lt;property name="action-name"&gt;win.filter('Open')&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
            &lt;child&gt;
              &lt;object class="GtkShortcutsShortcut"&gt;
                &lt;property name="title" translatable="yes" context="shortcut window"&gt;Filter to show only completed tasks&lt;/property&gt;
                &lt;property name="action-name"&gt;win.filter('Done')&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/object&gt;
&lt;/interface&gt;
</code></pre>
<p>The entries can be organized with <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ShortcutsSection.html"><code>gtk::ShortcutsSection</code></a> and <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ShortcutsGroup.html"><code>gtk::ShortcutsGroup</code></a>.
If we specify the action name, we also don't have to repeat the keyboard accelerator.
<a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ShortcutsShortcut.html"><code>gtk::ShortcutsShortcut</code></a> looks it up on its own.</p>
<blockquote>
<p>Note the way we set <code>action-name</code> for <code>ShortcutsShortcut</code>.
Instead of using a separate property for the target, it takes a <em>detailed</em> action name.
Detailed names look like this: <code>action_group.action_name(target)</code>.
Formatting of the target depends on its type and is documented <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Action.html#method.parse_detailed_name">here</a>.
In particular, strings have to be enclosed single quotes as you can see in this example.</p>
</blockquote>
<p>Finally, we have to add the <code>shortcuts.ui</code> to our resources.
Note that we give it the alias <code>gtk/help-overlay.ui</code>.
We do that to take advantage of a convenience functionality documented <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Application.html#automatic-resources">here</a>.
It will look for a resource at <code>gtk/help-overlay.ui</code> which defines a <code>ShortcutsWindow</code> with id <code>help_overlay</code>.
If it can find one it will create a action <code>win.show-help-overlay</code> which will show the window and associate the shortcut <kbd>Ctrl</kbd> + <kbd>?</kbd> with this action.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/resources/resources.gresource.xml">listings/todo/2/resources/resources.gresource.xml</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;gresources&gt;
  &lt;gresource prefix="/org/gtk_rs/Todo2/"&gt;
    &lt;file compressed="true" preprocess="xml-stripblanks" alias="gtk/help-overlay.ui"&gt;shortcuts.ui&lt;/file&gt;
    &lt;file compressed="true" preprocess="xml-stripblanks"&gt;task_row.ui&lt;/file&gt;
    &lt;file compressed="true" preprocess="xml-stripblanks"&gt;window.ui&lt;/file&gt;
  &lt;/gresource&gt;
&lt;/gresources&gt;
</code></pre>
<div style="text-align:center"><img src="img/todo_2_shortcuts.png" alt="The shortcut window"/></div>
<h2 id="saving-and-restoring-tasks"><a class="header" href="#saving-and-restoring-tasks">Saving and Restoring Tasks</a></h2>
<p>Since we use <code>Settings</code>, our filter state will persist between sessions.
However, the tasks themselves will not.
Let us implement that.
We could store our tasks in <code>Settings</code>, but it would be inconvenient.
When it comes to serializing and deserializing nothing beats the crate <a href="https://lib.rs/crates/serde"><code>serde</code></a>.
Combined with <a href="https://lib.rs/crates/serde_json"><code>serde_json</code></a> we can save our tasks as serialized <a href="https://en.wikipedia.org/wiki/JSON">json</a> files.</p>
<p>First, we extend our <code>Cargo.toml</code> with the <code>serde</code> and <code>serde_json</code> crate.</p>
<pre><code>cargo add serde --features derive
cargo add serde_json
</code></pre>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/Cargo.toml">listings/Cargo.toml</a></p>
<pre><code class="language-toml">[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
</code></pre>
<p>Serde is a framework for serializing and deserializing Rust data structures.
The <code>derive</code> feature allows us to make our structures (de-)serializable with a single line of code.
We also use the <code>rc</code> feature so that Serde can deal with <code>std::rc::Rc</code> objects.
This is why we stored the data of <code>TodoObject</code> in a distinct <code>TodoData</code> structure.
Doing so allows us to derive <code>Serialize</code> and <code>Deserialize</code> for <code>TodoData</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/task_object/mod.rs">listings/todo/2/task_object/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct TaskObject(ObjectSubclass&lt;imp::TaskObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TaskObject {
</span><span class="boring">    pub fn new(completed: bool, content: String) -&gt; Self {
</span><span class="boring">        Object::builder()
</span><span class="boring">            .property("completed", completed)
</span><span class="boring">            .property("content", content)
</span><span class="boring">            .build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn is_completed(&amp;self) -&gt; bool {
</span><span class="boring">        self.imp().data.borrow().completed
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn task_data(&amp;self) -&gt; TaskData {
</span><span class="boring">        self.imp().data.borrow().clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn from_task_data(task_data: TaskData) -&gt; Self {
</span><span class="boring">        Self::new(task_data.completed, task_data.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Default, Clone, Serialize, Deserialize)]
pub struct TaskData {
    pub completed: bool,
    pub content: String,
}</code></pre>
<p>We plan to store our data as a file, so we create a utility function to provide a suitable file path for us.
We use <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/fn.user_config_dir.html"><code>glib::user_config_dir</code></a> to get the path to the config directory and create a new subdirectory for our app.
Then we return the file path.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/utils.rs">listings/todo/2/utils.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::path::PathBuf;
</span><span class="boring">
</span><span class="boring">use gtk::glib;
</span><span class="boring">
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span>pub fn data_path() -&gt; PathBuf {
    let mut path = glib::user_data_dir();
    path.push(APP_ID);
    std::fs::create_dir_all(&amp;path).expect("Could not create directory.");
    path.push("data.json");
    path
}</code></pre>
<p>We override the <code>close_request</code> virtual function to save the tasks when the window is closed.
To do so, we first iterate through all entries and store them in a <code>Vec</code>.
Then we serialize the <code>Vec</code> and store the data as a json file.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/window/imp.rs">listings/todo/2/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListView};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo2/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListView&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_factory();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span>// Trait shared by all windows
impl WindowImpl for Window {
    fn close_request(&amp;self) -&gt; glib::Propagation {
        // Store task data in vector
        let backup_data: Vec&lt;TaskData&gt; = self
            .obj()
            .tasks()
            .iter::&lt;TaskObject&gt;()
            .filter_map(Result::ok)
            .map(|task_object| task_object.task_data())
            .collect();

        // Save state to file
        let file = File::create(data_path()).expect("Could not create json file.");
        serde_json::to_writer(file, &amp;backup_data)
            .expect("Could not write data to json file");

        // Pass close request on to the parent
        self.parent_close_request()
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Let's it have a look into what a <code>Vec&lt;TaskData&gt;</code> will be serialized.
Note that <a href="https://docs.serde.rs/serde_json/fn.to_writer.html"><code>serde_json::to_writer</code></a> saves the data into a more concise, but also less readable way.
To create the equivalent but nicely formatted json below you can just replace <code>to_writer</code> with <a href="https://docs.serde.rs/serde_json/fn.to_writer_pretty.html"><code>serde_json::to_writer_pretty</code></a>.</p>
<p>Filename: data.json</p>
<pre><code class="language-json">[
  {
    "completed": true,
    "content": "Task Number Two"
  },
  {
    "completed": false,
    "content": "Task Number Five"
  },
  {
    "completed": true,
    "content": "Task Number Six"
  },
  {
    "completed": false,
    "content": "Task Number Seven"
  },
  {
    "completed": false,
    "content": "Task Number Eight"
  }
]
</code></pre>
<p>When we start the app, we will want to restore the saved data.
Let us add a <code>restore_data</code> method for that.
We make sure to handle the case where there is no data file there yet.
It might be the first time that we started the app and therefore there is no former session to restore.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/window/mod.rs">listings/todo/2/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, CustomFilter, FilterListModel, NoSelection,
</span><span class="boring">    SignalListItemFactory,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter_state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span>    fn restore_data(&amp;self) {
        if let Ok(file) = File::open(data_path()) {
            // Deserialize data from file to vector
            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
                "It should be possible to read `backup_data` from the json file.",
            );

            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
            let task_objects: Vec&lt;TaskObject&gt; = backup_data
                .into_iter()
                .map(TaskObject::from_task_data)
                .collect();

            // Insert restored objects into model
            self.tasks().extend_from_slice(&amp;task_objects);
        }
    }
<span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Finally, we make sure that everything is set up in <code>constructed</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/window/imp.rs">listings/todo/2/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListView};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo2/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListView&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        // Call "constructed" on parent
        self.parent_constructed();

        // Setup
        let obj = self.obj();
        obj.setup_settings();
        obj.setup_tasks();
        obj.restore_data();
        obj.setup_callbacks();
        obj.setup_factory();
        obj.setup_actions();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span></code></pre>
<p>Our To-Do app suddenly became much more useful.
Not only can we filter tasks, we also retain our tasks between sessions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="css"><a class="header" href="#css">CSS</a></h1>
<p>When you want to modify the style of your website, you use <a href="https://de.wikipedia.org/wiki/Cascading_Style_Sheets">CSS</a>.
Similarly, GTK supports its own variant of CSS in order to style your app.</p>
<blockquote>
<p>We will not explain every piece of syntax used in this chapter.
If you are new to CSS or just need a refresher, have a look at the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Syntax">MDN Web Docs</a>.</p>
</blockquote>
<p>Let's say we have a button and we want to set its font color to magenta.
Every type of widget has a corresponding CSS node.
In the case of <code>gtk::Button</code>, this node is called <code>button</code>.
Therefore, we create a <code>style.css</code> file with the following content:</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/1/style.css">listings/css/1/style.css</a></p>
<pre><code class="language-css">button {
  color: magenta;
}
</code></pre>
<p>Next, we need to load the CSS file in the startup step of the application.
As usual, the widgets are created during the "activate" step.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/1/main.rs">listings/css/1/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gdk::Display;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gdk, glib, Application, ApplicationWindow, Button, CssProvider};
</span><span class="boring">
</span>const APP_ID: &amp;str = "org.gtk_rs.Css1";

fn main() -&gt; glib::ExitCode {
    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to signals
    app.connect_startup(|_| load_css());
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

fn load_css() {
    // Load the CSS file and add it to the provider
    let provider = CssProvider::new();
    provider.load_from_string(include_str!("style.css"));

    // Add the provider to the default screen
    gtk::style_context_add_provider_for_display(
        &amp;Display::default().expect("Could not connect to a display."),
        &amp;provider,
        gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
    );
}

fn build_ui(app: &amp;Application) {
    // Create button
    let button = Button::builder()
        .label("Press me!")
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // Create a new window and present it
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .child(&amp;button)
        .build();
    window.present();
}</code></pre>
<p>When we now run the app, we notice that our button <em>and</em> the "close" button are magenta.
Probably not what we wanted, but that is what our CSS snippet does.
We did not specify for which button the rule should apply, so it was applied to both of them.</p>
<div style="text-align:center"><img src="img/css_1.png" alt="Window with magenta text"/></div>
<blockquote>
<p>The <code>GtkInspector</code> comes in quite handy (not only) when playing with CSS.
Make sure that the window of your app is focused and press <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>D</kbd>.
A window will pop up which lets you browse and even manipulate the state of your app.
Open the CSS view and override the button color with the following snippet.</p>
<pre><code class="language-css">button {
 color: blue;
}
</code></pre>
<p>With the pause button you can toggle whether your CSS code is active or not.</p>
</blockquote>
<h2 id="style-classes-applied-by-gtk"><a class="header" href="#style-classes-applied-by-gtk">Style Classes Applied by GTK</a></h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors">Class selectors</a> are one way to choose which specific elements a CSS rule applies to.
GTK adds style classes to many of its widgets, often depending on their content.
A <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Button.html#css-nodes"><code>gtk::Button</code></a>, for example, will get the <code>text-button</code> style class when its content is a label.
That is why we create a new CSS rule which only applies to <code>button</code> nodes with the style class <code>text_button</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/2/style.css">listings/css/2/style.css</a></p>
<pre><code class="language-css">button.text-button {
  color: magenta;
}
</code></pre>
<p>Now only the font of our button becomes magenta.</p>
<div style="text-align:center"><img src="img/css_2.png" alt="Now only the text of the button is magenta"/></div>
<h2 id="adding-your-own-style-class"><a class="header" href="#adding-your-own-style-class">Adding Your Own Style Class</a></h2>
<p>With <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.WidgetExt.html#tymethod.add_css_class"><code>add_css_class</code></a> we can also add our own style classes to widgets.
One use-case for this is when you want a rule to apply to a hand-picked set of widgets.
For example if we have two buttons, but want only one of them to have magenta font.
Relying on one of the style classes which GTK adds will not help since both will get the same ones.
Which is why we add the style class <code>button-1</code> to the first one.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/3/main.rs">listings/css/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gdk::Display;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gdk, glib, Application, ApplicationWindow, Button, CssProvider};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Css3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to signals
</span><span class="boring">    app.connect_startup(|_| load_css());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn load_css() {
</span><span class="boring">    // Load the CSS file and add it to the provider
</span><span class="boring">    let provider = CssProvider::new();
</span><span class="boring">    provider.load_from_string(include_str!("style.css"));
</span><span class="boring">
</span><span class="boring">    // Add the provider to the default screen
</span><span class="boring">    gtk::style_context_add_provider_for_display(
</span><span class="boring">        &amp;Display::default().expect("Could not connect to a display."),
</span><span class="boring">        &amp;provider,
</span><span class="boring">        gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create buttons
    let button_1 = Button::with_label("Press me!");
    let button_2 = Button::with_label("Press me!");

    button_1.add_css_class("button-1");
<span class="boring">
</span><span class="boring">    // Create `gtk_box` and add buttons
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a new window and present it
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Then, we create a CSS rule that applies to <code>button</code> nodes with the style class <code>button-1</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/3/style.css">listings/css/3/style.css</a></p>
<pre><code class="language-css">button.button-1 {
  color: magenta;
}
</code></pre>
<p>We can see that this way only the first button gets colored magenta.</p>
<div style="text-align:center"><img src="img/css_3.png" alt="Two buttons and only the left one has magenta font"/></div>
<h2 id="specifying-name-of-a-widget"><a class="header" href="#specifying-name-of-a-widget">Specifying Name of a Widget</a></h2>
<p>If you want that your rule only applies to a single widget, matching with style classes can be fine.
Ideally however, you would give the widget a name and match with that name instead.
This way your intentions are more clear, compared to matching with style classes that can apply to multiple widgets.</p>
<p>Again, we have two buttons but want to color only one of them magenta.
We set the name of the first one with <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.WidgetExt.html#tymethod.set_widget_name"><code>set_widget_name</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/4/main.rs">listings/css/4/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gdk::Display;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gdk, glib, Application, ApplicationWindow, Button, CssProvider};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Css4";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to signals
</span><span class="boring">    app.connect_startup(|_| load_css());
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn load_css() {
</span><span class="boring">    // Load the CSS file and add it to the provider
</span><span class="boring">    let provider = CssProvider::new();
</span><span class="boring">    provider.load_from_string(include_str!("style.css"));
</span><span class="boring">
</span><span class="boring">    // Add the provider to the default screen
</span><span class="boring">    gtk::style_context_add_provider_for_display(
</span><span class="boring">        &amp;Display::default().expect("Could not connect to a display."),
</span><span class="boring">        &amp;provider,
</span><span class="boring">        gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create buttons
    let button_1 = Button::with_label("Press me!");
    let button_2 = Button::with_label("Press me!");

    button_1.set_widget_name("button-1");
<span class="boring">
</span><span class="boring">    // Create `gtk_box` and add buttons
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a new window and present it
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>Then, create a CSS rule that applies to <code>button</code> nodes with the name <code>button-1</code>.
The name is specified after the <code>#</code> symbol.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/4/style.css">listings/css/4/style.css</a></p>
<pre><code class="language-css">button#button-1 {
  color: magenta;
}
</code></pre>
<p>Again, the style rule only applies to the first button.</p>
<div style="text-align:center"><img src="img/css_4.png" alt="Two buttons and only the left one has magenta font"/></div>
<h2 id="css-rules-provided-by-gtk"><a class="header" href="#css-rules-provided-by-gtk">CSS Rules Provided by GTK</a></h2>
<p>Certain styles are common enough that GTK provides CSS rules for them.
For example, if you want to indicate that your button leads to a destructive or suggested action you don't have to provide your own CSS rules.
All you have to do is to add "destructive-action" or "suggested-action" style class to your button.
Most widgets will document these rules in their documentation under <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Button.html#css-nodes">CSS nodes</a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/5/main.rs">listings/css/5/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Css5";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to signals
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span>    // Create buttons
    let button_1 = Button::with_label("Destructive");
    let button_2 = Button::with_label("Suggested");

    button_1.add_css_class("destructive-action");
    button_2.add_css_class("suggested-action");
<span class="boring">
</span><span class="boring">    // Create `gtk_box` and add buttons
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .spacing(6)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button_1);
</span><span class="boring">    gtk_box.append(&amp;button_2);
</span><span class="boring">
</span><span class="boring">    // Create a new window and present it
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<div style="text-align:center"><img src="img/css_5.png" alt="The left button is red, the right one is blue"/></div>
<h2 id="interface-builder"><a class="header" href="#interface-builder">Interface Builder</a></h2>
<p>We can also add style classes with the interface builder.
Just add the <code>&lt;style&gt;</code> element to your widget.
The <code>&lt;style&gt;</code> element is documented together with <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Widget.html#gtkwidget-as-gtkbuildable"><code>gtk::Widget</code></a>.
Adding again destructive and suggested buttons, would then look like this:</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/6/window/window.ui">listings/css/6/window/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title" translatable="yes"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkBox"&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;
        &lt;property name="spacing"&gt;6&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkButton"&gt;
            &lt;property name="label"&gt;Destructive&lt;/property&gt;
            &lt;style&gt;
              &lt;class name="destructive-action"/&gt;
            &lt;/style&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class="GtkButton"&gt;
            &lt;property name="label"&gt;Suggested&lt;/property&gt;
            &lt;style&gt;
              &lt;class name="suggested-action"/&gt;
            &lt;/style&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<h2 id="pseudo-classes"><a class="header" href="#pseudo-classes">Pseudo-classes</a></h2>
<p>Sometimes you want your CSS rules to apply under even more precise conditions than style classes allow.
That is where <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes">pseudo-classes</a> come in.
Let's use a single button with name <code>button-1</code> to demonstrate this concept.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/7/window/window.ui">listings/css/7/window/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title" translatable="yes"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkButton"&gt;
        &lt;property name="label"&gt;Hover over me!&lt;/property&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;
        &lt;property name="name"&gt;button-1&lt;/property&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>By adding the pseudo-class <code>hover</code>, we say that we want this rule to only apply to a <code>button</code> node with name <code>button-1</code> when hovering over it with the mouse pointer.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/7/style.css">listings/css/7/style.css</a></p>
<pre><code class="language-css">button#button-1:hover {
  color: magenta;
  background: yellow;
}
</code></pre>
<p>If we now hover over the button, we see that over the span of one second its background turns yellow and its font turns magenta.
After we removed the cursor, the button returns to its original state.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/css_6.webm" type="video/webm">
  <p>A video which shows that hovering over one button makes its background yellow and text red</p>
 </video>
</div>
<h2 id="nodes"><a class="header" href="#nodes">Nodes</a></h2>
<p>In the previous examples, a widget always corresponded to a single CSS node.
This is not always the case.
For example, <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.MenuButton.html"><code>gtk::MenuButton</code></a> has multiple CSS nodes.
Let's see how that works.</p>
<p>First, we create a single <code>MenuButton</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/8/window/window.ui">listings/css/8/window/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title" translatable="yes"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkMenuButton"&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>You can make a <code>MenuButton</code> show an icon or a label.
If you choose to do neither of those, as we currently do, it shows an image displaying an arrow.</p>
<p>An inheritance tree of <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.MenuButton.html#css-nodes">CSS nodes</a> displays this situation:</p>
<pre><code>menubutton
╰── button.toggle
    ╰── &lt;content&gt;
         ╰── [arrow]
</code></pre>
<p>We see that the <code>menubutton</code> node has children, which themselves have children and attached style classes.
Now we know that we have to add a CSS rule that applies to the <code>arrow</code> node, which is a descendant of <code>menubutton</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/css/8/style.css">listings/css/8/style.css</a></p>
<pre><code class="language-css">menubutton arrow {
  color: magenta;
}
</code></pre>
<p>Indeed, we get a <code>MenuButton</code> with a magenta arrow.</p>
<div style="text-align:center"><img src="img/css_8.png" alt="Button with a magenta symbol in it"/></div>
<h2 id="set-css-name-and-use-exported-colors"><a class="header" href="#set-css-name-and-use-exported-colors">Set CSS Name and Use Exported Colors</a></h2>
<p>We already learned how to give an instance of a widget a name with pseudo-classes.
But what if we have a custom widget and we want to reference all instances of it?
Let's see how to deal with this situation by messing with our To-Do app once more.</p>
<p>The class <code>TaskRow</code> inherits from <code>gtk::Box</code>, so we could just match for the node <code>box</code>.
However, in that case we would also match with other instance of <code>gtk::Box</code>.
What we will want to do instead is to give <code>TaskRow</code> its own CSS name.
When calling <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/subclass/widget/trait.WidgetClassExt.html#method.set_css_name"><code>set_css_name</code> </a>, we change the name of the CSS node of the widget class.
In our case, the widget <code>TaskRow</code> then corresponds to the node <code>task-row</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/3/task_row/imp.rs">listings/todo/3/task_row/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">use glib::Binding;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CheckButton, CompositeTemplate, Label};
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(Default, CompositeTemplate)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo3/task_row.ui")]
</span><span class="boring">pub struct TaskRow {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub completed_button: TemplateChild&lt;CheckButton&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub content_label: TemplateChild&lt;Label&gt;,
</span><span class="boring">    // Vector holding the bindings to properties of `TaskObject`
</span><span class="boring">    pub bindings: RefCell&lt;Vec&lt;Binding&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for TaskRow {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "TodoTaskRow";
    type Type = super::TaskRow;
    type ParentType = gtk::Box;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();
        klass.set_css_name("task-row");
    }

    fn instance_init(obj: &amp;glib::subclass::InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for TaskRow {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for TaskRow {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all boxes
</span><span class="boring">impl BoxImpl for TaskRow {}</span></code></pre>
<p>What to do with the new node name now?
Let's change the background color once more but this time with a twist.
We are going to use the named color <code>success_color</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/3/resources/style.css">listings/todo/3/resources/style.css</a></p>
<pre><code class="language-css">task-row {
  background-color: @success_color;
}
</code></pre>
<p>The <code>Default</code> stylesheet of GTK provides pre-defined colors for various use-cases.
As of this writing, these exported colors can only be found in its <a href="https://gitlab.gnome.org/GNOME/gtk/-/blob/b2c227e9c57839a2a4e24462a71ae0bad9a95264/gtk/theme/Default/_colors-public.scss">source code</a>.</p>
<p>There we find the color <code>success_color</code>, which in real scenarios should be used to indicate success.
We can then access the pre-defined color by adding an <code>@</code> in front of its name.</p>
<p>We also have to add <code>style.css</code> to <code>resources.gresource.xml</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/3/resources/resources.gresource.xml">listings/todo/3/resources/resources.gresource.xml</a></p>
<pre><code class="language-diff"> &lt;?xml version="1.0" encoding="UTF-8"?&gt;
 &lt;gresources&gt;
   &lt;gresource prefix="/org/gtk_rs/Todo3/"&gt;
     &lt;file compressed="true" preprocess="xml-stripblanks" alias="gtk/help-overlay.ui"&gt;shortcuts.ui&lt;/file&gt;
     &lt;file compressed="true" preprocess="xml-stripblanks"&gt;task_row.ui&lt;/file&gt;
     &lt;file compressed="true" preprocess="xml-stripblanks"&gt;window.ui&lt;/file&gt;
+    &lt;file compressed="true"&gt;style.css&lt;/file&gt;
   &lt;/gresource&gt;
 &lt;/gresources&gt;
</code></pre>
<p>Additionally, we call <code>load_css()</code> in <code>connect_startup</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/3/main.rs">listings/todo/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod task_object;
</span><span class="boring">mod task_row;
</span><span class="boring">mod utils;
</span><span class="boring">mod window;
</span><span class="boring">
</span><span class="boring">use gdk::Display;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gdk, gio, glib, Application, CssProvider};
</span><span class="boring">use window::Window;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Todo3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    gio::resources_register_include!("todo_3.gresource")
</span><span class="boring">        .expect("Failed to register resources.");
</span><span class="boring">
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span>    // Connect to signals
    app.connect_startup(|app| {
        setup_shortcuts(app);
        load_css()
    });
<span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn setup_shortcuts(app: &amp;Application) {
</span><span class="boring">    app.set_accels_for_action("win.filter('All')", &amp;["&lt;Ctrl&gt;a"]);
</span><span class="boring">    app.set_accels_for_action("win.filter('Open')", &amp;["&lt;Ctrl&gt;o"]);
</span><span class="boring">    app.set_accels_for_action("win.filter('Done')", &amp;["&lt;Ctrl&gt;d"]);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn load_css() {
</span><span class="boring">    // Load the CSS file and add it to the provider
</span><span class="boring">    let provider = CssProvider::new();
</span><span class="boring">    provider.load_from_resource("/org/gtk_rs/Todo3/style.css");
</span><span class="boring">
</span><span class="boring">    // Add the provider to the default screen
</span><span class="boring">    gtk::style_context_add_provider_for_display(
</span><span class="boring">        &amp;Display::default().expect("Could not connect to a display."),
</span><span class="boring">        &amp;provider,
</span><span class="boring">        gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a new custom window and present it
</span><span class="boring">    let window = Window::new(app);
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p><code>load_css()</code> is very similar to the one shown at the beginning of the chapter.
However, this time we load styles using <code>load_from_resource()</code>.</p>
<pre><code class="language-rust"><span class="boring">mod task_object;
</span><span class="boring">mod task_row;
</span><span class="boring">mod utils;
</span><span class="boring">mod window;
</span><span class="boring">
</span><span class="boring">use gdk::Display;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gdk, gio, glib, Application, CssProvider};
</span><span class="boring">use window::Window;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Todo3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    gio::resources_register_include!("todo_3.gresource")
</span><span class="boring">        .expect("Failed to register resources.");
</span><span class="boring">
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to signals
</span><span class="boring">    app.connect_startup(|app| {
</span><span class="boring">        setup_shortcuts(app);
</span><span class="boring">        load_css()
</span><span class="boring">    });
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn setup_shortcuts(app: &amp;Application) {
</span><span class="boring">    app.set_accels_for_action("win.filter('All')", &amp;["&lt;Ctrl&gt;a"]);
</span><span class="boring">    app.set_accels_for_action("win.filter('Open')", &amp;["&lt;Ctrl&gt;o"]);
</span><span class="boring">    app.set_accels_for_action("win.filter('Done')", &amp;["&lt;Ctrl&gt;d"]);
</span><span class="boring">}
</span><span class="boring">
</span>fn load_css() {
    // Load the CSS file and add it to the provider
    let provider = CssProvider::new();
    provider.load_from_resource("/org/gtk_rs/Todo3/style.css");

    // Add the provider to the default screen
    gtk::style_context_add_provider_for_display(
        &amp;Display::default().expect("Could not connect to a display."),
        &amp;provider,
        gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
    );
}
<span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a new custom window and present it
</span><span class="boring">    let window = Window::new(app);
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>And that is how the task rows look like after the change.
Probably better to revert this immediately again.</p>
<div style="text-align:center"><img src="img/todo_3.png" alt="To-Do app with green background for its task widget"/></div>
<h2 id="adapt-todo-app"><a class="header" href="#adapt-todo-app">Adapt Todo App</a></h2>
<p>Luckily, finding an actual use for CSS in our To-Do app isn't too hard.
Until now the different tasks weren't nicely separated.
We can change that by adding the <code>frame</code> and the <code>separators</code> style class to our <code>tasks_list</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/4/resources/task_row.ui">listings/todo/4/resources/window.ui</a></p>
<pre><code class="language-diff"> &lt;object class="GtkListView" id="tasks_list"&gt;
   &lt;property name="valign"&gt;start&lt;/property&gt;
+  &lt;style&gt;
+    &lt;class name="frame"/&gt;
+    &lt;class name="separators"/&gt;
+  &lt;/style&gt;
 &lt;/object&gt;
</code></pre>
<div style="text-align:center"><img src="img/todo_4.png" alt="To-Do app with borders for its task widget"/></div>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>There are surely enough ways to define CSS rules.
Let's briefly recap the syntax we learned.
The following rule matches the node <code>arrow</code>, which is a descendant of the node <code>button</code> with the name <code>button-1</code> and the style classes <code>toggle</code> and <code>text-button</code>.
The rule then actually applies, when we also hover over <code>arrow</code>.</p>
<pre><code class="language-css">button#button-1.toggle.text-button arrow:hover {
  color: magenta;
}
</code></pre>
<p>When the rule applies, the <code>color</code> parameter will be set to magenta.
You can find the full list of supported parameters in GTK's <a href="https://docs.gtk.org/gtk4/css-properties.html#gtk-css-properties">documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libadwaita"><a class="header" href="#libadwaita">Libadwaita</a></h1>
<p>If you target a certain platform with your GUI, you will want to follow the platform's <a href="https://en.wikipedia.org/wiki/Human_interface_guidelines">Human Interface Guidelines</a> (HIG).
With a GTK application, chances are the platform is either <a href="https://elementary.io">elementary OS</a> or <a href="https://www.gnome.org/">GNOME</a>.
In this chapter we will discuss how to follow GNOME's <a href="https://developer.gnome.org/hig/">HIG</a> with <a href="https://gnome.pages.gitlab.gnome.org/libadwaita/doc/1-latest/">libadwaita</a>.</p>
<p>Libadwaita is a library augmenting GTK 4 which:</p>
<ul>
<li>provides widgets to better follow GNOME's HIG</li>
<li>provides widgets to let applications <a href="https://gnome.pages.gitlab.gnome.org/libadwaita/doc/main/adaptive-layouts.html">change their layout </a> based on the available space</li>
<li>integrates the Adwaita <a href="https://gnome.pages.gitlab.gnome.org/libadwaita/doc/main/styles-and-appearance.html">stylesheet</a></li>
<li>allows runtime recoloring with <a href="https://gnome.pages.gitlab.gnome.org/libadwaita/doc/1-latest/named-colors.html">named colors</a></li>
<li>adds <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.StyleManager.html">API</a> to support the cross-desktop dark style preference</li>
</ul>
<p>In order to use the Rust bindings, add the <a href="https://crates.io/crates/libadwaita">libadwaita crate</a> as dependency by executing:</p>
<pre><code>cargo add libadwaita --rename adw --features v1_5
</code></pre>
<p>The versions of the <code>gtk4</code> and <code>libadwaita</code> crates need to be synced.
Just remember that when you update one of them to the newest version to update the other one as well.</p>
<p>Installation of the library itself works similar to GTK.
Just follow the installation instruction that is suitable for your distribution.</p>
<h2 id="linux-1"><a class="header" href="#linux-1">Linux</a></h2>
<p>Fedora and derivatives:</p>
<pre><code>sudo dnf install libadwaita-devel
</code></pre>
<p>Debian and derivatives:</p>
<pre><code>sudo apt install libadwaita-1-dev
</code></pre>
<p>Arch and derivatives:</p>
<pre><code>sudo pacman -S libadwaita
</code></pre>
<h2 id="macos-1"><a class="header" href="#macos-1">macOS</a></h2>
<pre><code>brew install libadwaita
</code></pre>
<h2 id="windows-1"><a class="header" href="#windows-1">Windows</a></h2>
<h2 id="if-using-gvsbuild"><a class="header" href="#if-using-gvsbuild">If using gvsbuild</a></h2>
<p>If you used <code>gvsbuild</code> to build GTK 4:</p>
<pre><code>gvsbuild build libadwaita librsvg
</code></pre>
<h2 id="if-building-manually-with-msvc"><a class="header" href="#if-building-manually-with-msvc">If building manually with MSVC:</a></h2>
<p>From the Windows start menu, search for <code>x64 Native Tools Command Prompt for VS 2019</code>.
That will open a terminal configured to use MSVC x64 tools.
From there, run the following commands:</p>
<pre><code>cd /
git clone --branch libadwaita-1-3 https://gitlab.gnome.org/GNOME/libadwaita.git --depth 1
cd libadwaita
meson setup builddir -Dprefix=C:/gnome -Dintrospection=disabled -Dvapi=false
meson install -C builddir
</code></pre>
<h2 id="work-around-missing-icons"><a class="header" href="#work-around-missing-icons">Work around missing icons</a></h2>
<p><a href="https://gitlab.gnome.org/GNOME/gtk/-/blob/34b9ec5be2f3a38e1e72c4d96f130a2b14734121/NEWS#L60">This workaround is needed for GTK &lt; 4.10</a>
due to <a href="https://gitlab.gnome.org/GNOME/gtk/-/issues/5303">this issue</a>.</p>
<h3 id="gvsbuild"><a class="header" href="#gvsbuild">gvsbuild</a></h3>
<p>From a command prompt:</p>
<pre><code>xcopy /s /i C:\gtk-build\gtk\x64\release\share\icons\hicolor\scalable\apps C:\gtk-build\gtk\x64\release\share\icons\hicolor\scalable\actions
gtk4-update-icon-cache.exe -t -f C:\gtk-build\gtk\x64\release\share\icons\hicolor
</code></pre>
<h3 id="manually-with-msvc"><a class="header" href="#manually-with-msvc">Manually with MSVC</a></h3>
<pre><code>xcopy /s /i C:\gnome\share\icons\hicolor\scalable\apps C:\gnome\share\icons\hicolor\scalable\actions
gtk4-update-icon-cache.exe -t -f C:\gnome\share\icons\hicolor
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="let-to-do-app-use-libadwaita"><a class="header" href="#let-to-do-app-use-libadwaita">Let To-Do App use Libadwaita</a></h1>
<p>Within this chapter we will adapt our To-Do app so that it follows GNOME's <a href="https://developer.gnome.org/hig/">HIG</a>.
Let's start by installing Libadwaita and adding the <code>libadwaita</code> crate to our dependencies as explained in the <a href="libadwaita.html">previous chapter</a>.</p>
<p>The simplest way to take advantage of Libadwaita is by replacing <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Application.html"><code>gtk::Application</code></a> with <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.Application.html"><code>adw::Application</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/5/main.rs">listings/todo/5/main.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod task_object;
</span><span class="boring">mod task_row;
</span><span class="boring">mod utils;
</span><span class="boring">mod window;
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use window::Window;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Todo5";
</span><span class="boring">
</span>fn main() -&gt; glib::ExitCode {
    gio::resources_register_include!("todo_5.gresource")
        .expect("Failed to register resources.");

    // Create a new application
    //        👇 changed
    let app = adw::Application::builder().application_id(APP_ID).build();

    // Connect to signals
    app.connect_startup(setup_shortcuts);
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

//                       👇 changed
fn setup_shortcuts(app: &amp;adw::Application) {
    app.set_accels_for_action("win.filter('All')", &amp;["&lt;Ctrl&gt;a"]);
    app.set_accels_for_action("win.filter('Open')", &amp;["&lt;Ctrl&gt;o"]);
    app.set_accels_for_action("win.filter('Done')", &amp;["&lt;Ctrl&gt;d"]);
}

//                👇 changed
fn build_ui(app: &amp;adw::Application) {
    // Create a new custom window and present it
    let window = Window::new(app);
    window.present();
}</code></pre>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/5/window/mod.rs">listings/todo/5/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, CustomFilter, FilterListModel, NoSelection, SignalListItemFactory,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span>    pub fn new(app: &amp;adw::Application) -&gt; Self {
        // Create new window
        Object::builder().property("application", app).build()
    }
<span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>adw::Application</code> calls <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/functions/fn.init.html"><code>adw::init</code></a> internally and makes sure that translations, types, stylesheets, and icons are set up properly for Libadwaita.
It also loads stylesheets automatically from resources as long as they are named <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.Application.html#automatic-resources">correctly</a>.</p>
<p>Looking at our To-Do app we can see that the looks of its widgets changed.
This is because the <code>Default</code> stylesheet provided by GTK has been replaced with the <code>Adwaita</code> stylesheet provided by Libadwaita.</p>
<div style="text-align:center"><img src="img/todo_change_4_5.png" alt="Transformation of To-Do app"/></div>
<p>Also, our app now switches to the dark style together with the rest of the system.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_dark.webm" type="video/webm">
   <p>A video which shows how the To-Do app changes color scheme from light to dark</p>
 </video>
</div>
<h2 id="boxed-lists"><a class="header" href="#boxed-lists">Boxed lists</a></h2>
<p>Of course Libadwaita is more than just a couple of stylesheets and a <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.StyleManager.html"><code>StyleManager</code></a>.
But before we get to the interesting stuff, we will make our lives easier for the future by replacing all occurrences of <code>gtk::prelude</code> and <code>gtk::subclass::prelude</code> with <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/prelude/index.html"><code>adw::prelude</code></a> and <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/subclass/prelude/index.html"><code>adw::subclass::prelude</code></a>.
This works because the <code>adw</code> preludes, in addition to the Libadwaita-specific traits, re-export the corresponding <code>gtk</code> preludes.</p>
<p>Now we are going let our tasks follow the <a href="https://developer.gnome.org/hig/patterns/containers/boxed-lists.html">boxed lists pattern</a>.
The HIG does not require us to use this style and there's a good reason for that: it is incompatible with recycling lists.
This means they cannot be used with <a href="https://developer.gnome.org/hig/patterns/containers/list-column-views.html">list views</a> and are therefore only appropriate for relatively small lists.</p>
<blockquote>
<p>Try to add tasks programmatically and see how many of them you have to add until the UI noticeably slows down.
Determine for yourself if you think that is a reasonable number or if we should have rather stuck with list views.</p>
</blockquote>
<p>We can use boxed lists by using <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ListBox.html"><code>gtk::ListBox</code></a> instead of <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ListView.html"><code>gtk::ListView</code></a>.
We will also add the <a href="https://gnome.pages.gitlab.gnome.org/libadwaita/doc/main/boxed-lists.html"><code>boxed-list</code></a> style class provided by Libadwaita.</p>
<p>Let's implement all these changes in the <code>window.ui</code> file.
All of the changes are confined within the second child of the <code>ApplicationWindow</code>.
To see the complete file, just click on the link after "Filename".</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/6/resources/window.ui">listings/todo/6/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;child&gt;
  &lt;object class="GtkScrolledWindow"&gt;
    &lt;property name="hscrollbar-policy"&gt;never&lt;/property&gt;
    &lt;property name="min-content-height"&gt;420&lt;/property&gt;
    &lt;property name="vexpand"&gt;True&lt;/property&gt;
    &lt;property name="child"&gt;
      &lt;object class="AdwClamp"&gt;
        &lt;property name="child"&gt;
          &lt;object class="GtkBox"&gt;
            &lt;property name="orientation"&gt;vertical&lt;/property&gt;
            &lt;property name="spacing"&gt;18&lt;/property&gt;
            &lt;property name="margin-top"&gt;24&lt;/property&gt;
            &lt;property name="margin-bottom"&gt;24&lt;/property&gt;
            &lt;property name="margin-start"&gt;12&lt;/property&gt;
            &lt;property name="margin-end"&gt;12&lt;/property&gt;
            &lt;child&gt;
              &lt;object class="GtkEntry" id="entry"&gt;
                &lt;property name="placeholder-text" translatable="yes"&gt;Enter a Task…&lt;/property&gt;
                &lt;property name="secondary-icon-name"&gt;list-add-symbolic&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
            &lt;child&gt;
              &lt;object class="GtkListBox" id="tasks_list"&gt;
                &lt;property name="visible"&gt;False&lt;/property&gt;
                &lt;property name="selection-mode"&gt;none&lt;/property&gt;
                &lt;style&gt;
                  &lt;class name="boxed-list" /&gt;
                &lt;/style&gt;
              &lt;/object&gt;
            &lt;/child&gt;
          &lt;/object&gt;
        &lt;/property&gt;
      &lt;/object&gt;
    &lt;/property&gt;
  &lt;/object&gt;
&lt;/child&gt;
</code></pre>
<p>In order to follow the boxed list pattern, we switched to <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ListBox.html"><code>gtk::ListBox</code></a>, set its property "selection-mode" to "none" and added the <code>boxed-list</code> style class.</p>
<p>Let's continue with <code>window/imp.rs</code>.
The member variable <code>tasks_list</code> now describes a <code>ListBox</code> rather than a <code>ListView</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/6/window/imp.rs">listings/todo/6/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListBox};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/Todo6/window.ui")]
pub struct Window {
    #[template_child]
    pub entry: TemplateChild&lt;Entry&gt;,
    #[template_child]
    pub tasks_list: TemplateChild&lt;ListBox&gt;,
    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
    pub settings: OnceCell&lt;Settings&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "TodoWindow";
    type Type = super::Window;
    type ParentType = gtk::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();

        // Create action to remove done tasks and add to action group "win"
        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
            window.remove_done_tasks();
        });
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>We now move on to <code>window/mod.rs</code>.
<code>ListBox</code> supports models just fine, but without any widget recycling we don't need factories anymore.
<code>setup_factory</code> can therefore be safely deleted.
To setup the <code>ListBox</code>, we call <code>bind_model</code> in <code>setup_tasks</code>.
There we specify the model, as well as a closure describing how to transform the given GObject into a widget the list box can display.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/6/window/mod.rs">listings/todo/6/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, ActionRow};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{gio, glib, Align, CheckButton, CustomFilter, FilterListModel, NoSelection};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span>        // Wrap model with filter and selection and pass it to the list box
        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
        let selection_model = NoSelection::new(Some(filter_model.clone()));
        self.imp().tasks_list.bind_model(
            Some(&amp;selection_model),
            clone!(
                #[weak(rename_to = window)]
                self,
                #[upgrade_or_panic]
                move |obj| {
                    let task_object = obj
                        .downcast_ref()
                        .expect("The object should be of type `TaskObject`.");
                    let row = window.create_task_row(task_object);
                    row.upcast()
                }
            ),
        );
<span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;self.tasks());
</span><span class="boring">        self.tasks().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Assure that `tasks_list` is only visible
</span><span class="boring">    /// if the number of tasks is greater than 0
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We still have to specify the <code>create_task_row</code> method.
Here, we create an <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.ActionRow.html"><code>adw::ActionRow</code></a> with a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.CheckButton.html"><code>gtk::CheckButton</code></a> as activatable widget.
Without recycling, a GObject will always belong to the same widget.
That means we can just bind their properties without having to worry about unbinding them later on.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/6/window/mod.rs">listings/todo/6/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, ActionRow};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{gio, glib, Align, CheckButton, CustomFilter, FilterListModel, NoSelection};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;self.tasks());
</span><span class="boring">        self.tasks().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Assure that `tasks_list` is only visible
</span><span class="boring">    /// if the number of tasks is greater than 0
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
        // Create check button
        let check_button = CheckButton::builder()
            .valign(Align::Center)
            .can_focus(false)
            .build();

        // Create row
        let row = ActionRow::builder()
            .activatable_widget(&amp;check_button)
            .build();
        row.add_prefix(&amp;check_button);

        // Bind properties
        task_object
            .bind_property("completed", &amp;check_button, "active")
            .bidirectional()
            .sync_create()
            .build();
        task_object
            .bind_property("content", &amp;row, "title")
            .sync_create()
            .build();

        // Return row
        row
    }
<span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>When using boxed lists, you also have to take care to hide the <code>ListBox</code> when there is no task present.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/6/window/mod.rs">listings/todo/6/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, ActionRow};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{gio, glib, Align, CheckButton, CustomFilter, FilterListModel, NoSelection};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span>        // Assure that the task list is only visible when it is supposed to
        self.set_task_list_visible(&amp;self.tasks());
        self.tasks().connect_items_changed(clone!(
            #[weak(rename_to = window)]
            self,
            move |tasks, _, _, _| {
                window.set_task_list_visible(tasks);
            }
        ));
<span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Assure that `tasks_list` is only visible
</span><span class="boring">    /// if the number of tasks is greater than 0
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Finally, we define the <code>set_task_list_visible</code> method.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/6/window/mod.rs">listings/todo/6/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, ActionRow};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{gio, glib, Align, CheckButton, CustomFilter, FilterListModel, NoSelection};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;self.tasks());
</span><span class="boring">        self.tasks().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span>    /// Assure that `tasks_list` is only visible
    /// if the number of tasks is greater than 0
    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
    }
<span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>This is how the boxed list style looks like in our app.</p>
<div style="text-align:center"><img src="img/todo_6.png" alt="The To-Do app using libadwaita"/></div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-collections"><a class="header" href="#adding-collections">Adding Collections</a></h1>
<h2 id="sidebar"><a class="header" href="#sidebar">Sidebar</a></h2>
<p>Using Libadwaita on its own was already a big leap forward when it came to the look and feel of the To-Do app.
Let us go one step further by adding a way to group tasks into collections.
These collections will get their own sidebar on the left of the app.
We will start by adding an empty sidebar without any functionality.</p>
<div style="text-align:center"><img src="img/todo_7_sidebar.png" alt="To-Do app with an empty sidebar"/></div>
<p>There are a couple of steps we have to go through to get to this state.
First, we have to replace <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ApplicationWindow.html"><code>gtk::ApplicationWindow</code></a> with <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.ApplicationWindow.html"><code>adw::ApplicationWindow</code></a>.
The main difference between those two is that <code>adw::ApplicationWindow</code> has no titlebar area.
That comes in handy when we build up our interface with <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.NavigationSplitView.html"><code>adw::NavigationSplitView</code></a>.
In the screenshot above, the <code>NavigationSplitView</code> adds a sidebar for the collection view to the left, while the task view occupies the space on the right.
When using <code>adw::ApplicationWindow</code> the collection view and task view have their own <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.HeaderBar.html"><code>adw::HeaderBar</code></a> and the separator spans over the whole window.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/resources/window.ui">listings/todo/7/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;menu id="main-menu"&gt;
    &lt;!--Menu implementation--&gt;      
  &lt;/menu&gt;
  &lt;template class="TodoWindow" parent="AdwApplicationWindow"&gt;
    &lt;property name="title" translatable="yes"&gt;To-Do&lt;/property&gt;
    &lt;property name="width-request"&gt;360&lt;/property&gt;
    &lt;property name="height-request"&gt;200&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="AdwBreakpoint"&gt;
        &lt;condition&gt;max-width: 500sp&lt;/condition&gt;
        &lt;setter object="split_view" property="collapsed"&gt;True&lt;/setter&gt;
      &lt;/object&gt;
    &lt;/child&gt;
    &lt;property name="content"&gt;
      &lt;object class="AdwNavigationSplitView" id="split_view"&gt;
        &lt;property name="min-sidebar-width"&gt;200&lt;/property&gt;
        &lt;property name="sidebar"&gt;
          &lt;object class="AdwNavigationPage"&gt;
            &lt;!--Collection view implementation--&gt;
          &lt;/object&gt;
        &lt;/property&gt;
        &lt;property name="content"&gt;
          &lt;object class="AdwNavigationPage"&gt;
            &lt;!--Task view implementation--&gt;
          &lt;/object&gt;
        &lt;/property&gt;
      &lt;/object&gt;
    &lt;/property&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p><code>NavigationSplitView</code> also helps with making your app <a href="https://developer.gnome.org/hig/guidelines/adaptive.html">adaptive</a>/
As soon as the requested size is too small to fit all children at the same time, the splitview collapses, and starts behaving like a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Stack.html"><code>gtk::Stack</code></a>.
This means that it only displays one of its children at a time.
The adaptive behavior of the leaflet allows the To-Do app to work on smaller screen sizes (like e.g. phones) even with the added collection view.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_7_navigation_sidebar.webm" type="video/webm">
   <p>A video which shows that reduzing the width of the app let's the sidebar collapse</p>
 </video>
</div>
<p>We add the necessary UI elements for the collection view, such as a header bar with a button to add a new collection, as well as the list box <code>collections_list</code> to display the collections later on.
We also add the style <a href="https://gnome.pages.gitlab.gnome.org/libadwaita/doc/1-latest/style-classes.html#sidebars">navigations-sidebar</a> to <code>collections_list</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/resources/window.ui">listings/todo/7/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;object class="AdwNavigationPage"&gt;
  &lt;property name="title" bind-source="TodoWindow"
    bind-property="title" bind-flags="sync-create" /&gt;
  &lt;property name="child"&gt;
    &lt;object class="AdwToolbarView"&gt;
      &lt;child type="top"&gt;
        &lt;object class="AdwHeaderBar"&gt;
          &lt;child type="start"&gt;
            &lt;object class="GtkToggleButton"&gt;
              &lt;property name="icon-name"&gt;list-add-symbolic&lt;/property&gt;
              &lt;property name="tooltip-text" translatable="yes"&gt;New Collection&lt;/property&gt;
              &lt;property name="action-name"&gt;win.new-collection&lt;/property&gt;
            &lt;/object&gt;
          &lt;/child&gt;
        &lt;/object&gt;
      &lt;/child&gt;
      &lt;property name="content"&gt;
        &lt;object class="GtkScrolledWindow"&gt;
          &lt;property name="child"&gt;
            &lt;object class="GtkListBox" id="collections_list"&gt;
              &lt;style&gt;
                &lt;class name="navigation-sidebar" /&gt;
              &lt;/style&gt;
            &lt;/object&gt;
          &lt;/property&gt;
        &lt;/object&gt;
      &lt;/property&gt;
    &lt;/object&gt;
</code></pre>
<p>We also add a header bar to the task view.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/resources/window.ui">listings/todo/7/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;object class="AdwNavigationPage"&gt;
  &lt;property name="title" translatable="yes"&gt;Tasks&lt;/property&gt;
  &lt;property name="child"&gt;
    &lt;object class="AdwToolbarView"&gt;
      &lt;child type="top"&gt;
        &lt;object class="AdwHeaderBar"&gt;
          &lt;property name="show-title"&gt;False&lt;/property&gt;
          &lt;child type="end"&gt;
            &lt;object class="GtkMenuButton"&gt;
              &lt;property name="icon-name"&gt;open-menu-symbolic&lt;/property&gt;
              &lt;property name="menu-model"&gt;main-menu&lt;/property&gt;
              &lt;property name="tooltip-text" translatable="yes"&gt;Main Menu&lt;/property&gt;
            &lt;/object&gt;
          &lt;/child&gt;
        &lt;/object&gt;
      &lt;/child&gt;
      &lt;property name="content"&gt;
        &lt;object class="GtkScrolledWindow"&gt;
          &lt;property name="child"&gt;
            &lt;object class="AdwClamp"&gt;
              &lt;property name="maximum-size"&gt;400&lt;/property&gt;
              &lt;property name="tightening-threshold"&gt;300&lt;/property&gt;
              &lt;property name="child"&gt;
                &lt;object class="GtkBox"&gt;
                  &lt;property name="orientation"&gt;vertical&lt;/property&gt;
                  &lt;property name="margin-start"&gt;12&lt;/property&gt;
                  &lt;property name="margin-end"&gt;12&lt;/property&gt;
                  &lt;property name="spacing"&gt;12&lt;/property&gt;
                  &lt;child&gt;
                    &lt;object class="GtkEntry" id="entry"&gt;
                      &lt;property name="placeholder-text" translatable="yes"&gt;Enter a Task…&lt;/property&gt;
                      &lt;property name="secondary-icon-name"&gt;list-add-symbolic&lt;/property&gt;
                    &lt;/object&gt;
                  &lt;/child&gt;
                  &lt;child&gt;
                    &lt;object class="GtkListBox" id="tasks_list"&gt;
                      &lt;property name="visible"&gt;False&lt;/property&gt;
                      &lt;property name="selection-mode"&gt;none&lt;/property&gt;
                      &lt;style&gt;
                        &lt;class name="boxed-list" /&gt;
                      &lt;/style&gt;
                    &lt;/object&gt;
                  &lt;/child&gt;
                &lt;/object&gt;
              &lt;/property&gt;
            &lt;/object&gt;
          &lt;/property&gt;
        &lt;/object&gt;
      &lt;/property&gt;
    &lt;/object&gt;
  &lt;/property&gt;
&lt;/object&gt;
</code></pre>
<p>We also have to adapt the window implementation.
For example, the parent type of our window is now <code>adw::ApplicationWindow</code> instead of <code>gtk::ApplicationWindow</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/window/imp.rs">listings/todo/7/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListBox};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo7/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "TodoWindow";
    type Type = super::Window;
    //                👇 changed
    type ParentType = adw::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();

        // Create action to remove done tasks and add to action group "win"
        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
            window.remove_done_tasks();
        });
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p>That also means that we have to implement the trait <code>AdwApplicationWindowImpl</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/window/imp.rs">listings/todo/7/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListBox};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo7/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    //                👇 changed
</span><span class="boring">    type ParentType = adw::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span>// Trait shared by all adwaita application windows
impl AdwApplicationWindowImpl for Window {}</code></pre>
<p>Finally, we add <code>adw::ApplicationWindow</code> to the ancestors of <code>Window</code> in <code>mod.rs</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/window/mod.rs">listings/todo/7/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, ActionRow};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{gio, glib, Align, CheckButton, CustomFilter, FilterListModel, NoSelection};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span>glib::wrapper! {
    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
        //       👇 changed
        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
}
<span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;self.tasks());
</span><span class="boring">        self.tasks().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Assure that `tasks_list` is only visible
</span><span class="boring">    /// if the number of tasks is greater than 0
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h2 id="placeholder-page"><a class="header" href="#placeholder-page">Placeholder Page</a></h2>
<p>Even before we start to populate the collection view, we ought to think about a different challenge: the empty state of our To-Do app.
Before, the empty state without a single task was quite okay.
It was clear that you had to add tasks in the entry bar.
However, now the situation is different.
Users will have to add a collection first, and we have to make that clear.
The GNOME HIG suggests to use a <a href="https://developer.gnome.org/hig/patterns/feedback/placeholders.html">placeholder page</a> for that.
In our case, this placeholder page will be presented to the user if they open the app without any collections present.</p>
<div style="text-align:center"><img src="img/todo_8_placeholder_page.png" alt="The placeholder page"/></div>
<p>We now wrap our UI in a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Stack.html"><code>gtk::Stack</code></a>.
One stack page describes the placeholder page, the other describes the main page.
We will later wire up the logic to display the correct stack page in the Rust code.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/resources/window.ui">listings/todo/8/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;menu id="main-menu"&gt;
    &lt;!--Menu implementation--&gt; 
  &lt;/menu&gt;
  &lt;template class="TodoWindow" parent="AdwApplicationWindow"&gt;
    &lt;property name="title" translatable="yes"&gt;To-Do&lt;/property&gt;
    &lt;property name="width-request"&gt;360&lt;/property&gt;
    &lt;property name="height-request"&gt;200&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="AdwBreakpoint"&gt;
        &lt;condition&gt;max-width: 500sp&lt;/condition&gt;
        &lt;setter object="split_view" property="collapsed"&gt;True&lt;/setter&gt;
      &lt;/object&gt;
    &lt;/child&gt;
    &lt;property name="content"&gt;
      &lt;object class="GtkStack" id="stack"&gt;
        &lt;property name="transition-type"&gt;crossfade&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkStackPage"&gt;
            &lt;property name="name"&gt;placeholder&lt;/property&gt;
            &lt;property name="child"&gt;
              &lt;object class="GtkBox"&gt;
                &lt;!--Placeholder page implementation--&gt; 
              &lt;/object&gt;
            &lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class="GtkStackPage"&gt;
            &lt;property name="name"&gt;main&lt;/property&gt;
            &lt;property name="child"&gt;
              &lt;object class="AdwNavigationSplitView" id="split_view"&gt;
                &lt;!--Main page implementation--&gt;
              &lt;/object&gt;
            &lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/property&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>In order to create the pageholder page as displayed before, we combine a flat header bar with <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.StatusPage.html"><code>adw::StatusPage</code></a>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/resources/window.ui">listings/todo/8/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;object class="GtkBox"&gt;
  &lt;property name="orientation"&gt;vertical&lt;/property&gt;
  &lt;child&gt;
    &lt;object class="GtkHeaderBar"&gt;
      &lt;style&gt;
        &lt;class name="flat" /&gt;
      &lt;/style&gt;
    &lt;/object&gt;
  &lt;/child&gt;
  &lt;child&gt;
    &lt;object class="GtkWindowHandle"&gt;
      &lt;property name="vexpand"&gt;True&lt;/property&gt;
      &lt;property name="child"&gt;
        &lt;object class="AdwStatusPage"&gt;
          &lt;property name="icon-name"&gt;checkbox-checked-symbolic&lt;/property&gt;
          &lt;property name="title" translatable="yes"&gt;No Tasks&lt;/property&gt;
          &lt;property name="description" translatable="yes"&gt;Create some tasks to start using the app.&lt;/property&gt;
          &lt;property name="child"&gt;
            &lt;object class="GtkButton"&gt;
              &lt;property name="label" translatable="yes"&gt;_New Collection&lt;/property&gt;
              &lt;property name="use-underline"&gt;True&lt;/property&gt;
              &lt;property name="halign"&gt;center&lt;/property&gt;
              &lt;property name="action-name"&gt;win.new-collection&lt;/property&gt;
              &lt;style&gt;
                &lt;class name="pill" /&gt;
                &lt;class name="suggested-action" /&gt;
              &lt;/style&gt;
            &lt;/object&gt;
          &lt;/property&gt;
        &lt;/object&gt;
      &lt;/property&gt;
    &lt;/object&gt;
  &lt;/child&gt;
&lt;/object&gt;
</code></pre>
<h2 id="collections"><a class="header" href="#collections">Collections</a></h2>
<p>We still need a way to store our collections.
Just like we have already created <code>TaskObject</code>, we will now introduce <code>CollectionObject</code>.
It will have the members <code>title</code> and <code>tasks</code>, both of which will be exposed as properties.
As usual, the full implementation can be seen by clicking at the eye symbol at the top right of the snippet.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/collection_object/imp.rs">listings/todo/8/collection_object/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use glib::Properties;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span>// Object holding the state
#[derive(Properties, Default)]
#[properties(wrapper_type = super::CollectionObject)]
pub struct CollectionObject {
    #[property(get, set)]
    pub title: RefCell&lt;String&gt;,
    #[property(get, set)]
    pub tasks: OnceCell&lt;gio::ListStore&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for CollectionObject {
    const NAME: &amp;'static str = "TodoCollectionObject";
    type Type = super::CollectionObject;
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">#[glib::derived_properties]
</span><span class="boring">impl ObjectImpl for CollectionObject {}</span></code></pre>
<p>We also add the struct <code>CollectionData</code> to aid in serialization and deserialization.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/collection_object/mod.rs">listings/todo/8/collection_object/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CollectionObject(ObjectSubclass&lt;imp::CollectionObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CollectionObject {
</span><span class="boring">    pub fn new(title: &amp;str, tasks: gio::ListStore) -&gt; Self {
</span><span class="boring">        Object::builder()
</span><span class="boring">            .property("title", title)
</span><span class="boring">            .property("tasks", tasks)
</span><span class="boring">            .build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn to_collection_data(&amp;self) -&gt; CollectionData {
</span><span class="boring">        let title = self.imp().title.borrow().clone();
</span><span class="boring">        let tasks_data = self
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">        CollectionData { title, tasks_data }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn from_collection_data(collection_data: CollectionData) -&gt; Self {
</span><span class="boring">        let title = collection_data.title;
</span><span class="boring">        let tasks_to_extend: Vec&lt;TaskObject&gt; = collection_data
</span><span class="boring">            .tasks_data
</span><span class="boring">            .into_iter()
</span><span class="boring">            .map(TaskObject::from_task_data)
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">        tasks.extend_from_slice(&amp;tasks_to_extend);
</span><span class="boring">
</span><span class="boring">        Self::new(&amp;title, tasks)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Default, Clone, Serialize, Deserialize)]
pub struct CollectionData {
    pub title: String,
    pub tasks_data: Vec&lt;TaskData&gt;,
}</code></pre>
<p>Finally, we add methods to <code>CollectionObject</code> in order to</p>
<ul>
<li>construct it with <code>new</code>,</li>
<li>easily access the tasks <code>ListStore</code> with <code>tasks</code> and</li>
<li>convert to and from <code>CollectionData</code> with <code>to_collection_data</code> and <code>from_collection_data</code>.</li>
</ul>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/collection_object/mod.rs">listings/todo/8/collection_object/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct CollectionObject(ObjectSubclass&lt;imp::CollectionObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span>impl CollectionObject {
    pub fn new(title: &amp;str, tasks: gio::ListStore) -&gt; Self {
        Object::builder()
            .property("title", title)
            .property("tasks", tasks)
            .build()
    }

    pub fn to_collection_data(&amp;self) -&gt; CollectionData {
        let title = self.imp().title.borrow().clone();
        let tasks_data = self
            .tasks()
            .iter::&lt;TaskObject&gt;()
            .filter_map(Result::ok)
            .map(|task_object| task_object.task_data())
            .collect();
        CollectionData { title, tasks_data }
    }

    pub fn from_collection_data(collection_data: CollectionData) -&gt; Self {
        let title = collection_data.title;
        let tasks_to_extend: Vec&lt;TaskObject&gt; = collection_data
            .tasks_data
            .into_iter()
            .map(TaskObject::from_task_data)
            .collect();

        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
        tasks.extend_from_slice(&amp;tasks_to_extend);

        Self::new(&amp;title, tasks)
    }
}
<span class="boring">
</span><span class="boring">#[derive(Default, Clone, Serialize, Deserialize)]
</span><span class="boring">pub struct CollectionData {
</span><span class="boring">    pub title: String,
</span><span class="boring">    pub tasks_data: Vec&lt;TaskData&gt;,
</span><span class="boring">}</span></code></pre>
<h2 id="window-1"><a class="header" href="#window-1">Window</a></h2>
<p>In order to hook up the new logic, we have to add more state to <code>imp::Window</code>.
There are additional widgets that we access via the <code>template_child</code> macro.
Additionally, we reference the <code>collections</code> list store, the <code>current_collection</code> as well as the <code>current_filter_model</code>.
We also store <code>tasks_changed_handler_id</code>.
Its purpose will become clear in later snippets.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/window/imp.rs">listings/todo/8/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, NavigationSplitView};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib::SignalHandlerId;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, FilterListModel, ListBox, Stack};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/Todo8/window.ui")]
pub struct Window {
    pub settings: OnceCell&lt;Settings&gt;,
    #[template_child]
    pub entry: TemplateChild&lt;Entry&gt;,
    #[template_child]
    pub tasks_list: TemplateChild&lt;ListBox&gt;,
    // 👇 all members below are new
    #[template_child]
    pub collections_list: TemplateChild&lt;ListBox&gt;,
    #[template_child]
    pub split_view: TemplateChild&lt;NavigationSplitView&gt;,
    #[template_child]
    pub stack: TemplateChild&lt;Stack&gt;,
    pub collections: OnceCell&lt;gio::ListStore&gt;,
    pub current_collection: RefCell&lt;Option&lt;CollectionObject&gt;&gt;,
    pub current_filter_model: RefCell&lt;Option&lt;FilterListModel&gt;&gt;,
    pub tasks_changed_handler_id: RefCell&lt;Option&lt;SignalHandlerId&gt;&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = adw::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Create async action to create new collection and add to action group "win"
</span><span class="boring">        klass.install_action_async(
</span><span class="boring">            "win.new-collection",
</span><span class="boring">            None,
</span><span class="boring">            |window, _, _| async move {
</span><span class="boring">                window.new_collection().await;
</span><span class="boring">            },
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_collections();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;CollectionData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .collections()
</span><span class="boring">            .iter::&lt;CollectionObject&gt;()
</span><span class="boring">            .filter_map(|collection_object| collection_object.ok())
</span><span class="boring">            .map(|collection_object| collection_object.to_collection_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p>Further, we add a couple of helper methods which will come in handy later on.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span>    fn tasks(&amp;self) -&gt; gio::ListStore {
        self.current_collection().tasks()
    }

    fn current_collection(&amp;self) -&gt; CollectionObject {
        self.imp()
            .current_collection
            .borrow()
            .clone()
            .expect("`current_collection` should be set in `set_current_collections`.")
    }

    fn collections(&amp;self) -&gt; gio::ListStore {
        self.imp()
            .collections
            .get()
            .expect("`collections` should be set in `setup_collections`.")
            .clone()
    }

    fn set_filter(&amp;self) {
        self.imp()
            .current_filter_model
            .borrow()
            .clone()
            .expect("`current_filter_model` should be set in `set_current_collection`.")
            .set_filter(self.filter().as_ref());
    }
<span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>As always, we want our data to be saved when we close the window.
Since most of the implementation is in the method <code>CollectionObject::to_collection_data</code>, the implementation of <code>close_request</code> doesn't change much.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, NavigationSplitView};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib::SignalHandlerId;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, FilterListModel, ListBox, Stack};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo8/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    // 👇 all members below are new
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub collections_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub split_view: TemplateChild&lt;NavigationSplitView&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub stack: TemplateChild&lt;Stack&gt;,
</span><span class="boring">    pub collections: OnceCell&lt;gio::ListStore&gt;,
</span><span class="boring">    pub current_collection: RefCell&lt;Option&lt;CollectionObject&gt;&gt;,
</span><span class="boring">    pub current_filter_model: RefCell&lt;Option&lt;FilterListModel&gt;&gt;,
</span><span class="boring">    pub tasks_changed_handler_id: RefCell&lt;Option&lt;SignalHandlerId&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = adw::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Create async action to create new collection and add to action group "win"
</span><span class="boring">        klass.install_action_async(
</span><span class="boring">            "win.new-collection",
</span><span class="boring">            None,
</span><span class="boring">            |window, _, _| async move {
</span><span class="boring">                window.new_collection().await;
</span><span class="boring">            },
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_collections();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span>// Trait shared by all windows
impl WindowImpl for Window {
    fn close_request(&amp;self) -&gt; glib::Propagation {
        // Store task data in vector
        let backup_data: Vec&lt;CollectionData&gt; = self
            .obj()
            .collections()
            .iter::&lt;CollectionObject&gt;()
            .filter_map(|collection_object| collection_object.ok())
            .map(|collection_object| collection_object.to_collection_data())
            .collect();

        // Save state to file
        let file = File::create(data_path()).expect("Could not create json file.");
        serde_json::to_writer(file, &amp;backup_data)
            .expect("Could not write data to json file");

        // Pass close request on to the parent
        self.parent_close_request()
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p><code>constructed</code> stays mostly the same as well.
Instead of <code>setup_tasks</code> we now call <code>setup_collections</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/7/window/imp.rs">listings/todo/8/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, NavigationSplitView};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib::SignalHandlerId;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, FilterListModel, ListBox, Stack};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo8/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    // 👇 all members below are new
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub collections_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub split_view: TemplateChild&lt;NavigationSplitView&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub stack: TemplateChild&lt;Stack&gt;,
</span><span class="boring">    pub collections: OnceCell&lt;gio::ListStore&gt;,
</span><span class="boring">    pub current_collection: RefCell&lt;Option&lt;CollectionObject&gt;&gt;,
</span><span class="boring">    pub current_filter_model: RefCell&lt;Option&lt;FilterListModel&gt;&gt;,
</span><span class="boring">    pub tasks_changed_handler_id: RefCell&lt;Option&lt;SignalHandlerId&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = adw::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Create async action to create new collection and add to action group "win"
</span><span class="boring">        klass.install_action_async(
</span><span class="boring">            "win.new-collection",
</span><span class="boring">            None,
</span><span class="boring">            |window, _, _| async move {
</span><span class="boring">                window.new_collection().await;
</span><span class="boring">            },
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        // Call "constructed" on parent
        self.parent_constructed();

        // Setup
        let obj = self.obj();
        obj.setup_settings();
        obj.setup_collections();
        obj.restore_data();
        obj.setup_callbacks();
        obj.setup_actions();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;CollectionData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .collections()
</span><span class="boring">            .iter::&lt;CollectionObject&gt;()
</span><span class="boring">            .filter_map(|collection_object| collection_object.ok())
</span><span class="boring">            .map(|collection_object| collection_object.to_collection_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p><code>setup_collections</code> sets up the <code>collections</code> list store as well as assuring that changes in the model will be reflected in the <code>collections_list</code>.
To do that it uses the method <code>create_collection_row</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_collections(&amp;self) {
        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
        self.imp()
            .collections
            .set(collections.clone())
            .expect("Could not set collections");

        self.imp().collections_list.bind_model(
            Some(&amp;collections),
            clone!(
                #[weak(rename_to = window)]
                self,
                #[upgrade_or_panic]
                move |obj| {
                    let collection_object = obj
                        .downcast_ref()
                        .expect("The object should be of type `CollectionObject`.");
                    let row = window.create_collection_row(collection_object);
                    row.upcast()
                }
            ),
        )
    }
<span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>create_collection_row</code> takes a <code>CollectionObject</code> and builds a <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ListBoxRow.html"><code>gtk::ListBoxRow</code></a> from its information.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn create_collection_row(
        &amp;self,
        collection_object: &amp;CollectionObject,
    ) -&gt; ListBoxRow {
        let label = Label::builder()
            .ellipsize(pango::EllipsizeMode::End)
            .xalign(0.0)
            .build();

        collection_object
            .bind_property("title", &amp;label, "label")
            .sync_create()
            .build();

        ListBoxRow::builder().child(&amp;label).build()
    }
<span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We also adapt <code>restore_data</code>.
Again, the heavy lifting comes from <code>CollectionObject::from_collection_data</code>, so we don't have to change too much here.
Since the rows of <code>collections_list</code> can be selected, we have to select one of them after restoring the data.
We choose the first one and let the method <code>set_current_collection</code> do the rest.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span>    fn restore_data(&amp;self) {
        if let Ok(file) = File::open(data_path()) {
            // Deserialize data from file to vector
            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
                .expect(
                    "It should be possible to read `backup_data` from the json file.",
                );

            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
            let collections: Vec&lt;CollectionObject&gt; = backup_data
                .into_iter()
                .map(CollectionObject::from_collection_data)
                .collect();

            // Insert restored objects into model
            self.collections().extend_from_slice(&amp;collections);

            // Set first collection as current
            if let Some(first_collection) = collections.first() {
                self.set_current_collection(first_collection.clone());
            }
        }
    }
<span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>set_current_collection</code> assures that all elements accessing tasks refer to the task model of the current collection.
We bind the <code>tasks_list</code> to the current collection and store the filter model.
Whenever there are no tasks in our current collection we want to hide our tasks list.
Otherwise, the list box will leave a bad-looking line behind.
However, we don't want to accumulate signal handlers whenever we switch collections.
This is why we store the <code>tasks_changed_handler_id</code> and disconnect the old handler as soon as we set a new collection.
Finally, we select the collection row.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span>    fn set_current_collection(&amp;self, collection: CollectionObject) {
        // Wrap model with filter and selection and pass it to the list box
        let tasks = collection.tasks();
        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
        let selection_model = NoSelection::new(Some(filter_model.clone()));
        self.imp().tasks_list.bind_model(
            Some(&amp;selection_model),
            clone!(
                #[weak(rename_to = window)]
                self,
                #[upgrade_or_panic]
                move |obj| {
                    let task_object = obj
                        .downcast_ref()
                        .expect("The object should be of type `TaskObject`.");
                    let row = window.create_task_row(task_object);
                    row.upcast()
                }
            ),
        );

        // Store filter model
        self.imp().current_filter_model.replace(Some(filter_model));

        // If present, disconnect old `tasks_changed` handler
        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
            self.tasks().disconnect(handler_id);
        }

        // Assure that the task list is only visible when it is supposed to
        self.set_task_list_visible(&amp;tasks);
        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
            #[weak(rename_to = window)]
            self,
            move |tasks, _, _, _| {
                window.set_task_list_visible(tasks);
            }
        ));
        self.imp()
            .tasks_changed_handler_id
            .replace(Some(tasks_changed_handler_id));

        // Set current tasks
        self.imp().current_collection.replace(Some(collection));

        self.select_collection_row();
    }
<span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Previously, we used the method <code>set_task_list_visible</code>.
It assures that <code>tasks_list</code> is only visible if the number of tasks is greater than 0.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span>    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
    }
<span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>select_collection_row</code> assures that the row for the current collection is selected in <code>collections_list</code>.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span>    fn select_collection_row(&amp;self) {
        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
            let row = self.imp().collections_list.row_at_index(index as i32);
            self.imp().collections_list.select_row(row.as_ref());
        }
    }
<span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h2 id="message-dialog"><a class="header" href="#message-dialog">Message Dialog</a></h2>
<p>There isn't yet a way to add a collection.
Let's implement that functionality.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_8_dialog.webm" type="video/webm">
   <p>A video which shows the new dialog</p>
 </video>
</div>
<p>The screencast above demonstrates the desired behavior.
When we activate the button with the <code>+</code> symbol, a dialog appears.
While the entry is empty, the "Create" button remains insensitive.
As soon as we start typing, the button becomes sensitive.
When we remove all typed letters and the entry becomes empty again, the "Create" button becomes insensitive and the entry gets the "error" style.
After clicking the "Create" button, a new collection is created, and we navigate to its task view.</p>
<p>To implement that behavior we will first add a "new-collection" action to <code>class_init</code> method.
This action will be activated by a click on the <code>+</code> button as well as on the button in the placeholder page.
We are using <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/subclass/widget/trait.WidgetClassExt.html#method.install_action_async"><code>install_action_async</code></a>.
It is a convenient way to add asynchronous actions to subclassed widgets.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/imp.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{prelude::*, NavigationSplitView};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib::SignalHandlerId;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, FilterListModel, ListBox, Stack};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo8/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    // 👇 all members below are new
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub collections_list: TemplateChild&lt;ListBox&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub split_view: TemplateChild&lt;NavigationSplitView&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub stack: TemplateChild&lt;Stack&gt;,
</span><span class="boring">    pub collections: OnceCell&lt;gio::ListStore&gt;,
</span><span class="boring">    pub current_collection: RefCell&lt;Option&lt;CollectionObject&gt;&gt;,
</span><span class="boring">    pub current_filter_model: RefCell&lt;Option&lt;FilterListModel&gt;&gt;,
</span><span class="boring">    pub tasks_changed_handler_id: RefCell&lt;Option&lt;SignalHandlerId&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "TodoWindow";
    type Type = super::Window;
    type ParentType = adw::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();

        // Create action to remove done tasks and add to action group "win"
        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
            window.remove_done_tasks();
        });

        // Create async action to create new collection and add to action group "win"
        klass.install_action_async(
            "win.new-collection",
            None,
            |window, _, _| async move {
                window.new_collection().await;
            },
        );
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_collections();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;CollectionData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .collections()
</span><span class="boring">            .iter::&lt;CollectionObject&gt;()
</span><span class="boring">            .filter_map(|collection_object| collection_object.ok())
</span><span class="boring">            .map(|collection_object| collection_object.to_collection_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all adwaita application windows
</span><span class="boring">impl AdwApplicationWindowImpl for Window {}</span></code></pre>
<p>As soon as the "new-collection" action is activated, the <code>async</code> <code>new_collection</code> method is called.
Here, we create the <a href="https://world.pages.gitlab.gnome.org/Rust/libadwaita-rs/stable/latest/docs/libadwaita/struct.AlertDialog.html"><code>adw::AlertDialog</code></a>, set up the buttons as well as add the entry to it.
We add a callback to the entry to ensure that when the content changes, an empty content sets <code>dialog_button</code> as insensitive and adds an "error" CSS class to the entry.
We then <code>await</code> on the user pressing a button on the dialog.
If they click "Cancel", we simply return.
However, if they click "Create", we want a new collection to be created and set as current collection.
Afterwards we navigate forward on our leaflet, which means we navigate to the task view.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    async fn new_collection(&amp;self) {
        // Create entry
        let entry = Entry::builder()
            .placeholder_text("Name")
            .activates_default(true)
            .build();

        let cancel_response = "cancel";
        let create_response = "create";

        // Create new dialog
        let dialog = AlertDialog::builder()
            .heading("New Collection")
            .close_response(cancel_response)
            .default_response(create_response)
            .extra_child(&amp;entry)
            .build();
        dialog
            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
        // Make the dialog button insensitive initially
        dialog.set_response_enabled(create_response, false);
        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);

        // Set entry's css class to "error", when there is no text in it
        entry.connect_changed(clone!(
            #[weak]
            dialog,
            move |entry| {
                let text = entry.text();
                let empty = text.is_empty();

                dialog.set_response_enabled(create_response, !empty);

                if empty {
                    entry.add_css_class("error");
                } else {
                    entry.remove_css_class("error");
                }
            }
        ));

        let response = dialog.choose_future(self).await;

        // Return if the user chose `cancel_response`
        if response == cancel_response {
            return;
        }

        // Create a new list store
        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();

        // Create a new collection object from the title the user provided
        let title = entry.text().to_string();
        let collection = CollectionObject::new(&amp;title, tasks);

        // Add new collection object and set current tasks
        self.collections().append(&amp;collection);
        self.set_current_collection(collection);

        // Show the content
        self.imp().split_view.set_show_content(true);
    }
<span class="boring">}</span></code></pre>
<p>We also add more callbacks to <code>setup_callbacks</code>.
Importantly, we want to filter our current task model whenever the value of the "filter" setting changes.
Whenever the items of our collections change we also want to set the stack.
This makes sure that our placeholder page is shown if there are no collections.
Finally, we assure that when we click on a row of <code>collections_list</code>, <code>current_collection</code> is set to the selected collection and the split view shows the task view.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span>        // Filter model whenever the value of the key "filter" changes
        self.settings().connect_changed(
            Some("filter"),
            clone!(
                #[weak(rename_to = window)]
                self,
                move |_, _| {
                    window.set_filter();
                }
            ),
        );

        // Setup callback when items of collections change
        self.set_stack();
        self.collections().connect_items_changed(clone!(
            #[weak(rename_to = window)]
            self,
            move |_, _, _, _| {
                window.set_stack();
            }
        ));

        // Setup callback for activating a row of collections list
        self.imp().collections_list.connect_row_activated(clone!(
            #[weak(rename_to = window)]
            self,
            move |_, row| {
                let index = row.index();
                let selected_collection = window
                    .collections()
                    .item(index as u32)
                    .expect("There needs to be an object at this position.")
                    .downcast::&lt;CollectionObject&gt;()
                    .expect("The object needs to be a `CollectionObject`.");
                window.set_current_collection(selected_collection);
                window.imp().split_view.set_show_content(true);
            }
        ));
<span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_stack(&amp;self) {
</span><span class="boring">        if self.collections().n_items() &gt; 0 {
</span><span class="boring">            self.imp().stack.set_visible_child_name("main");
</span><span class="boring">        } else {
</span><span class="boring">            self.imp().stack.set_visible_child_name("placeholder");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Before, we called the method <code>set_stack</code>.
This method ensure when there is at least one collection, the "main" page is shown, and the "placeholder" page otherwise.</p>
<p>Filename: <a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/8/window/imp.rs">listings/todo/8/window/mod.rs</a></p>
<pre><code class="language-rust no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use adw::prelude::*;
</span><span class="boring">use adw::subclass::prelude::*;
</span><span class="boring">use adw::{ActionRow, AlertDialog, ResponseAppearance};
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, pango, Align, CheckButton, CustomFilter, Entry, FilterListModel, Label,
</span><span class="boring">    ListBoxRow, NoSelection,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use crate::collection_object::{CollectionData, CollectionObject};
</span><span class="boring">use crate::task_object::TaskObject;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends adw::ApplicationWindow, gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;adw::Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.current_collection().tasks()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn current_collection(&amp;self) -&gt; CollectionObject {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_collection
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_collection` should be set in `set_current_collections`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn collections(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`collections` should be set in `setup_collections`.")
</span><span class="boring">            .clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_filter(&amp;self) {
</span><span class="boring">        self.imp()
</span><span class="boring">            .current_filter_model
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("`current_filter_model` should be set in `set_current_collection`.")
</span><span class="boring">            .set_filter(self.filter().as_ref());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_collections(&amp;self) {
</span><span class="boring">        let collections = gio::ListStore::new::&lt;CollectionObject&gt;();
</span><span class="boring">        self.imp()
</span><span class="boring">            .collections
</span><span class="boring">            .set(collections.clone())
</span><span class="boring">            .expect("Could not set collections");
</span><span class="boring">
</span><span class="boring">        self.imp().collections_list.bind_model(
</span><span class="boring">            Some(&amp;collections),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let collection_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `CollectionObject`.");
</span><span class="boring">                    let row = window.create_collection_row(collection_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;CollectionData&gt; = serde_json::from_reader(file)
</span><span class="boring">                .expect(
</span><span class="boring">                    "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">                );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;CollectionData&gt;` to `Vec&lt;CollectionObject&gt;`
</span><span class="boring">            let collections: Vec&lt;CollectionObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(CollectionObject::from_collection_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.collections().extend_from_slice(&amp;collections);
</span><span class="boring">
</span><span class="boring">            // Set first collection as current
</span><span class="boring">            if let Some(first_collection) = collections.first() {
</span><span class="boring">                self.set_current_collection(first_collection.clone());
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_collection_row(
</span><span class="boring">        &amp;self,
</span><span class="boring">        collection_object: &amp;CollectionObject,
</span><span class="boring">    ) -&gt; ListBoxRow {
</span><span class="boring">        let label = Label::builder()
</span><span class="boring">            .ellipsize(pango::EllipsizeMode::End)
</span><span class="boring">            .xalign(0.0)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        collection_object
</span><span class="boring">            .bind_property("title", &amp;label, "label")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        ListBoxRow::builder().child(&amp;label).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_current_collection(&amp;self, collection: CollectionObject) {
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list box
</span><span class="boring">        let tasks = collection.tasks();
</span><span class="boring">        let filter_model = FilterListModel::new(Some(tasks.clone()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.bind_model(
</span><span class="boring">            Some(&amp;selection_model),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[upgrade_or_panic]
</span><span class="boring">                move |obj| {
</span><span class="boring">                    let task_object = obj
</span><span class="boring">                        .downcast_ref()
</span><span class="boring">                        .expect("The object should be of type `TaskObject`.");
</span><span class="boring">                    let row = window.create_task_row(task_object);
</span><span class="boring">                    row.upcast()
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Store filter model
</span><span class="boring">        self.imp().current_filter_model.replace(Some(filter_model));
</span><span class="boring">
</span><span class="boring">        // If present, disconnect old `tasks_changed` handler
</span><span class="boring">        if let Some(handler_id) = self.imp().tasks_changed_handler_id.take() {
</span><span class="boring">            self.tasks().disconnect(handler_id);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Assure that the task list is only visible when it is supposed to
</span><span class="boring">        self.set_task_list_visible(&amp;tasks);
</span><span class="boring">        let tasks_changed_handler_id = tasks.connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |tasks, _, _, _| {
</span><span class="boring">                window.set_task_list_visible(tasks);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks_changed_handler_id
</span><span class="boring">            .replace(Some(tasks_changed_handler_id));
</span><span class="boring">
</span><span class="boring">        // Set current tasks
</span><span class="boring">        self.imp().current_collection.replace(Some(collection));
</span><span class="boring">
</span><span class="boring">        self.select_collection_row();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_task_list_visible(&amp;self, tasks: &amp;gio::ListStore) {
</span><span class="boring">        self.imp().tasks_list.set_visible(tasks.n_items() &gt; 0);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn select_collection_row(&amp;self) {
</span><span class="boring">        if let Some(index) = self.collections().find(&amp;self.current_collection()) {
</span><span class="boring">            let row = self.imp().collections_list.row_at_index(index as i32);
</span><span class="boring">            self.imp().collections_list.select_row(row.as_ref());
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn create_task_row(&amp;self, task_object: &amp;TaskObject) -&gt; ActionRow {
</span><span class="boring">        // Create check button
</span><span class="boring">        let check_button = CheckButton::builder()
</span><span class="boring">            .valign(Align::Center)
</span><span class="boring">            .can_focus(false)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Create row
</span><span class="boring">        let row = ActionRow::builder()
</span><span class="boring">            .activatable_widget(&amp;check_button)
</span><span class="boring">            .build();
</span><span class="boring">        row.add_prefix(&amp;check_button);
</span><span class="boring">
</span><span class="boring">        // Bind properties
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("completed", &amp;check_button, "active")
</span><span class="boring">            .bidirectional()
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">        task_object
</span><span class="boring">            .bind_property("content", &amp;row, "title")
</span><span class="boring">            .sync_create()
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Return row
</span><span class="boring">        row
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    window.set_filter();
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        // Setup callback when items of collections change
</span><span class="boring">        self.set_stack();
</span><span class="boring">        self.collections().connect_items_changed(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _, _, _| {
</span><span class="boring">                window.set_stack();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for activating a row of collections list
</span><span class="boring">        self.imp().collections_list.connect_row_activated(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, row| {
</span><span class="boring">                let index = row.index();
</span><span class="boring">                let selected_collection = window
</span><span class="boring">                    .collections()
</span><span class="boring">                    .item(index as u32)
</span><span class="boring">                    .expect("There needs to be an object at this position.")
</span><span class="boring">                    .downcast::&lt;CollectionObject&gt;()
</span><span class="boring">                    .expect("The object needs to be a `CollectionObject`.");
</span><span class="boring">                window.set_current_collection(selected_collection);
</span><span class="boring">                window.imp().split_view.set_show_content(true);
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span>    fn set_stack(&amp;self) {
        if self.collections().n_items() &gt; 0 {
            self.imp().stack.set_visible_child_name("main");
        } else {
            self.imp().stack.set_visible_child_name("placeholder");
        }
    }
<span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    async fn new_collection(&amp;self) {
</span><span class="boring">        // Create entry
</span><span class="boring">        let entry = Entry::builder()
</span><span class="boring">            .placeholder_text("Name")
</span><span class="boring">            .activates_default(true)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        let cancel_response = "cancel";
</span><span class="boring">        let create_response = "create";
</span><span class="boring">
</span><span class="boring">        // Create new dialog
</span><span class="boring">        let dialog = AlertDialog::builder()
</span><span class="boring">            .heading("New Collection")
</span><span class="boring">            .close_response(cancel_response)
</span><span class="boring">            .default_response(create_response)
</span><span class="boring">            .extra_child(&amp;entry)
</span><span class="boring">            .build();
</span><span class="boring">        dialog
</span><span class="boring">            .add_responses(&amp;[(cancel_response, "Cancel"), (create_response, "Create")]);
</span><span class="boring">        // Make the dialog button insensitive initially
</span><span class="boring">        dialog.set_response_enabled(create_response, false);
</span><span class="boring">        dialog.set_response_appearance(create_response, ResponseAppearance::Suggested);
</span><span class="boring">
</span><span class="boring">        // Set entry's css class to "error", when there is no text in it
</span><span class="boring">        entry.connect_changed(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            dialog,
</span><span class="boring">            move |entry| {
</span><span class="boring">                let text = entry.text();
</span><span class="boring">                let empty = text.is_empty();
</span><span class="boring">
</span><span class="boring">                dialog.set_response_enabled(create_response, !empty);
</span><span class="boring">
</span><span class="boring">                if empty {
</span><span class="boring">                    entry.add_css_class("error");
</span><span class="boring">                } else {
</span><span class="boring">                    entry.remove_css_class("error");
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        let response = dialog.choose_future(self).await;
</span><span class="boring">
</span><span class="boring">        // Return if the user chose `cancel_response`
</span><span class="boring">        if response == cancel_response {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Create a new list store
</span><span class="boring">        let tasks = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Create a new collection object from the title the user provided
</span><span class="boring">        let title = entry.text().to_string();
</span><span class="boring">        let collection = CollectionObject::new(&amp;title, tasks);
</span><span class="boring">
</span><span class="boring">        // Add new collection object and set current tasks
</span><span class="boring">        self.collections().append(&amp;collection);
</span><span class="boring">        self.set_current_collection(collection);
</span><span class="boring">
</span><span class="boring">        // Show the content
</span><span class="boring">        self.imp().split_view.set_show_content(true);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>And that was it!
Now we can enjoy the final result.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_8_adaptive_sidebar.webm" type="video/webm">
   <p>A video which shows the final To-Do app</p>
 </video>
</div>
<blockquote>
<p>You might have noticed that there is not yet a way to remove a collection.
Try to implement this missing piece of functionality in your local version of the To-Do app.
Which edge cases do you have to consider?</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
