<!DOCTYPE HTML>
<html lang="zh_cn" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>控制待办事项应用的状态 - 基于 Rust 和 GTK 4 的 GUI 开发</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/style.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">简介</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.</strong> 安装</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation_linux.html"><strong aria-hidden="true">1.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="installation_macos.html"><strong aria-hidden="true">1.2.</strong> macOS</a></li><li class="chapter-item expanded "><a href="installation_windows.html"><strong aria-hidden="true">1.3.</strong> Windows</a></li></ol></li><li class="chapter-item expanded "><a href="project_setup.html"><strong aria-hidden="true">2.</strong> 项目设置</a></li><li class="chapter-item expanded "><a href="hello_world.html"><strong aria-hidden="true">3.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="widgets.html"><strong aria-hidden="true">4.</strong> 控件</a></li><li class="chapter-item expanded "><a href="g_object_concepts.html"><strong aria-hidden="true">5.</strong> GObject 相关概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="g_object_memory_management.html"><strong aria-hidden="true">5.1.</strong> 内存管理</a></li><li class="chapter-item expanded "><a href="g_object_subclassing.html"><strong aria-hidden="true">5.2.</strong> 子类化</a></li><li class="chapter-item expanded "><a href="g_object_values.html"><strong aria-hidden="true">5.3.</strong> 泛型值</a></li><li class="chapter-item expanded "><a href="g_object_properties.html"><strong aria-hidden="true">5.4.</strong> 属性</a></li><li class="chapter-item expanded "><a href="g_object_signals.html"><strong aria-hidden="true">5.5.</strong> 信号</a></li></ol></li><li class="chapter-item expanded "><a href="main_event_loop.html"><strong aria-hidden="true">6.</strong> 主事件循环</a></li><li class="chapter-item expanded "><a href="settings.html"><strong aria-hidden="true">7.</strong> 设置(Settings)</a></li><li class="chapter-item expanded "><a href="saving_window_state.html"><strong aria-hidden="true">8.</strong> 保存窗口状态</a></li><li class="chapter-item expanded "><a href="list_widgets.html"><strong aria-hidden="true">9.</strong> 列表控件</a></li><li class="chapter-item expanded "><a href="composite_templates.html"><strong aria-hidden="true">10.</strong> 复合模板</a></li><li class="chapter-item expanded "><a href="todo_1.html"><strong aria-hidden="true">11.</strong> 创建一个简单的待办事项应用</a></li><li class="chapter-item expanded "><a href="actions.html"><strong aria-hidden="true">12.</strong> Actions</a></li><li class="chapter-item expanded "><a href="todo_2.html" class="active"><strong aria-hidden="true">13.</strong> 控制待办事项应用的状态</a></li><li class="chapter-item expanded "><a href="css.html"><strong aria-hidden="true">14.</strong> CSS</a></li><li class="chapter-item expanded "><a href="libadwaita.html"><strong aria-hidden="true">15.</strong> Libadwaita</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="todo_3.html"><strong aria-hidden="true">15.1.</strong> Let To-Do App use Libadwaita</a></li><li class="chapter-item expanded "><a href="todo_4.html"><strong aria-hidden="true">15.2.</strong> Adding Collections</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">基于 Rust 和 GTK 4 的 GUI 开发</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Mario-Hero/GTK-Rust-Book-zh_cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="控制待办事项应用的状态"><a class="header" href="#控制待办事项应用的状态">控制待办事项应用的状态</a></h1>
<h2 id="过滤任务"><a class="header" href="#过滤任务">过滤任务</a></h2>
<p>现在是继续开发待办事项应用的时候了。 一个值得添加的功能是：过滤任务。 这是一个利用我们新学到的关于 Action 的知识的好机会！ 使用 Action，我们可以通过菜单和键盘快捷键访问过滤器。 这就是我们希望的最终效果：</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_2_animation.webm" type="video/webm">
  <p>A video which shows a more featureful To-Do app/p>
 </video>
</div>
请注意，屏幕录像还显示了一个标签为"清除(Clear)"的按钮，它将删除所有已完成的任务。 当我们以后让应用程序在不同会话之间保存任务时，这个按钮就会派上用场。
<p>让我们先在 <code>window.ui</code> 中添加菜单和标题栏。 在阅读了<a href="actions.html">动作</a>一章后，我们应该会对添加的代码感到熟悉。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/resources/window.ui">listings/todo/2/resources/window.ui</a></p>
<pre><code class="language-diff"> &lt;?xml version="1.0" encoding="UTF-8"?&gt;
 &lt;interface&gt;
+  &lt;menu id="main-menu"&gt;
+    &lt;submenu&gt;
+      &lt;attribute name="label" translatable="yes"&gt;_Filter&lt;/attribute&gt;
+      &lt;item&gt;
+        &lt;attribute name="label" translatable="yes"&gt;_All&lt;/attribute&gt;
+        &lt;attribute name="action"&gt;win.filter&lt;/attribute&gt;
+        &lt;attribute name="target"&gt;All&lt;/attribute&gt;
+      &lt;/item&gt;
+      &lt;item&gt;
+        &lt;attribute name="label" translatable="yes"&gt;_Open&lt;/attribute&gt;
+        &lt;attribute name="action"&gt;win.filter&lt;/attribute&gt;
+        &lt;attribute name="target"&gt;Open&lt;/attribute&gt;
+      &lt;/item&gt;
+      &lt;item&gt;
+        &lt;attribute name="label" translatable="yes"&gt;_Done&lt;/attribute&gt;
+        &lt;attribute name="action"&gt;win.filter&lt;/attribute&gt;
+        &lt;attribute name="target"&gt;Done&lt;/attribute&gt;
+      &lt;/item&gt;
+    &lt;/submenu&gt;
+    &lt;item&gt;
+      &lt;attribute name="label" translatable="yes"&gt;_Remove Done Tasks&lt;/attribute&gt;
+      &lt;attribute name="action"&gt;win.remove-done-tasks&lt;/attribute&gt;
+    &lt;/item&gt;
+    &lt;item&gt;
+      &lt;attribute name="label" translatable="yes"&gt;_Keyboard Shortcuts&lt;/attribute&gt;
+      &lt;attribute name="action"&gt;win.show-help-overlay&lt;/attribute&gt;
+    &lt;/item&gt;
+  &lt;/menu&gt;
   &lt;template class="TodoWindow" parent="GtkApplicationWindow"&gt;
     &lt;property name="width-request"&gt;360&lt;/property&gt;
     &lt;property name="title" translatable="yes"&gt;To-Do&lt;/property&gt;
+    &lt;child type="titlebar"&gt;
+      &lt;object class="GtkHeaderBar"&gt;
+        &lt;child type="end"&gt;
+          &lt;object class="GtkMenuButton" id="menu_button"&gt;
+            &lt;property name="icon-name"&gt;open-menu-symbolic&lt;/property&gt;
+            &lt;property name="menu-model"&gt;main-menu&lt;/property&gt;
+          &lt;/object&gt;
+        &lt;/child&gt;
+      &lt;/object&gt;
+    &lt;/child&gt;
</code></pre>
<p>然后，我们创建一个设置 schema。 同样，"过滤器"设置与菜单调用的有状态的动作（Action）相对应。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/org.gtk_rs.Todo2.gschema.xml">listings/todo/2/org.gtk_rs.Todo2.gschema.xml</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;schemalist&gt;
  &lt;schema id="org.gtk_rs.Todo2" path="/org/gtk_rs/Todo2/"&gt;
    &lt;key name="filter" type="s"&gt;
      &lt;choices&gt;
        &lt;choice value='All'/&gt;
        &lt;choice value='Open'/&gt;
        &lt;choice value='Done'/&gt;
      &lt;/choices&gt;
      &lt;default&gt;'All'&lt;/default&gt;
      &lt;summary&gt;Filter of the tasks&lt;/summary&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
</code></pre>
<p>我们按照<a href="./settings.html">设置</a>一章中的描述安装 schema. 然后，我们将<code>设置(settings)</code>的引用添加到 <code>imp::Window</code>.</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/window/imp.rs">listings/todo/2/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListView};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/Todo2/window.ui")]
pub struct Window {
    #[template_child]
    pub entry: TemplateChild&lt;Entry&gt;,
    #[template_child]
    pub tasks_list: TemplateChild&lt;ListView&gt;,
    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
    pub settings: OnceCell&lt;Settings&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_factory();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>同样，我们创建了一些函数，以方便访问设置。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/window/mod.rs">listings/todo/2/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, CustomFilter, FilterListModel, NoSelection,
</span><span class="boring">    SignalListItemFactory,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_settings(&amp;self) {
        let settings = Settings::new(APP_ID);
        self.imp()
            .settings
            .set(settings)
            .expect("`settings` should not be set before calling `setup_settings`.");
    }

    fn settings(&amp;self) -&gt; &amp;Settings {
        self.imp()
            .settings
            .get()
            .expect("`settings` should be set in `setup_settings`.")
    }
<span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter_state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>我们还为 <code>TaskObject</code> 添加了 <code>is_completed</code>、<code>task_data</code> 和 <code>from_task_data</code> 方法。 我们将在下面的代码段中使用它们。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/task_object/mod.rs">listings/todo/2/task_object/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct TaskObject(ObjectSubclass&lt;imp::TaskObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span>impl TaskObject {
    pub fn new(completed: bool, content: String) -&gt; Self {
        Object::builder()
            .property("completed", completed)
            .property("content", content)
            .build()
    }

    pub fn is_completed(&amp;self) -&gt; bool {
        self.imp().data.borrow().completed
    }

    pub fn task_data(&amp;self) -&gt; TaskData {
        self.imp().data.borrow().clone()
    }

    pub fn from_task_data(task_data: TaskData) -&gt; Self {
        Self::new(task_data.completed, task_data.content)
    }
}
<span class="boring">
</span><span class="boring">#[derive(Default, Clone, Serialize, Deserialize)]
</span><span class="boring">pub struct TaskData {
</span><span class="boring">    pub completed: bool,
</span><span class="boring">    pub content: String,
</span><span class="boring">}</span></code></pre>
<p>与前一章类似，我们让<code>设置(settings)</code>创建动作。 然后，我们将新创建的动作"过滤器(filter)"添加到窗口中。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/window/mod.rs">listings/todo/2/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, CustomFilter, FilterListModel, NoSelection,
</span><span class="boring">    SignalListItemFactory,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter_state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_actions(&amp;self) {
        // Create action from key "filter" and add to action group "win"
        let action_filter = self.settings().create_action("filter");
        self.add_action(&amp;action_filter);
    }
<span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>我们还添加了一个动作，允许我们删除已完成的任务。 这次我们使用另一种名为 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/subclass/widget/trait.WidgetClassExt.html#method.install_action"><code>install_action</code></a> 的方法。 这种方法有一些限制。 它只能在子类化部件时使用，而且不支持有状态的动作。 但是，它的用法很简洁，而且有一个相应的姊妹方法 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/subclass/widget/trait.WidgetClassExt.html#method.install_action_async"><code>install_action_async</code></a>，我们将在以后的章节中使用它。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/window/imp.rs">listings/todo/2/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListView};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo2/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListView&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = "TodoWindow";
    type Type = super::Window;
    type ParentType = gtk::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();

        // Create action to remove done tasks and add to action group "win"
        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
            window.remove_done_tasks();
        });
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_factory();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>这是 <code>remove_done_tasks</code> 的实现。 我们遍历 <code>gio::ListStore</code> 并删除所有已完成的任务对象。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/window/mod.rs">listings/todo/2/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, CustomFilter, FilterListModel, NoSelection,
</span><span class="boring">    SignalListItemFactory,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter_state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span>    fn remove_done_tasks(&amp;self) {
        let tasks = self.tasks();
        let mut position = 0;
        while let Some(item) = tasks.item(position) {
            // Get `TaskObject` from `glib::Object`
            let task_object = item
                .downcast_ref::&lt;TaskObject&gt;()
                .expect("The object needs to be of type `TaskObject`.");

            if task_object.is_completed() {
                tasks.remove(position);
            } else {
                position += 1;
            }
        }
    }
<span class="boring">}</span></code></pre>
<p>激活 "win.filter" 操作后，相应的设置将被更改。 因此我们需要一个方法，将此设置转换为 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.FilterListModel.html"><code>gtk::FilterListModel</code></a> 可以理解的过滤器。 可能的状态有 "全部"、"待办"和 "已完成"。 对于 "待办"和 "已完成"，我们返回 <code>Some(filter)</code> 。 如果状态为 "全部"，则无需过滤任何内容，因此我们返回 <code>None</code>.</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/window/mod.rs">listings/todo/2/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, CustomFilter, FilterListModel, NoSelection,
</span><span class="boring">    SignalListItemFactory,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span>    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
        // Get filter_state from settings
        let filter_state: String = self.settings().get("filter");

        // Create custom filters
        let filter_open = CustomFilter::new(|obj| {
            // Get `TaskObject` from `glib::Object`
            let task_object = obj
                .downcast_ref::&lt;TaskObject&gt;()
                .expect("The object needs to be of type `TaskObject`.");

            // Only allow completed tasks
            !task_object.is_completed()
        });
        let filter_done = CustomFilter::new(|obj| {
            // Get `TaskObject` from `glib::Object`
            let task_object = obj
                .downcast_ref::&lt;TaskObject&gt;()
                .expect("The object needs to be of type `TaskObject`.");

            // Only allow done tasks
            task_object.is_completed()
        });

        // Return the correct filter
        match filter_state.as_str() {
            "All" =&gt; None,
            "Open" =&gt; Some(filter_open),
            "Done" =&gt; Some(filter_done),
            _ =&gt; unreachable!(),
        }
    }
<span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>现在，我们可以设置模型了。 通过调用 <code>filter</code> 方法，用设置中的状态初始化 <code>filter_model</code>。 每当关键字 "filter" 的状态发生变化时，我们就会再次调用 <code>filter</code> 方法来获取更新后的 <code>filter_model</code>.</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/window/mod.rs">listings/todo/2/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, CustomFilter, FilterListModel, NoSelection,
</span><span class="boring">    SignalListItemFactory,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter_state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_tasks(&amp;self) {
        // Create new model
        let model = gio::ListStore::new::&lt;TaskObject&gt;();

        // Get state and set model
        self.imp().tasks.replace(Some(model));

        // Wrap model with filter and selection and pass it to the list view
        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
        let selection_model = NoSelection::new(Some(filter_model.clone()));
        self.imp().tasks_list.set_model(Some(&amp;selection_model));

        // Filter model whenever the value of the key "filter" changes
        self.settings().connect_changed(
            Some("filter"),
            clone!(
                #[weak(rename_to = window)]
                self,
                #[weak]
                filter_model,
                move |_, _| {
                    filter_model.set_filter(window.filter().as_ref());
                }
            ),
        );
    }
<span class="boring">
</span><span class="boring">    fn restore_data(&amp;self) {
</span><span class="boring">        if let Ok(file) = File::open(data_path()) {
</span><span class="boring">            // Deserialize data from file to vector
</span><span class="boring">            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
</span><span class="boring">                "It should be possible to read `backup_data` from the json file.",
</span><span class="boring">            );
</span><span class="boring">
</span><span class="boring">            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
</span><span class="boring">            let task_objects: Vec&lt;TaskObject&gt; = backup_data
</span><span class="boring">                .into_iter()
</span><span class="boring">                .map(TaskObject::from_task_data)
</span><span class="boring">                .collect();
</span><span class="boring">
</span><span class="boring">            // Insert restored objects into model
</span><span class="boring">            self.tasks().extend_from_slice(&amp;task_objects);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>然后，我们使用 <code>set_accels_for_action</code> 将快捷方式与其动作绑定。 这里也使用了详细的动作名称。 由于这必须在应用程序级别完成，<code>setup_shortcuts</code> 将 <code>gtk::Application</code> 作为参数。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/main.rs">listings/todo/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod task_object;
</span><span class="boring">mod task_row;
</span><span class="boring">mod utils;
</span><span class="boring">mod window;
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application};
</span><span class="boring">use window::Window;
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Todo2";
</span><span class="boring">
</span>fn main() -&gt; glib::ExitCode {
    // Register and include resources
    gio::resources_register_include!("todo_2.gresource")
        .expect("Failed to register resources.");

    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to signals
    app.connect_startup(setup_shortcuts);
    app.connect_activate(build_ui);

    // Run the application
    app.run()
}

fn setup_shortcuts(app: &amp;Application) {
    app.set_accels_for_action("win.filter('All')", &amp;["&lt;Ctrl&gt;a"]);
    app.set_accels_for_action("win.filter('Open')", &amp;["&lt;Ctrl&gt;o"]);
    app.set_accels_for_action("win.filter('Done')", &amp;["&lt;Ctrl&gt;d"]);
}
<span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a new custom window and present it
</span><span class="boring">    let window = Window::new(app);
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>现在，我们创建了所有这些漂亮的快捷方式，我们希望用户能找到它们。 为此，我们需要创建一个快捷方式窗口。 我们再次使用一个 <code>ui</code> 文件来描述它，但这里我们不想使用它作为我们自定义控件模板。 相反，我们用它实例化了一个现有类 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ShortcutsWindow.html"><code>gtk::ShortcutsWindow</code></a>  的控件。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/resources/shortcuts.ui">listings/todo/2/resources/shortcuts.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;object class="GtkShortcutsWindow" id="help_overlay"&gt;
    &lt;property name="modal"&gt;True&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkShortcutsSection"&gt;
        &lt;property name="section-name"&gt;shortcuts&lt;/property&gt;
        &lt;property name="max-height"&gt;10&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkShortcutsGroup"&gt;
            &lt;property name="title" translatable="yes" context="shortcut window"&gt;General&lt;/property&gt;
            &lt;child&gt;
              &lt;object class="GtkShortcutsShortcut"&gt;
                &lt;property name="title" translatable="yes" context="shortcut window"&gt;Show shortcuts&lt;/property&gt;
                &lt;property name="action-name"&gt;win.show-help-overlay&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
            &lt;child&gt;
              &lt;object class="GtkShortcutsShortcut"&gt;
                &lt;property name="title" translatable="yes" context="shortcut window"&gt;Filter to show all tasks&lt;/property&gt;
                &lt;property name="action-name"&gt;win.filter('All')&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
            &lt;child&gt;
              &lt;object class="GtkShortcutsShortcut"&gt;
                &lt;property name="title" translatable="yes" context="shortcut window"&gt;Filter to show only open tasks&lt;/property&gt;
                &lt;property name="action-name"&gt;win.filter('Open')&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
            &lt;child&gt;
              &lt;object class="GtkShortcutsShortcut"&gt;
                &lt;property name="title" translatable="yes" context="shortcut window"&gt;Filter to show only completed tasks&lt;/property&gt;
                &lt;property name="action-name"&gt;win.filter('Done')&lt;/property&gt;
              &lt;/object&gt;
            &lt;/child&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/object&gt;
&lt;/interface&gt;
</code></pre>
<p>这些条目可以用 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ShortcutsSection.html"><code>gtk::ShortcutsSection</code></a> 和 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ShortcutsGroup.html"><code>gtk::ShortcutsGroup</code></a> 来组织。 如果我们指定了动作名称，我们就不必重复键盘快键键。 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.ShortcutsShortcut.html"><code>gtk::ShortcutsShortcut</code></a> 会自行查找。</p>
<blockquote>
<p>请注意我们为 <code>ShortcutsShortcut</code> 设置 <code>action-name</code> 的方式。 我们没有为目标使用单独的属性，而是使用了一个<em>详细</em>的操作名称。 详细名称看上去类似： <code>action_group.action_name(target)</code>. 目标的格式取决于其类型，此处有<a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Action.html#method.parse_detailed_name">相关说明</a>。 尤其是字符串，必须用单引号括起来，如本例所示。</p>
</blockquote>
<p>最后，我们必须将 <code>shortcuts.ui</code> 添加到资源中。 请注意，我们给它起的别名是 <code>gtk/help-overlay.ui</code>. 这样做是为了利用<a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Application.html#automatic-resources">此处</a>记录的一个便利功能。 它将在 <code>gtk/help-overlay.ui</code> 中查找资源，该资源定义了一个 ID 为 <code>help_overlay</code> 的<code>快捷方式窗口(ShortcutsWindow)</code>。 如果能找到，它将创建一个操作 <code>win.show-help-overlay</code> 来显示该窗口，并将快捷键  <kbd>Ctrl</kbd> + <kbd>?</kbd> 与之关联。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/resources/resources.gresource.xml">listings/todo/2/resources/resources.gresource.xml</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;gresources&gt;
  &lt;gresource prefix="/org/gtk_rs/Todo2/"&gt;
    &lt;file compressed="true" preprocess="xml-stripblanks" alias="gtk/help-overlay.ui"&gt;shortcuts.ui&lt;/file&gt;
    &lt;file compressed="true" preprocess="xml-stripblanks"&gt;task_row.ui&lt;/file&gt;
    &lt;file compressed="true" preprocess="xml-stripblanks"&gt;window.ui&lt;/file&gt;
  &lt;/gresource&gt;
&lt;/gresources&gt;
</code></pre>
<div style="text-align:center"><img src="img/todo_2_shortcuts.png" alt="The shortcut window"/></div>
<h2 id="保存和恢复任务"><a class="header" href="#保存和恢复任务">保存和恢复任务</a></h2>
<p>由于我们使用的是<code>设置(Settings)</code>，因此我们的过滤器状态将在会话之间持续存在。 但是，任务本身不会。 让我们来实现这一点。 我们可以将任务存储在<code>设置</code>中，但这样会很不方便。 说到序列化和反序列化，没有什么比 <a href="https://lib.rs/crates/serde"><code>serde</code></a>更好的了。 结合 <a href="https://lib.rs/crates/serde_json"><code>serde_json</code></a>，我们可以将任务保存为序列化的 <a href="https://en.wikipedia.org/wiki/JSON">json</a> 文件。</p>
<p>首先，我们使用 <code>serde</code> 和 <code>serde_json</code> crate 扩展 <code>Cargo.toml</code>.</p>
<pre><code>cargo add serde --features derive
cargo add serde_json
</code></pre>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/Cargo.toml">listings/Cargo.toml</a></p>
<pre><code class="language-toml">[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
</code></pre>
<p>Serde 是一个用于序列化和反序列化 Rust 数据结构的框架。 通过<code>派生（derive）</code>功能，我们只需一行代码就能使我们的结构（去）序列化。 我们还使用了 <code>rc</code> 功能，这样 Serde 就能处理 <code>std::rc::Rc</code> 对象。 这就是为什么我们将 <code>TodoObject</code> 的数据存储在一个不同的 <code>TodoData</code> 结构中。 这样我们就可以为 <code>TodoData</code> 派生出<code>序列化(Serialize)</code>和<code>反序列化(Deserialize)</code>.</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/task_object/mod.rs">listings/todo/2/task_object/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct TaskObject(ObjectSubclass&lt;imp::TaskObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TaskObject {
</span><span class="boring">    pub fn new(completed: bool, content: String) -&gt; Self {
</span><span class="boring">        Object::builder()
</span><span class="boring">            .property("completed", completed)
</span><span class="boring">            .property("content", content)
</span><span class="boring">            .build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn is_completed(&amp;self) -&gt; bool {
</span><span class="boring">        self.imp().data.borrow().completed
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn task_data(&amp;self) -&gt; TaskData {
</span><span class="boring">        self.imp().data.borrow().clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn from_task_data(task_data: TaskData) -&gt; Self {
</span><span class="boring">        Self::new(task_data.completed, task_data.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Default, Clone, Serialize, Deserialize)]
pub struct TaskData {
    pub completed: bool,
    pub content: String,
}</code></pre>
<p>我们计划将数据存储为文件，因此我们创建了一个工具函数，为我们提供合适的文件路径。 我们使用 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/fn.user_config_dir.html"><code>glib::user_config_dir</code></a> 获取配置目录的路径，并为应用程序创建一个新的子目录。 然后返回文件路径。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/utils.rs">listings/todo/2/utils.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::path::PathBuf;
</span><span class="boring">
</span><span class="boring">use gtk::glib;
</span><span class="boring">
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span>pub fn data_path() -&gt; PathBuf {
    let mut path = glib::user_data_dir();
    path.push(APP_ID);
    std::fs::create_dir_all(&amp;path).expect("Could not create directory.");
    path.push("data.json");
    path
}</code></pre>
<p>我们重写了 <code>close_request</code> 虚函数，以便在窗口关闭时保存任务。 为此，我们首先遍历所有条目并将其存储在一个 <code>Vec</code> 中。 然后将 <code>Vec</code> 序列化，并将数据存储为 json 文件。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/window/imp.rs">listings/todo/2/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListView};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo2/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListView&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_tasks();
</span><span class="boring">        obj.restore_data();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_factory();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span>// Trait shared by all windows
impl WindowImpl for Window {
    fn close_request(&amp;self) -&gt; glib::Propagation {
        // Store task data in vector
        let backup_data: Vec&lt;TaskData&gt; = self
            .obj()
            .tasks()
            .iter::&lt;TaskObject&gt;()
            .filter_map(Result::ok)
            .map(|task_object| task_object.task_data())
            .collect();

        // Save state to file
        let file = File::create(data_path()).expect("Could not create json file.");
        serde_json::to_writer(file, &amp;backup_data)
            .expect("Could not write data to json file");

        // Pass close request on to the parent
        self.parent_close_request()
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>让我们来看看 <code>Vec&lt;TaskData&gt;</code> 将被序列化成什么样子。 请注意，<a href="https://docs.serde.rs/serde_json/fn.to_writer.html"><code>serde_json::to_writer</code></a> 会以更简洁但可读性更差的方式保存数据。 若要创建等价但格式友好的 json，只需将 <code>to_writer</code> 替换为  <a href="https://docs.serde.rs/serde_json/fn.to_writer_pretty.html"><code>serde_json::to_writer_pretty</code></a>.</p>
<p>文件名：data.json</p>
<pre><code class="language-json">[
  {
    "completed": true,
    "content": "Task Number Two"
  },
  {
    "completed": false,
    "content": "Task Number Five"
  },
  {
    "completed": true,
    "content": "Task Number Six"
  },
  {
    "completed": false,
    "content": "Task Number Seven"
  },
  {
    "completed": false,
    "content": "Task Number Eight"
  }
]
</code></pre>
<p>当我们启动应用程序时，我们希望恢复已保存的数据。 让我们为此添加一个 <code>restore_data</code> 方法。 我们将确保处理启动时没有数据文件的情况。 这可能是我们第一次启动应用程序，因此没有以前的会话可以恢复。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/window/mod.rs">listings/todo/2/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Application, CustomFilter, FilterListModel, NoSelection,
</span><span class="boring">    SignalListItemFactory,
</span><span class="boring">};
</span><span class="boring">use gtk::{prelude::*, ListItem};
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::task_row::TaskRow;
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn tasks(&amp;self) -&gt; gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        self.imp()
</span><span class="boring">            .tasks
</span><span class="boring">            .borrow()
</span><span class="boring">            .clone()
</span><span class="boring">            .expect("Could not get current tasks.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn filter(&amp;self) -&gt; Option&lt;CustomFilter&gt; {
</span><span class="boring">        // Get filter_state from settings
</span><span class="boring">        let filter_state: String = self.settings().get("filter");
</span><span class="boring">
</span><span class="boring">        // Create custom filters
</span><span class="boring">        let filter_open = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow completed tasks
</span><span class="boring">            !task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">        let filter_done = CustomFilter::new(|obj| {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = obj
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Only allow done tasks
</span><span class="boring">            task_object.is_completed()
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Return the correct filter
</span><span class="boring">        match filter_state.as_str() {
</span><span class="boring">            "All" =&gt; None,
</span><span class="boring">            "Open" =&gt; Some(filter_open),
</span><span class="boring">            "Done" =&gt; Some(filter_done),
</span><span class="boring">            _ =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_tasks(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new::&lt;TaskObject&gt;();
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        self.imp().tasks.replace(Some(model));
</span><span class="boring">
</span><span class="boring">        // Wrap model with filter and selection and pass it to the list view
</span><span class="boring">        let filter_model = FilterListModel::new(Some(self.tasks()), self.filter());
</span><span class="boring">        let selection_model = NoSelection::new(Some(filter_model.clone()));
</span><span class="boring">        self.imp().tasks_list.set_model(Some(&amp;selection_model));
</span><span class="boring">
</span><span class="boring">        // Filter model whenever the value of the key "filter" changes
</span><span class="boring">        self.settings().connect_changed(
</span><span class="boring">            Some("filter"),
</span><span class="boring">            clone!(
</span><span class="boring">                #[weak(rename_to = window)]
</span><span class="boring">                self,
</span><span class="boring">                #[weak]
</span><span class="boring">                filter_model,
</span><span class="boring">                move |_, _| {
</span><span class="boring">                    filter_model.set_filter(window.filter().as_ref());
</span><span class="boring">                }
</span><span class="boring">            ),
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span>    fn restore_data(&amp;self) {
        if let Ok(file) = File::open(data_path()) {
            // Deserialize data from file to vector
            let backup_data: Vec&lt;TaskData&gt; = serde_json::from_reader(file).expect(
                "It should be possible to read `backup_data` from the json file.",
            );

            // Convert `Vec&lt;TaskData&gt;` to `Vec&lt;TaskObject&gt;`
            let task_objects: Vec&lt;TaskObject&gt; = backup_data
                .into_iter()
                .map(TaskObject::from_task_data)
                .collect();

            // Insert restored objects into model
            self.tasks().extend_from_slice(&amp;task_objects);
        }
    }
<span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Setup callback for activation of the entry
</span><span class="boring">        self.imp().entry.connect_activate(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">
</span><span class="boring">        // Setup callback for clicking (and the releasing) the icon of the entry
</span><span class="boring">        self.imp().entry.connect_icon_release(clone!(
</span><span class="boring">            #[weak(rename_to = window)]
</span><span class="boring">            self,
</span><span class="boring">            move |_, _| {
</span><span class="boring">                window.new_task();
</span><span class="boring">            }
</span><span class="boring">        ));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn new_task(&amp;self) {
</span><span class="boring">        // Get content from entry and clear it
</span><span class="boring">        let buffer = self.imp().entry.buffer();
</span><span class="boring">        let content = buffer.text().to_string();
</span><span class="boring">        if content.is_empty() {
</span><span class="boring">            return;
</span><span class="boring">        }
</span><span class="boring">        buffer.set_text("");
</span><span class="boring">
</span><span class="boring">        // Add new task to model
</span><span class="boring">        let task = TaskObject::new(false, content);
</span><span class="boring">        self.tasks().append(&amp;task);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TaskRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TaskRow`
</span><span class="boring">            let task_row = TaskRow::new();
</span><span class="boring">            list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .set_child(Some(&amp;task_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TaskRow` to a `TaskObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TaskObject` from `ListItem`
</span><span class="boring">            let task_object = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .item()
</span><span class="boring">                .and_downcast::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The item has to be an `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.bind(&amp;task_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TaskRow` from `TaskObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TaskRow` from `ListItem`
</span><span class="boring">            let task_row = list_item
</span><span class="boring">                .downcast_ref::&lt;ListItem&gt;()
</span><span class="boring">                .expect("Needs to be ListItem")
</span><span class="boring">                .child()
</span><span class="boring">                .and_downcast::&lt;TaskRow&gt;()
</span><span class="boring">                .expect("The child has to be a `TaskRow`.");
</span><span class="boring">
</span><span class="boring">            task_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        self.imp().tasks_list.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Create action from key "filter" and add to action group "win"
</span><span class="boring">        let action_filter = self.settings().create_action("filter");
</span><span class="boring">        self.add_action(&amp;action_filter);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn remove_done_tasks(&amp;self) {
</span><span class="boring">        let tasks = self.tasks();
</span><span class="boring">        let mut position = 0;
</span><span class="boring">        while let Some(item) = tasks.item(position) {
</span><span class="boring">            // Get `TaskObject` from `glib::Object`
</span><span class="boring">            let task_object = item
</span><span class="boring">                .downcast_ref::&lt;TaskObject&gt;()
</span><span class="boring">                .expect("The object needs to be of type `TaskObject`.");
</span><span class="boring">
</span><span class="boring">            if task_object.is_completed() {
</span><span class="boring">                tasks.remove(position);
</span><span class="boring">            } else {
</span><span class="boring">                position += 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>最后，我们要确保一切在 <code>constructed</code> 中配置好。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/todo/2/window/imp.rs">listings/todo/2/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, CompositeTemplate, Entry, ListView};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">use crate::task_object::{TaskData, TaskObject};
</span><span class="boring">use crate::utils::data_path;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/Todo2/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub tasks_list: TemplateChild&lt;ListView&gt;,
</span><span class="boring">    pub tasks: RefCell&lt;Option&lt;gio::ListStore&gt;&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "TodoWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">
</span><span class="boring">        // Create action to remove done tasks and add to action group "win"
</span><span class="boring">        klass.install_action("win.remove-done-tasks", None, |window, _, _| {
</span><span class="boring">            window.remove_done_tasks();
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        // Call "constructed" on parent
        self.parent_constructed();

        // Setup
        let obj = self.obj();
        obj.setup_settings();
        obj.setup_tasks();
        obj.restore_data();
        obj.setup_callbacks();
        obj.setup_factory();
        obj.setup_actions();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {
</span><span class="boring">    fn close_request(&amp;self) -&gt; glib::Propagation {
</span><span class="boring">        // Store task data in vector
</span><span class="boring">        let backup_data: Vec&lt;TaskData&gt; = self
</span><span class="boring">            .obj()
</span><span class="boring">            .tasks()
</span><span class="boring">            .iter::&lt;TaskObject&gt;()
</span><span class="boring">            .filter_map(Result::ok)
</span><span class="boring">            .map(|task_object| task_object.task_data())
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        // Save state to file
</span><span class="boring">        let file = File::create(data_path()).expect("Could not create json file.");
</span><span class="boring">        serde_json::to_writer(file, &amp;backup_data)
</span><span class="boring">            .expect("Could not write data to json file");
</span><span class="boring">
</span><span class="boring">        // Pass close request on to the parent
</span><span class="boring">        self.parent_close_request()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}
</span></code></pre>
<p>我们的待办事项应用突然变得更有用了。 我们不仅可以过滤任务，还可以在会话之间保留任务。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="actions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="css.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="actions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="css.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
