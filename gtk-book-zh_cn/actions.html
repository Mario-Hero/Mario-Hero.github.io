<!DOCTYPE HTML>
<html lang="zh_cn" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Actions - 基于 Rust 和 GTK 4 的 GUI 开发</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/style.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">简介</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.</strong> 安装</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation_linux.html"><strong aria-hidden="true">1.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="installation_macos.html"><strong aria-hidden="true">1.2.</strong> macOS</a></li><li class="chapter-item expanded "><a href="installation_windows.html"><strong aria-hidden="true">1.3.</strong> Windows</a></li></ol></li><li class="chapter-item expanded "><a href="project_setup.html"><strong aria-hidden="true">2.</strong> 项目设置</a></li><li class="chapter-item expanded "><a href="hello_world.html"><strong aria-hidden="true">3.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="widgets.html"><strong aria-hidden="true">4.</strong> 控件</a></li><li class="chapter-item expanded "><a href="g_object_concepts.html"><strong aria-hidden="true">5.</strong> GObject 相关概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="g_object_memory_management.html"><strong aria-hidden="true">5.1.</strong> 内存管理</a></li><li class="chapter-item expanded "><a href="g_object_subclassing.html"><strong aria-hidden="true">5.2.</strong> 子类化</a></li><li class="chapter-item expanded "><a href="g_object_values.html"><strong aria-hidden="true">5.3.</strong> 泛型值</a></li><li class="chapter-item expanded "><a href="g_object_properties.html"><strong aria-hidden="true">5.4.</strong> 属性</a></li><li class="chapter-item expanded "><a href="g_object_signals.html"><strong aria-hidden="true">5.5.</strong> 信号</a></li></ol></li><li class="chapter-item expanded "><a href="main_event_loop.html"><strong aria-hidden="true">6.</strong> 主事件循环</a></li><li class="chapter-item expanded "><a href="settings.html"><strong aria-hidden="true">7.</strong> 设置(Settings)</a></li><li class="chapter-item expanded "><a href="saving_window_state.html"><strong aria-hidden="true">8.</strong> 保存窗口状态</a></li><li class="chapter-item expanded "><a href="list_widgets.html"><strong aria-hidden="true">9.</strong> 列表控件</a></li><li class="chapter-item expanded "><a href="composite_templates.html"><strong aria-hidden="true">10.</strong> 复合模板</a></li><li class="chapter-item expanded "><a href="todo_1.html"><strong aria-hidden="true">11.</strong> 创建一个简单的待办事项应用</a></li><li class="chapter-item expanded "><a href="actions.html" class="active"><strong aria-hidden="true">12.</strong> Actions</a></li><li class="chapter-item expanded "><a href="todo_2.html"><strong aria-hidden="true">13.</strong> 控制待办事项应用的状态</a></li><li class="chapter-item expanded "><a href="css.html"><strong aria-hidden="true">14.</strong> CSS</a></li><li class="chapter-item expanded "><a href="libadwaita.html"><strong aria-hidden="true">15.</strong> Libadwaita</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="todo_3.html"><strong aria-hidden="true">15.1.</strong> Let To-Do App use Libadwaita</a></li><li class="chapter-item expanded "><a href="todo_4.html"><strong aria-hidden="true">15.2.</strong> Adding Collections</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">基于 Rust 和 GTK 4 的 GUI 开发</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Mario-Hero/GTK-Rust-Book-zh_cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="动作actions"><a class="header" href="#动作actions">动作(Actions)</a></h1>
<p>到目前为止，我们已经学会了许多将控件粘在一起的方法。 我们可以通过通道发送消息、发射信号、共享引用计数状态和绑定属性。 现在，我们将通过学习动作(Actions)来完成我们的设置。</p>
<p>动作是绑定到某个 GObject 的功能。 让我们来看看最简单的情况，即在没有参数的情况下激活一个动作。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/1/main.rs">listings/actions/1/main.rs</a></p>
<pre><code class="language-rust no_run"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Actions1";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Set keyboard accelerator to trigger "win.close".
</span><span class="boring">    app.set_accels_for_action("win.close", &amp;["&lt;Ctrl&gt;W"]);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Create a window and set the title
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .width_request(360)
        .build();

    // Add action "close" to `window` taking no parameter
    let action_close = ActionEntry::builder("close")
        .activate(|window: &amp;ApplicationWindow, _, _| {
            window.close();
        })
        .build();
    window.add_action_entries([action_close]);

    // Present window
    window.present();
}</code></pre>
<p>首先，我们创建了一个名为 "close" 的新  <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.ActionEntry.html"><code>gio::ActionEntry</code></a> ，它不需要任何参数。 我们还连接了一个回调，用于在激活动作时关闭窗口。 最后，我们通过 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/prelude/trait.ActionMapExtManual.html#method.add_action_entries"><code>add_action_entries</code></a>将操作条目添加到窗口中。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/1/main.rs">listings/actions/1/main.rs</a></p>
<pre><code class="language-rust no_run"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, ApplicationWindow};
</span><span class="boring">
</span>const APP_ID: &amp;str = "org.gtk_rs.Actions1";

fn main() -&gt; glib::ExitCode {
    // Create a new application
    let app = Application::builder().application_id(APP_ID).build();

    // Connect to "activate" signal of `app`
    app.connect_activate(build_ui);

    // Set keyboard accelerator to trigger "win.close".
    app.set_accels_for_action("win.close", &amp;["&lt;Ctrl&gt;W"]);

    // Run the application
    app.run()
}
<span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window and set the title
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .width_request(360)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Add action "close" to `window` taking no parameter
</span><span class="boring">    let action_close = ActionEntry::builder("close")
</span><span class="boring">        .activate(|window: &amp;ApplicationWindow, _, _| {
</span><span class="boring">            window.close();
</span><span class="boring">        })
</span><span class="boring">        .build();
</span><span class="boring">    window.add_action_entries([action_close]);
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>使用动作的最常见原因之一是快捷键，因此我们在此添加了一个。 通过  <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.GtkApplicationExt.html#tymethod.set_accels_for_action"><code>set_accels_for_action</code></a>，可以为某个动作分配一个或多个快捷键。 有关 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/functions/fn.accelerator_parse.html"><code>accelerator_parse</code></a>的语法，请查阅文档。</p>
<p>在我们继续讨论动作的其他方面之前，让我们先来了解一下这里的一些奇特之处。 "win.close" 中的 "win" 是动作组。 但 GTK 如何知道 "win" 是我们窗口的动作组呢？ 答案是，在窗口和应用程序中添加操作非常普遍，因此已经有两个预定义的组可用：</p>
<ul>
<li>"app" 用于应用程序的全局动作，</li>
<li>"win" 用于与应用程序窗口相关的动作。</li>
</ul>
<p>我们可以通过  <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/prelude/trait.WidgetExt.html#method.insert_action_group"><code>insert_action_group</code></a> 方法为任何控件添加动作组。 让我们将动作添加到动作组 "custom-group"，然后将该组添加到我们的窗口。该动作项(action entry)不再是针对我们的窗口，"activate（激活）" 回调的第一个参数类型是 <code>SimpleActionGroup</code>，而不是 <code>ApplicationWindow</code>。 这意味着我们必须将窗口克隆到闭包中。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/2/main.rs">listings/actions/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::gio::SimpleActionGroup;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Actions2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">    // Set keyboard accelerator to trigger "custom-group.close".
</span><span class="boring">    app.set_accels_for_action("custom-group.close", &amp;["&lt;Ctrl&gt;W"]);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Create a window and set the title
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .width_request(360)
        .build();

    // Add action "close" to `window` taking no parameter
    let action_close = ActionEntry::builder("close")
        .activate(clone!(
            #[weak]
            window,
            move |_, _, _| {
                window.close();
            }
        ))
        .build();

    // Create a new action group and add actions to it
    let actions = SimpleActionGroup::new();
    actions.add_action_entries([action_close]);
    window.insert_action_group("custom-group", Some(&amp;actions));

    // Present window
    window.present();
}</code></pre>
<p>如果我们将快捷键绑定到 "custom-group.close"，它就会像以前一样工作。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/2/main.rs">listings/actions/2/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use glib::clone;
</span><span class="boring">use gtk::gio::SimpleActionGroup;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Actions2";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span>    // Set keyboard accelerator to trigger "custom-group.close".
    app.set_accels_for_action("custom-group.close", &amp;["&lt;Ctrl&gt;W"]);
<span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Create a window and set the title
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .width_request(360)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Add action "close" to `window` taking no parameter
</span><span class="boring">    let action_close = ActionEntry::builder("close")
</span><span class="boring">        .activate(clone!(
</span><span class="boring">            #[weak]
</span><span class="boring">            window,
</span><span class="boring">            move |_, _, _| {
</span><span class="boring">                window.close();
</span><span class="boring">            }
</span><span class="boring">        ))
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Create a new action group and add actions to it
</span><span class="boring">    let actions = SimpleActionGroup::new();
</span><span class="boring">    actions.add_action_entries([action_close]);
</span><span class="boring">    window.insert_action_group("custom-group", Some(&amp;actions));
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>此外，如果我们有多个相同窗口的实例，我们会希望在激活 "win.close" 时只关闭当前聚焦的窗口。 事实上，"win.close" 将被派发到当前聚焦的窗口。 不过，这也意味着我们实际上为每个窗口实例定义了一个动作。 如果我们想使用一个全局动作，可以在<strong>应用程序</strong>上调用 <code>add_action_entries</code>.</p>
<blockquote>
<p>添加 "win.close" 作为一个简单的示例非常有用。 不过，今后我们将使用预定义的  <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Window.html#actions">"window.close"</a> 操作，其作用完全相同。</p>
</blockquote>
<h2 id="参数和状态"><a class="header" href="#参数和状态">参数和状态</a></h2>
<p>与大多数函数一样，动作可以接受一个参数。 不过，与大多数函数不同的是，它也可以是有状态的。 让我们看看它是如何工作的。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/3/main.rs">listings/actions/3/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Align, Application, ApplicationWindow, Button, Label, Orientation,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Actions3";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    let original_state = 0;
    let label = Label::builder()
        .label(format!("Counter: {original_state}"))
        .build();

    // Create a button with label
    let button = Button::builder().label("Press me!").build();

    // Connect to "clicked" signal of `button`
    button.connect_clicked(move |button| {
        // Activate "win.count" and pass "1" as parameter
        let parameter = 1;
        button
            .activate_action("win.count", Some(&amp;parameter.to_variant()))
            .expect("The action does not exist.");
    });

    // Create a `gtk::Box` and add `button` and `label` to it
    let gtk_box = gtk::Box::builder()
        .orientation(Orientation::Vertical)
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .spacing(12)
        .halign(Align::Center)
        .build();
    gtk_box.append(&amp;button);
    gtk_box.append(&amp;label);

    // Create a window, set the title and add `gtk_box` to it
    let window = ApplicationWindow::builder()
        .application(app)
        .title("My GTK App")
        .width_request(360)
        .child(&amp;gtk_box)
        .build();

    // Add action "count" to `window` taking an integer as parameter
    let action_count = ActionEntry::builder("count")
        .parameter_type(Some(&amp;i32::static_variant_type()))
        .state(original_state.to_variant())
        .activate(move |_, action, parameter| {
            // Get state
            let mut state = action
                .state()
                .expect("Could not get state.")
                .get::&lt;i32&gt;()
                .expect("The variant needs to be of type `i32`.");

            // Get parameter
            let parameter = parameter
                .expect("Could not get parameter.")
                .get::&lt;i32&gt;()
                .expect("The variant needs to be of type `i32`.");

            // Increase state by parameter and store state
            state += parameter;
            action.set_state(&amp;state.to_variant());

            // Update label with new state
            label.set_label(&amp;format!("Counter: {state}"));
        })
        .build();
    window.add_action_entries([action_count]);

    // Present window
    window.present();
}</code></pre>
<p>在这里，我们创建了一个 "win.count" 动作，每次激活时都会按给定参数增加状态。 它还负责用当前状态更新标签。 每次点击按钮都会激活动作，同时将 "1" 作为参数传递。 我们的应用程序就是这样运行的：</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/actions_counter.webm" type="video/webm">
  <p>A video which shows that pressing on one button also changes the label below</p>
 </video>
</div>
<h2 id="可执行动作的actionable"><a class="header" href="#可执行动作的actionable">可执行动作的(Actionable)</a></h2>
<p>将动作连接到按钮的 "clicked"（点击）信号是一个典型的使用案例，这就是为什么所有按钮都实现了 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Actionable.html"><code>Actionable</code></a> 接口。 这样，就可以通过设置 "action-name" 属性来指定动作。 如果动作接受参数，则可通过 "action-target" 属性进行设置。 有了 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/builders/struct.ButtonBuilder.html"><code>ButtonBuilder</code></a>, 我们可以通过调用其方法来设置一切。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/4/main.rs">listings/actions/4/main.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::ActionEntry;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{
</span><span class="boring">    gio, glib, Align, Application, ApplicationWindow, Button, Label, Orientation,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const APP_ID: &amp;str = "org.gtk_rs.Actions4";
</span><span class="boring">
</span><span class="boring">fn main() -&gt; glib::ExitCode {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder().application_id(APP_ID).build();
</span><span class="boring">
</span><span class="boring">    // Connect to "activate" signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    let original_state = 0;
</span><span class="boring">    let label = Label::builder()
</span><span class="boring">        .label(format!("Counter: {original_state}"))
</span><span class="boring">        .build();
</span>    // Create a button with label and action
    let button = Button::builder()
        .label("Press me!")
        .action_name("win.count")
        .action_target(&amp;1.to_variant())
        .build();
<span class="boring">
</span><span class="boring">    // Create `gtk_box` and add `button` and `label` to it
</span><span class="boring">    let gtk_box = gtk::Box::builder()
</span><span class="boring">        .orientation(Orientation::Vertical)
</span><span class="boring">        .margin_top(12)
</span><span class="boring">        .margin_bottom(12)
</span><span class="boring">        .margin_start(12)
</span><span class="boring">        .margin_end(12)
</span><span class="boring">        .spacing(12)
</span><span class="boring">        .halign(Align::Center)
</span><span class="boring">        .build();
</span><span class="boring">    gtk_box.append(&amp;button);
</span><span class="boring">    gtk_box.append(&amp;label);
</span><span class="boring">
</span><span class="boring">    // Create a window and set the title
</span><span class="boring">    let window = ApplicationWindow::builder()
</span><span class="boring">        .application(app)
</span><span class="boring">        .title("My GTK App")
</span><span class="boring">        .width_request(360)
</span><span class="boring">        .child(&amp;gtk_box)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Add action "count" to `window` taking an integer as parameter
</span><span class="boring">    let action_count = ActionEntry::builder("count")
</span><span class="boring">        .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">        .state(original_state.to_variant())
</span><span class="boring">        .activate(move |_, action, parameter| {
</span><span class="boring">            // Get state
</span><span class="boring">            let mut state = action
</span><span class="boring">                .state()
</span><span class="boring">                .expect("Could not get state.")
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">            // Get parameter
</span><span class="boring">            let parameter = parameter
</span><span class="boring">                .expect("Could not get parameter.")
</span><span class="boring">                .get::&lt;i32&gt;()
</span><span class="boring">                .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">            // Increase state by parameter and store state
</span><span class="boring">            state += parameter;
</span><span class="boring">            action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">            // Update label with new state
</span><span class="boring">            label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">        })
</span><span class="boring">        .build();
</span><span class="boring">    window.add_action_entries([action_count]);
</span><span class="boring">
</span><span class="boring">    // Present window
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<p>还可以通过界面生成器轻松访问可执行动作的部件。 像往常一样，我们通过一个复合模板来创建窗口。 然后，我们可以在模板中设置 "动作名称(action-name)"和 "动作目标(action-target)"属性。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/5/resources/window.ui">listings/actions/5/resources/window.ui</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;interface&gt;
  &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
    &lt;property name="title"&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class="GtkBox" id="gtk_box"&gt;
        &lt;property name="orientation"&gt;vertical&lt;/property&gt;
        &lt;property name="margin-top"&gt;12&lt;/property&gt;
        &lt;property name="margin-bottom"&gt;12&lt;/property&gt;
        &lt;property name="margin-start"&gt;12&lt;/property&gt;
        &lt;property name="margin-end"&gt;12&lt;/property&gt;
        &lt;property name="spacing"&gt;12&lt;/property&gt;
        &lt;property name="halign"&gt;center&lt;/property&gt;
        &lt;child&gt;
          &lt;object class="GtkButton" id="button"&gt;
            &lt;property name="label"&gt;Press me!&lt;/property&gt;
            &lt;property name="action-name"&gt;win.count&lt;/property&gt;
            &lt;property name="action-target"&gt;1&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class="GtkLabel" id="label"&gt;
            &lt;property name="label"&gt;Counter: 0&lt;/property&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>我们将在 <code>Window::setup_actions</code> 方法中连接操作并将其添加到窗口。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/5/window/mod.rs">listings/actions/5/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::ActionEntry;
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span>impl Window {
    pub fn new(app: &amp;Application) -&gt; Self {
        // Create new window
        Object::builder().property("application", app).build()
    }

    fn setup_actions(&amp;self) {
        // Add stateful action "count" to `window` taking an integer as parameter
        let original_state = 0;
        let action_count = ActionEntry::builder("count")
            .parameter_type(Some(&amp;i32::static_variant_type()))
            .state(original_state.to_variant())
            .activate(move |window: &amp;Self, action, parameter| {
                // Get state
                let mut state = action
                    .state()
                    .expect("Could not get state.")
                    .get::&lt;i32&gt;()
                    .expect("The variant needs to be of type `i32`.");

                // Get parameter
                let parameter = parameter
                    .expect("Could not get parameter.")
                    .get::&lt;i32&gt;()
                    .expect("The variant needs to be of type `i32`.");

                // Increase state by parameter and store state
                state += parameter;
                action.set_state(&amp;state.to_variant());

                // Update label with new state
                window.imp().label.set_label(&amp;format!("Counter: {state}"));
            })
            .build();
        self.add_action_entries([action_count]);
    }
}</code></pre>
<p>最后，<code>setup_actions</code> 将在 <code>constructed</code> 函数内调用。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/5/window/imp.rs">listings/actions/5/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CompositeTemplate, Label};
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/example/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub label: TemplateChild&lt;Label&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        // Call "constructed" on parent
        self.parent_constructed();

        // Add actions
        self.obj().setup_actions();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>该应用程序的行为与我们之前的示例相同，但它将使我们在下一部分添加菜单时更加简单。</p>
<h2 id="菜单"><a class="header" href="#菜单">菜单</a></h2>
<p>如果要创建<a href="https://developer.gnome.org/hig/patterns/controls/menus.html">菜单</a>，就必须使用动作，而且要使用界面生成器。 通常情况下，菜单条目中的操作符合以下三种描述之一：</p>
<ul>
<li>无参数和无状态，</li>
<li>或无参数和布尔状态，</li>
<li>或字符串参数和字符串状态。</li>
</ul>
<p>让我们修改我们的小程序来演示这些情况。 首先，我们扩展 <code>setup_actions</code>。 对于不带参数或状态的动作，我们可以使用预定义的 "window.close" 动作。 因此，我们无需在此处添加任何内容。</p>
<p>通过动作 "button-frame"，我们可以操作按钮的 "has-frame" 属性。 这里的惯例是，不带参数并且为布尔状态的操作应该像切换操作一样。 这意味着调用者可以期待布尔状态在激活动作后切换。 幸运的是，这正是带有布尔属性的 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.PropertyAction.html"><code>gio::PropertyAction</code></a> 的默认行为。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/6/window/mod.rs">listings/actions/6/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{ActionEntry, PropertyAction};
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, Orientation};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Add stateful action "count" to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = ActionEntry::builder("count")
</span><span class="boring">            .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">            .state(original_state.to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get state
</span><span class="boring">                let mut state = action
</span><span class="boring">                    .state()
</span><span class="boring">                    .expect("Could not get state.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Increase state by parameter and store state
</span><span class="boring">                state += parameter;
</span><span class="boring">                action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">                // Update label with new state
</span><span class="boring">                window.imp().label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">            })
</span><span class="boring">            .build();
</span>        // Add property action "button-frame" to `window`
        let button = self.imp().button.get();
        let action_button_frame =
            PropertyAction::new("button-frame", &amp;button, "has-frame");
        self.add_action(&amp;action_button_frame);
<span class="boring">
</span><span class="boring">        // Add stateful action "orientation" to `window` taking a string as parameter
</span><span class="boring">        let action_orientation = ActionEntry::builder("orientation")
</span><span class="boring">            .parameter_type(Some(&amp;String::static_variant_type()))
</span><span class="boring">            .state("Vertical".to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;String&gt;()
</span><span class="boring">                    .expect("The value needs to be of type `String`.");
</span><span class="boring">
</span><span class="boring">                let orientation = match parameter.as_str() {
</span><span class="boring">                    "Horizontal" =&gt; Orientation::Horizontal,
</span><span class="boring">                    "Vertical" =&gt; Orientation::Vertical,
</span><span class="boring">                    _ =&gt; unreachable!(),
</span><span class="boring">                };
</span><span class="boring">
</span><span class="boring">                // Set orientation and save state
</span><span class="boring">                window.imp().gtk_box.set_orientation(orientation);
</span><span class="boring">                action.set_state(&amp;parameter.to_variant());
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        self.add_action_entries([action_count, action_orientation]);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<blockquote>
<p>当您需要一个操作 GObject 属性的动作时，<code>PropertyAction</code> 就会派上用场。 属性将作为动作的状态。 如上所述，如果属性是布尔型，则动作没有参数，并在激活时切换属性。 在所有其他情况下，操作都有一个与属性类型相同的参数。 激活动作时，属性会被设置为与动作参数相同的值。</p>
</blockquote>
<p>最后，我们添加了 "win.orientation"，一个带有字符串参数和字符串状态的动作。 该操作可用于改变 <code>gtk_box</code> 的朝向。 这里的惯例是状态(state)应设置为给定的参数。 我们并不需要动作状态来实现方向切换，但它在使菜单显示当前朝向时非常有用。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/6/window/mod.rs">listings/actions/6/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{ActionEntry, PropertyAction};
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, Orientation};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Add stateful action "count" to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = ActionEntry::builder("count")
</span><span class="boring">            .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">            .state(original_state.to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get state
</span><span class="boring">                let mut state = action
</span><span class="boring">                    .state()
</span><span class="boring">                    .expect("Could not get state.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Increase state by parameter and store state
</span><span class="boring">                state += parameter;
</span><span class="boring">                action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">                // Update label with new state
</span><span class="boring">                window.imp().label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        // Add property action "button-frame" to `window`
</span><span class="boring">        let button = self.imp().button.get();
</span><span class="boring">        let action_button_frame =
</span><span class="boring">            PropertyAction::new("button-frame", &amp;button, "has-frame");
</span><span class="boring">        self.add_action(&amp;action_button_frame);
</span><span class="boring">
</span>        // Add stateful action "orientation" to `window` taking a string as parameter
        let action_orientation = ActionEntry::builder("orientation")
            .parameter_type(Some(&amp;String::static_variant_type()))
            .state("Vertical".to_variant())
            .activate(move |window: &amp;Self, action, parameter| {
                // Get parameter
                let parameter = parameter
                    .expect("Could not get parameter.")
                    .get::&lt;String&gt;()
                    .expect("The value needs to be of type `String`.");

                let orientation = match parameter.as_str() {
                    "Horizontal" =&gt; Orientation::Horizontal,
                    "Vertical" =&gt; Orientation::Vertical,
                    _ =&gt; unreachable!(),
                };

                // Set orientation and save state
                window.imp().gtk_box.set_orientation(orientation);
                action.set_state(&amp;parameter.to_variant());
            })
            .build();
        self.add_action_entries([action_count, action_orientation]);
<span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>尽管 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Menu.html"><code>gio::Menu</code></a> 也可以通过绑定创建，但最方便的方法还是使用界面生成器。 我们可以在模板前添加菜单。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/6/resources/window.ui">listings/actions/6/resources/window.ui</a></p>
<pre><code class="language-diff"> &lt;?xml version="1.0" encoding="UTF-8"?&gt;
 &lt;interface&gt;
+  &lt;menu id="main-menu"&gt;
+    &lt;item&gt;
+      &lt;attribute name="label" translatable="yes"&gt;_Close window&lt;/attribute&gt;
+      &lt;attribute name="action"&gt;window.close&lt;/attribute&gt;
+    &lt;/item&gt;
+    &lt;item&gt;
+      &lt;attribute name="label" translatable="yes"&gt;_Toggle button frame&lt;/attribute&gt;
+      &lt;attribute name="action"&gt;win.button-frame&lt;/attribute&gt;
+    &lt;/item&gt;
+    &lt;section&gt;
+      &lt;attribute name="label" translatable="yes"&gt;Orientation&lt;/attribute&gt;
+      &lt;item&gt;
+        &lt;attribute name="label" translatable="yes"&gt;_Horizontal&lt;/attribute&gt;
+        &lt;attribute name="action"&gt;win.orientation&lt;/attribute&gt;
+        &lt;attribute name="target"&gt;Horizontal&lt;/attribute&gt;
+      &lt;/item&gt;
+      &lt;item&gt;
+        &lt;attribute name="label" translatable="yes"&gt;_Vertical&lt;/attribute&gt;
+        &lt;attribute name="action"&gt;win.orientation&lt;/attribute&gt;
+        &lt;attribute name="target"&gt;Vertical&lt;/attribute&gt;
+      &lt;/item&gt;
+    &lt;/section&gt;
+  &lt;/menu&gt;
   &lt;template class="MyGtkAppWindow" parent="GtkApplicationWindow"&gt;
     &lt;property name="title"&gt;My GTK App&lt;/property&gt;
+    &lt;property name="width-request"&gt;360&lt;/property&gt;
+    &lt;child type="titlebar"&gt;
+      &lt;object class="GtkHeaderBar"&gt;
+        &lt;child type ="end"&gt;
+          &lt;object class="GtkMenuButton"&gt;
+            &lt;property name="icon-name"&gt;open-menu-symbolic&lt;/property&gt;
+            &lt;property name="menu-model"&gt;main-menu&lt;/property&gt;
+          &lt;/object&gt;
+        &lt;/child&gt;
+      &lt;/object&gt;
+    &lt;/child&gt;
     &lt;child&gt;
       &lt;object class="GtkBox" id="gtk_box"&gt;
         &lt;property name="orientation"&gt;vertical&lt;/property&gt;
</code></pre>
<p>由于我们通过 <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.MenuButton.html#menu-model">menu-model</a> 属性将菜单连接到了  <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.MenuButton.html"><code>gtk::MenuButton</code></a> ，因此菜单(<code>Menu</code>)应为  <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.PopoverMenu.html"><code>gtk::PopoverMenu</code></a>. <code>PopoverMenu</code> 的<a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.PopoverMenu.html">文档</a>还为界面生成器解释了其 xml 语法。</p>
<p>还要注意我们是如何指定目标的：</p>
<pre><code class="language-xml">&lt;attribute name="target"&gt;Horizontal&lt;/attribute&gt;
</code></pre>
<p>字符串是目标的默认类型，因此我们无需指定类型。 对于其他类型的目标，则需要手动指定正确的 <a href="https://docs.gtk.org/glib/gvariant-format-strings.html">GVariant 格式字符串</a>。 例如，一个值为 "5 "的 <code>i32</code> 变量对应的格式如下：</p>
<pre><code class="language-xml">&lt;attribute name="target" type="i"&gt;5&lt;/attribute&gt;
</code></pre>
<p>这就是该应用程序的实际效果：</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/actions_menu.webm" type="video/webm">
  <p>A video which now also shows the menu</p>
 </video>
</div>
<blockquote>
<p>我们将菜单按钮(<code>MenuButton</code>)的属性 "icon-name" 设置为 "open-menu-symbolic"，从而更改了菜单按钮的图标。 您可以在<a href="https://flathub.org/apps/org.gnome.design.IconLibrary">图标库</a>中找到更多图标。 这些图标可以嵌入  <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Resource.html"><code>gio::Resource</code></a> ，然后在合成模板（或其他地方）中引用。</p>
</blockquote>
<h2 id="设置settings"><a class="header" href="#设置settings">设置(Settings)</a></h2>
<p>菜单项很好地显示了有状态动作的状态，但在应用程序关闭后，对该状态的所有更改都会丢失。 像往常一样，我们使用 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Settings.html"><code>gio::Settings</code></a> 解决这个问题。 首先，我们创建一个 schema，其中包含与之前创建的有状态操作相对应的设置。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/7/org.gtk_rs.Actions7.gschema.xml">listings/actions/7/org.gtk_rs.Actions7.gschema.xml</a></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;schemalist&gt;
  &lt;schema id="org.gtk_rs.Actions7" path="/org/gtk_rs/Actions7/"&gt;
    &lt;key name="button-frame" type="b"&gt;
      &lt;default&gt;true&lt;/default&gt;
      &lt;summary&gt;Whether the button has a frame&lt;/summary&gt;
    &lt;/key&gt;
    &lt;key name="orientation" type="s"&gt;
      &lt;choices&gt;
        &lt;choice value='Horizontal'/&gt;
        &lt;choice value='Vertical'/&gt;
      &lt;/choices&gt;
      &lt;default&gt;'Vertical'&lt;/default&gt;
      &lt;summary&gt;Orientation of GtkBox&lt;/summary&gt;
    &lt;/key&gt;
  &lt;/schema&gt;
&lt;/schemalist&gt;
</code></pre>
<p>同样，我们按照<a href="">设置一章</a>中描述来安装 schema. 然后将设置添加到 <code>imp::Window</code>. 由于 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/struct.Settings.html"><code>gio::Settings</code></a> 没有实现 <code>Default</code>，我们将其封装在 <a href="https://doc.rust-lang.org/std/cell/struct.OnceCell.html"><code>std::cell::OnceCell</code></a> 中。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/7/window/imp.rs">listings/actions/7/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Button, CompositeTemplate, Label};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/gtk_rs/example/window.ui")]
pub struct Window {
    #[template_child]
    pub gtk_box: TemplateChild&lt;gtk::Box&gt;,
    #[template_child]
    pub button: TemplateChild&lt;Button&gt;,
    #[template_child]
    pub label: TemplateChild&lt;Label&gt;,
    pub settings: OnceCell&lt;Settings&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self) {
</span><span class="boring">        // Call "constructed" on parent
</span><span class="boring">        self.parent_constructed();
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        let obj = self.obj();
</span><span class="boring">        obj.setup_settings();
</span><span class="boring">        obj.setup_actions();
</span><span class="boring">        obj.bind_settings();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>现在，我们创建一些函数，使设置更容易访问。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/7/window/mod.rs">listings/actions/7/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{ActionEntry, Settings};
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, Orientation};
</span><span class="boring">
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_settings(&amp;self) {
        let settings = Settings::new(APP_ID);
        self.imp()
            .settings
            .set(settings)
            .expect("`settings` should not be set before calling `setup_settings`.");
    }

    fn settings(&amp;self) -&gt; &amp;Settings {
        self.imp()
            .settings
            .get()
            .expect("`settings` should be set in `setup_settings`.")
    }
<span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Add stateful action "count" to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = ActionEntry::builder("count")
</span><span class="boring">            .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">            .state(original_state.to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get state
</span><span class="boring">                let mut state = action
</span><span class="boring">                    .state()
</span><span class="boring">                    .expect("Could not get state.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Increase state by parameter and store state
</span><span class="boring">                state += parameter;
</span><span class="boring">                action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">                // Update label with new state
</span><span class="boring">                window.imp().label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        self.add_action_entries([action_count]);
</span><span class="boring">
</span><span class="boring">        // Create action from key "button-frame" and add to action group "win"
</span><span class="boring">        let action_button_frame = self.settings().create_action("button-frame");
</span><span class="boring">        self.add_action(&amp;action_button_frame);
</span><span class="boring">
</span><span class="boring">        // Create action from key "orientation" and add to action group "win"
</span><span class="boring">        let action_orientation = self.settings().create_action("orientation");
</span><span class="boring">        self.add_action(&amp;action_orientation);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn bind_settings(&amp;self) {
</span><span class="boring">        // Bind setting "button-frame" to "has-frame" property of `button`
</span><span class="boring">        let button = self.imp().button.get();
</span><span class="boring">        self.settings()
</span><span class="boring">            .bind("button-frame", &amp;button, "has-frame")
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Bind setting "orientation" to "orientation" property of `button`
</span><span class="boring">        let gtk_box = self.imp().gtk_box.get();
</span><span class="boring">        self.settings()
</span><span class="boring">            .bind("orientation", &amp;gtk_box, "orientation")
</span><span class="boring">            .mapping(|variant, _| {
</span><span class="boring">                let orientation = variant
</span><span class="boring">                    .get::&lt;String&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `String`.");
</span><span class="boring">
</span><span class="boring">                let orientation = match orientation.as_str() {
</span><span class="boring">                    "Horizontal" =&gt; Orientation::Horizontal,
</span><span class="boring">                    "Vertical" =&gt; Orientation::Vertical,
</span><span class="boring">                    _ =&gt; unreachable!(),
</span><span class="boring">                };
</span><span class="boring">
</span><span class="boring">                Some(orientation.to_value())
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>通过设置条目创建有状态的动作非常常见，因此<code>设置(Settings)</code>提供了一种方法来实现这一目的。 我们使用 <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/gio/prelude/trait.SettingsExt.html#tymethod.create_action"> <code>create_action</code></a> 方法创建动作，然后将其添加到窗口的动作组中。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/7/window/mod.rs">listings/actions/7/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{ActionEntry, Settings};
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, Orientation};
</span><span class="boring">
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Add stateful action "count" to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = ActionEntry::builder("count")
</span><span class="boring">            .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">            .state(original_state.to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get state
</span><span class="boring">                let mut state = action
</span><span class="boring">                    .state()
</span><span class="boring">                    .expect("Could not get state.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Increase state by parameter and store state
</span><span class="boring">                state += parameter;
</span><span class="boring">                action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">                // Update label with new state
</span><span class="boring">                window.imp().label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        self.add_action_entries([action_count]);
</span><span class="boring">
</span>        // Create action from key "button-frame" and add to action group "win"
        let action_button_frame = self.settings().create_action("button-frame");
        self.add_action(&amp;action_button_frame);

        // Create action from key "orientation" and add to action group "win"
        let action_orientation = self.settings().create_action("orientation");
        self.add_action(&amp;action_orientation);
<span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn bind_settings(&amp;self) {
</span><span class="boring">        // Bind setting "button-frame" to "has-frame" property of `button`
</span><span class="boring">        let button = self.imp().button.get();
</span><span class="boring">        self.settings()
</span><span class="boring">            .bind("button-frame", &amp;button, "has-frame")
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        // Bind setting "orientation" to "orientation" property of `button`
</span><span class="boring">        let gtk_box = self.imp().gtk_box.get();
</span><span class="boring">        self.settings()
</span><span class="boring">            .bind("orientation", &amp;gtk_box, "orientation")
</span><span class="boring">            .mapping(|variant, _| {
</span><span class="boring">                let orientation = variant
</span><span class="boring">                    .get::&lt;String&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `String`.");
</span><span class="boring">
</span><span class="boring">                let orientation = match orientation.as_str() {
</span><span class="boring">                    "Horizontal" =&gt; Orientation::Horizontal,
</span><span class="boring">                    "Vertical" =&gt; Orientation::Vertical,
</span><span class="boring">                    _ =&gt; unreachable!(),
</span><span class="boring">                };
</span><span class="boring">
</span><span class="boring">                Some(orientation.to_value())
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>由于来自 <code>create_action</code> 的动作遵循上述约定，我们可以尽量减少进一步的改动。 每次激活时，"win.button-frame" 动作都会切换其状态，而 "win.orientation" 动作的状态则遵循给定的参数。</p>
<p>不过，我们仍需指定动作激活时应发生的情况。 对于有状态的操作，我们不用为它的"激活"信号添加回调，而是将设置绑定到我们要操作的属性上。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/7/window/mod.rs">listings/actions/7/window/mod.rs</a></p>
<pre><code class="language-rust"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use gio::{ActionEntry, Settings};
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Application, Orientation};
</span><span class="boring">
</span><span class="boring">use crate::APP_ID;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::builder().property("application", app).build()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_settings(&amp;self) {
</span><span class="boring">        let settings = Settings::new(APP_ID);
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .set(settings)
</span><span class="boring">            .expect("`settings` should not be set before calling `setup_settings`.");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn settings(&amp;self) -&gt; &amp;Settings {
</span><span class="boring">        self.imp()
</span><span class="boring">            .settings
</span><span class="boring">            .get()
</span><span class="boring">            .expect("`settings` should be set in `setup_settings`.")
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_actions(&amp;self) {
</span><span class="boring">        // Add stateful action "count" to `window` taking an integer as parameter
</span><span class="boring">        let original_state = 0;
</span><span class="boring">        let action_count = ActionEntry::builder("count")
</span><span class="boring">            .parameter_type(Some(&amp;i32::static_variant_type()))
</span><span class="boring">            .state(original_state.to_variant())
</span><span class="boring">            .activate(move |window: &amp;Self, action, parameter| {
</span><span class="boring">                // Get state
</span><span class="boring">                let mut state = action
</span><span class="boring">                    .state()
</span><span class="boring">                    .expect("Could not get state.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Get parameter
</span><span class="boring">                let parameter = parameter
</span><span class="boring">                    .expect("Could not get parameter.")
</span><span class="boring">                    .get::&lt;i32&gt;()
</span><span class="boring">                    .expect("The variant needs to be of type `i32`.");
</span><span class="boring">
</span><span class="boring">                // Increase state by parameter and store state
</span><span class="boring">                state += parameter;
</span><span class="boring">                action.set_state(&amp;state.to_variant());
</span><span class="boring">
</span><span class="boring">                // Update label with new state
</span><span class="boring">                window.imp().label.set_label(&amp;format!("Counter: {state}"));
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        self.add_action_entries([action_count]);
</span><span class="boring">
</span><span class="boring">        // Create action from key "button-frame" and add to action group "win"
</span><span class="boring">        let action_button_frame = self.settings().create_action("button-frame");
</span><span class="boring">        self.add_action(&amp;action_button_frame);
</span><span class="boring">
</span><span class="boring">        // Create action from key "orientation" and add to action group "win"
</span><span class="boring">        let action_orientation = self.settings().create_action("orientation");
</span><span class="boring">        self.add_action(&amp;action_orientation);
</span><span class="boring">    }
</span><span class="boring">
</span>    fn bind_settings(&amp;self) {
        // Bind setting "button-frame" to "has-frame" property of `button`
        let button = self.imp().button.get();
        self.settings()
            .bind("button-frame", &amp;button, "has-frame")
            .build();

        // Bind setting "orientation" to "orientation" property of `button`
        let gtk_box = self.imp().gtk_box.get();
        self.settings()
            .bind("orientation", &amp;gtk_box, "orientation")
            .mapping(|variant, _| {
                let orientation = variant
                    .get::&lt;String&gt;()
                    .expect("The variant needs to be of type `String`.");

                let orientation = match orientation.as_str() {
                    "Horizontal" =&gt; Orientation::Horizontal,
                    "Vertical" =&gt; Orientation::Vertical,
                    _ =&gt; unreachable!(),
                };

                Some(orientation.to_value())
            })
            .build();
    }
<span class="boring">}</span></code></pre>
<p>最后，我们要确保 <code>bind_settings</code> 在构造(<code>constructed</code>)内部被调用。</p>
<p>文件名：<a class=file-link href="https://github.com/gtk-rs/gtk4-rs/blob/master/book/listings/actions/7/window/imp.rs">listings/actions/7/window/imp.rs</a></p>
<pre><code class="language-rust"><span class="boring">use gio::Settings;
</span><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib, Button, CompositeTemplate, Label};
</span><span class="boring">use std::cell::OnceCell;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(resource = "/org/gtk_rs/example/window.ui")]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub gtk_box: TemplateChild&lt;gtk::Box&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub button: TemplateChild&lt;Button&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub label: TemplateChild&lt;Label&gt;,
</span><span class="boring">    pub settings: OnceCell&lt;Settings&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = "MyGtkAppWindow";
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self) {
        // Call "constructed" on parent
        self.parent_constructed();

        // Setup
        let obj = self.obj();
        obj.setup_settings();
        obj.setup_actions();
        obj.bind_settings();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application windows
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>动作的功能非常强大，我们在此只是浅尝辄止。 如果您想了解更多，<a href="https://developer.gnome.org/documentation/tutorials/actions.html">GNOME 开发者文档</a>是一个很好的开始。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="todo_1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="todo_2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="todo_1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="todo_2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
